/*
Copyright 2023 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was generated by "go run gen/main.go > gen.go". Do not edit
// directly.

package cloud

import (
	"context"
	"fmt"
	"net/http"
	"sync"

	"google.golang.org/api/googleapi"
	"k8s.io/klog/v2"

	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/filter"
	"github.com/GoogleCloudPlatform/k8s-cloud-provider/pkg/cloud/meta"

	computealpha "google.golang.org/api/compute/v0.alpha"
	computebeta "google.golang.org/api/compute/v0.beta"
	computega "google.golang.org/api/compute/v1"
	networkservicesga "google.golang.org/api/networkservices/v1"
	networkservicesbeta "google.golang.org/api/networkservices/v1beta1"
)

func kLogEnabled(level klog.Level) bool {
	return klog.V(level).Enabled() == true
}

// Cloud is an interface for the GCE compute API.
type Cloud interface {
	Addresses() Addresses
	AlphaAddresses() AlphaAddresses
	BetaAddresses() BetaAddresses
	AlphaGlobalAddresses() AlphaGlobalAddresses
	BetaGlobalAddresses() BetaGlobalAddresses
	GlobalAddresses() GlobalAddresses
	BackendServices() BackendServices
	BetaBackendServices() BetaBackendServices
	AlphaBackendServices() AlphaBackendServices
	RegionBackendServices() RegionBackendServices
	AlphaRegionBackendServices() AlphaRegionBackendServices
	BetaRegionBackendServices() BetaRegionBackendServices
	Disks() Disks
	RegionDisks() RegionDisks
	AlphaFirewalls() AlphaFirewalls
	BetaFirewalls() BetaFirewalls
	Firewalls() Firewalls
	AlphaNetworkFirewallPolicies() AlphaNetworkFirewallPolicies
	AlphaRegionNetworkFirewallPolicies() AlphaRegionNetworkFirewallPolicies
	ForwardingRules() ForwardingRules
	AlphaForwardingRules() AlphaForwardingRules
	BetaForwardingRules() BetaForwardingRules
	AlphaGlobalForwardingRules() AlphaGlobalForwardingRules
	BetaGlobalForwardingRules() BetaGlobalForwardingRules
	GlobalForwardingRules() GlobalForwardingRules
	HealthChecks() HealthChecks
	AlphaHealthChecks() AlphaHealthChecks
	BetaHealthChecks() BetaHealthChecks
	AlphaRegionHealthChecks() AlphaRegionHealthChecks
	BetaRegionHealthChecks() BetaRegionHealthChecks
	RegionHealthChecks() RegionHealthChecks
	HttpHealthChecks() HttpHealthChecks
	HttpsHealthChecks() HttpsHealthChecks
	InstanceGroups() InstanceGroups
	Instances() Instances
	BetaInstances() BetaInstances
	AlphaInstances() AlphaInstances
	InstanceGroupManagers() InstanceGroupManagers
	InstanceTemplates() InstanceTemplates
	Images() Images
	BetaImages() BetaImages
	AlphaImages() AlphaImages
	AlphaNetworks() AlphaNetworks
	BetaNetworks() BetaNetworks
	Networks() Networks
	AlphaNetworkEndpointGroups() AlphaNetworkEndpointGroups
	BetaNetworkEndpointGroups() BetaNetworkEndpointGroups
	NetworkEndpointGroups() NetworkEndpointGroups
	AlphaGlobalNetworkEndpointGroups() AlphaGlobalNetworkEndpointGroups
	BetaGlobalNetworkEndpointGroups() BetaGlobalNetworkEndpointGroups
	GlobalNetworkEndpointGroups() GlobalNetworkEndpointGroups
	Projects() Projects
	Regions() Regions
	AlphaRouters() AlphaRouters
	BetaRouters() BetaRouters
	Routers() Routers
	Routes() Routes
	BetaSecurityPolicies() BetaSecurityPolicies
	ServiceAttachments() ServiceAttachments
	BetaServiceAttachments() BetaServiceAttachments
	AlphaServiceAttachments() AlphaServiceAttachments
	SslCertificates() SslCertificates
	BetaSslCertificates() BetaSslCertificates
	AlphaSslCertificates() AlphaSslCertificates
	AlphaRegionSslCertificates() AlphaRegionSslCertificates
	BetaRegionSslCertificates() BetaRegionSslCertificates
	RegionSslCertificates() RegionSslCertificates
	SslPolicies() SslPolicies
	RegionSslPolicies() RegionSslPolicies
	AlphaSubnetworks() AlphaSubnetworks
	BetaSubnetworks() BetaSubnetworks
	Subnetworks() Subnetworks
	AlphaTargetHttpProxies() AlphaTargetHttpProxies
	BetaTargetHttpProxies() BetaTargetHttpProxies
	TargetHttpProxies() TargetHttpProxies
	AlphaRegionTargetHttpProxies() AlphaRegionTargetHttpProxies
	BetaRegionTargetHttpProxies() BetaRegionTargetHttpProxies
	RegionTargetHttpProxies() RegionTargetHttpProxies
	TargetHttpsProxies() TargetHttpsProxies
	AlphaTargetHttpsProxies() AlphaTargetHttpsProxies
	BetaTargetHttpsProxies() BetaTargetHttpsProxies
	AlphaRegionTargetHttpsProxies() AlphaRegionTargetHttpsProxies
	BetaRegionTargetHttpsProxies() BetaRegionTargetHttpsProxies
	RegionTargetHttpsProxies() RegionTargetHttpsProxies
	TargetPools() TargetPools
	AlphaTargetTcpProxies() AlphaTargetTcpProxies
	BetaTargetTcpProxies() BetaTargetTcpProxies
	TargetTcpProxies() TargetTcpProxies
	AlphaUrlMaps() AlphaUrlMaps
	BetaUrlMaps() BetaUrlMaps
	UrlMaps() UrlMaps
	AlphaRegionUrlMaps() AlphaRegionUrlMaps
	BetaRegionUrlMaps() BetaRegionUrlMaps
	RegionUrlMaps() RegionUrlMaps
	Zones() Zones
	TcpRoutes() TcpRoutes
	BetaTcpRoutes() BetaTcpRoutes
	Meshes() Meshes
	BetaMeshes() BetaMeshes
}

// NewGCE returns a GCE.
func NewGCE(s *Service) *GCE {
	g := &GCE{
		gceAddresses:                          &GCEAddresses{s},
		gceAlphaAddresses:                     &GCEAlphaAddresses{s},
		gceBetaAddresses:                      &GCEBetaAddresses{s},
		gceAlphaGlobalAddresses:               &GCEAlphaGlobalAddresses{s},
		gceBetaGlobalAddresses:                &GCEBetaGlobalAddresses{s},
		gceGlobalAddresses:                    &GCEGlobalAddresses{s},
		gceBackendServices:                    &GCEBackendServices{s},
		gceBetaBackendServices:                &GCEBetaBackendServices{s},
		gceAlphaBackendServices:               &GCEAlphaBackendServices{s},
		gceRegionBackendServices:              &GCERegionBackendServices{s},
		gceAlphaRegionBackendServices:         &GCEAlphaRegionBackendServices{s},
		gceBetaRegionBackendServices:          &GCEBetaRegionBackendServices{s},
		gceDisks:                              &GCEDisks{s},
		gceRegionDisks:                        &GCERegionDisks{s},
		gceAlphaFirewalls:                     &GCEAlphaFirewalls{s},
		gceBetaFirewalls:                      &GCEBetaFirewalls{s},
		gceFirewalls:                          &GCEFirewalls{s},
		gceAlphaNetworkFirewallPolicies:       &GCEAlphaNetworkFirewallPolicies{s},
		gceAlphaRegionNetworkFirewallPolicies: &GCEAlphaRegionNetworkFirewallPolicies{s},
		gceForwardingRules:                    &GCEForwardingRules{s},
		gceAlphaForwardingRules:               &GCEAlphaForwardingRules{s},
		gceBetaForwardingRules:                &GCEBetaForwardingRules{s},
		gceAlphaGlobalForwardingRules:         &GCEAlphaGlobalForwardingRules{s},
		gceBetaGlobalForwardingRules:          &GCEBetaGlobalForwardingRules{s},
		gceGlobalForwardingRules:              &GCEGlobalForwardingRules{s},
		gceHealthChecks:                       &GCEHealthChecks{s},
		gceAlphaHealthChecks:                  &GCEAlphaHealthChecks{s},
		gceBetaHealthChecks:                   &GCEBetaHealthChecks{s},
		gceAlphaRegionHealthChecks:            &GCEAlphaRegionHealthChecks{s},
		gceBetaRegionHealthChecks:             &GCEBetaRegionHealthChecks{s},
		gceRegionHealthChecks:                 &GCERegionHealthChecks{s},
		gceHttpHealthChecks:                   &GCEHttpHealthChecks{s},
		gceHttpsHealthChecks:                  &GCEHttpsHealthChecks{s},
		gceInstanceGroups:                     &GCEInstanceGroups{s},
		gceInstances:                          &GCEInstances{s},
		gceBetaInstances:                      &GCEBetaInstances{s},
		gceAlphaInstances:                     &GCEAlphaInstances{s},
		gceInstanceGroupManagers:              &GCEInstanceGroupManagers{s},
		gceInstanceTemplates:                  &GCEInstanceTemplates{s},
		gceImages:                             &GCEImages{s},
		gceBetaImages:                         &GCEBetaImages{s},
		gceAlphaImages:                        &GCEAlphaImages{s},
		gceAlphaNetworks:                      &GCEAlphaNetworks{s},
		gceBetaNetworks:                       &GCEBetaNetworks{s},
		gceNetworks:                           &GCENetworks{s},
		gceAlphaNetworkEndpointGroups:         &GCEAlphaNetworkEndpointGroups{s},
		gceBetaNetworkEndpointGroups:          &GCEBetaNetworkEndpointGroups{s},
		gceNetworkEndpointGroups:              &GCENetworkEndpointGroups{s},
		gceAlphaGlobalNetworkEndpointGroups:   &GCEAlphaGlobalNetworkEndpointGroups{s},
		gceBetaGlobalNetworkEndpointGroups:    &GCEBetaGlobalNetworkEndpointGroups{s},
		gceGlobalNetworkEndpointGroups:        &GCEGlobalNetworkEndpointGroups{s},
		gceProjects:                           &GCEProjects{s},
		gceRegions:                            &GCERegions{s},
		gceAlphaRouters:                       &GCEAlphaRouters{s},
		gceBetaRouters:                        &GCEBetaRouters{s},
		gceRouters:                            &GCERouters{s},
		gceRoutes:                             &GCERoutes{s},
		gceBetaSecurityPolicies:               &GCEBetaSecurityPolicies{s},
		gceServiceAttachments:                 &GCEServiceAttachments{s},
		gceBetaServiceAttachments:             &GCEBetaServiceAttachments{s},
		gceAlphaServiceAttachments:            &GCEAlphaServiceAttachments{s},
		gceSslCertificates:                    &GCESslCertificates{s},
		gceBetaSslCertificates:                &GCEBetaSslCertificates{s},
		gceAlphaSslCertificates:               &GCEAlphaSslCertificates{s},
		gceAlphaRegionSslCertificates:         &GCEAlphaRegionSslCertificates{s},
		gceBetaRegionSslCertificates:          &GCEBetaRegionSslCertificates{s},
		gceRegionSslCertificates:              &GCERegionSslCertificates{s},
		gceSslPolicies:                        &GCESslPolicies{s},
		gceRegionSslPolicies:                  &GCERegionSslPolicies{s},
		gceAlphaSubnetworks:                   &GCEAlphaSubnetworks{s},
		gceBetaSubnetworks:                    &GCEBetaSubnetworks{s},
		gceSubnetworks:                        &GCESubnetworks{s},
		gceAlphaTargetHttpProxies:             &GCEAlphaTargetHttpProxies{s},
		gceBetaTargetHttpProxies:              &GCEBetaTargetHttpProxies{s},
		gceTargetHttpProxies:                  &GCETargetHttpProxies{s},
		gceAlphaRegionTargetHttpProxies:       &GCEAlphaRegionTargetHttpProxies{s},
		gceBetaRegionTargetHttpProxies:        &GCEBetaRegionTargetHttpProxies{s},
		gceRegionTargetHttpProxies:            &GCERegionTargetHttpProxies{s},
		gceTargetHttpsProxies:                 &GCETargetHttpsProxies{s},
		gceAlphaTargetHttpsProxies:            &GCEAlphaTargetHttpsProxies{s},
		gceBetaTargetHttpsProxies:             &GCEBetaTargetHttpsProxies{s},
		gceAlphaRegionTargetHttpsProxies:      &GCEAlphaRegionTargetHttpsProxies{s},
		gceBetaRegionTargetHttpsProxies:       &GCEBetaRegionTargetHttpsProxies{s},
		gceRegionTargetHttpsProxies:           &GCERegionTargetHttpsProxies{s},
		gceTargetPools:                        &GCETargetPools{s},
		gceAlphaTargetTcpProxies:              &GCEAlphaTargetTcpProxies{s},
		gceBetaTargetTcpProxies:               &GCEBetaTargetTcpProxies{s},
		gceTargetTcpProxies:                   &GCETargetTcpProxies{s},
		gceAlphaUrlMaps:                       &GCEAlphaUrlMaps{s},
		gceBetaUrlMaps:                        &GCEBetaUrlMaps{s},
		gceUrlMaps:                            &GCEUrlMaps{s},
		gceAlphaRegionUrlMaps:                 &GCEAlphaRegionUrlMaps{s},
		gceBetaRegionUrlMaps:                  &GCEBetaRegionUrlMaps{s},
		gceRegionUrlMaps:                      &GCERegionUrlMaps{s},
		gceZones:                              &GCEZones{s},
		tdTcpRoutes:                           &TDTcpRoutes{s},
		tdBetaTcpRoutes:                       &TDBetaTcpRoutes{s},
		tdMeshes:                              &TDMeshes{s},
		tdBetaMeshes:                          &TDBetaMeshes{s},
	}
	return g
}

// GCE implements Cloud.
var _ Cloud = (*GCE)(nil)

// GCE is the golang adapter for the compute APIs.
type GCE struct {
	gceAddresses                          *GCEAddresses
	gceAlphaAddresses                     *GCEAlphaAddresses
	gceBetaAddresses                      *GCEBetaAddresses
	gceAlphaGlobalAddresses               *GCEAlphaGlobalAddresses
	gceBetaGlobalAddresses                *GCEBetaGlobalAddresses
	gceGlobalAddresses                    *GCEGlobalAddresses
	gceBackendServices                    *GCEBackendServices
	gceBetaBackendServices                *GCEBetaBackendServices
	gceAlphaBackendServices               *GCEAlphaBackendServices
	gceRegionBackendServices              *GCERegionBackendServices
	gceAlphaRegionBackendServices         *GCEAlphaRegionBackendServices
	gceBetaRegionBackendServices          *GCEBetaRegionBackendServices
	gceDisks                              *GCEDisks
	gceRegionDisks                        *GCERegionDisks
	gceAlphaFirewalls                     *GCEAlphaFirewalls
	gceBetaFirewalls                      *GCEBetaFirewalls
	gceFirewalls                          *GCEFirewalls
	gceAlphaNetworkFirewallPolicies       *GCEAlphaNetworkFirewallPolicies
	gceAlphaRegionNetworkFirewallPolicies *GCEAlphaRegionNetworkFirewallPolicies
	gceForwardingRules                    *GCEForwardingRules
	gceAlphaForwardingRules               *GCEAlphaForwardingRules
	gceBetaForwardingRules                *GCEBetaForwardingRules
	gceAlphaGlobalForwardingRules         *GCEAlphaGlobalForwardingRules
	gceBetaGlobalForwardingRules          *GCEBetaGlobalForwardingRules
	gceGlobalForwardingRules              *GCEGlobalForwardingRules
	gceHealthChecks                       *GCEHealthChecks
	gceAlphaHealthChecks                  *GCEAlphaHealthChecks
	gceBetaHealthChecks                   *GCEBetaHealthChecks
	gceAlphaRegionHealthChecks            *GCEAlphaRegionHealthChecks
	gceBetaRegionHealthChecks             *GCEBetaRegionHealthChecks
	gceRegionHealthChecks                 *GCERegionHealthChecks
	gceHttpHealthChecks                   *GCEHttpHealthChecks
	gceHttpsHealthChecks                  *GCEHttpsHealthChecks
	gceInstanceGroups                     *GCEInstanceGroups
	gceInstances                          *GCEInstances
	gceBetaInstances                      *GCEBetaInstances
	gceAlphaInstances                     *GCEAlphaInstances
	gceInstanceGroupManagers              *GCEInstanceGroupManagers
	gceInstanceTemplates                  *GCEInstanceTemplates
	gceImages                             *GCEImages
	gceBetaImages                         *GCEBetaImages
	gceAlphaImages                        *GCEAlphaImages
	gceAlphaNetworks                      *GCEAlphaNetworks
	gceBetaNetworks                       *GCEBetaNetworks
	gceNetworks                           *GCENetworks
	gceAlphaNetworkEndpointGroups         *GCEAlphaNetworkEndpointGroups
	gceBetaNetworkEndpointGroups          *GCEBetaNetworkEndpointGroups
	gceNetworkEndpointGroups              *GCENetworkEndpointGroups
	gceAlphaGlobalNetworkEndpointGroups   *GCEAlphaGlobalNetworkEndpointGroups
	gceBetaGlobalNetworkEndpointGroups    *GCEBetaGlobalNetworkEndpointGroups
	gceGlobalNetworkEndpointGroups        *GCEGlobalNetworkEndpointGroups
	gceProjects                           *GCEProjects
	gceRegions                            *GCERegions
	gceAlphaRouters                       *GCEAlphaRouters
	gceBetaRouters                        *GCEBetaRouters
	gceRouters                            *GCERouters
	gceRoutes                             *GCERoutes
	gceBetaSecurityPolicies               *GCEBetaSecurityPolicies
	gceServiceAttachments                 *GCEServiceAttachments
	gceBetaServiceAttachments             *GCEBetaServiceAttachments
	gceAlphaServiceAttachments            *GCEAlphaServiceAttachments
	gceSslCertificates                    *GCESslCertificates
	gceBetaSslCertificates                *GCEBetaSslCertificates
	gceAlphaSslCertificates               *GCEAlphaSslCertificates
	gceAlphaRegionSslCertificates         *GCEAlphaRegionSslCertificates
	gceBetaRegionSslCertificates          *GCEBetaRegionSslCertificates
	gceRegionSslCertificates              *GCERegionSslCertificates
	gceSslPolicies                        *GCESslPolicies
	gceRegionSslPolicies                  *GCERegionSslPolicies
	gceAlphaSubnetworks                   *GCEAlphaSubnetworks
	gceBetaSubnetworks                    *GCEBetaSubnetworks
	gceSubnetworks                        *GCESubnetworks
	gceAlphaTargetHttpProxies             *GCEAlphaTargetHttpProxies
	gceBetaTargetHttpProxies              *GCEBetaTargetHttpProxies
	gceTargetHttpProxies                  *GCETargetHttpProxies
	gceAlphaRegionTargetHttpProxies       *GCEAlphaRegionTargetHttpProxies
	gceBetaRegionTargetHttpProxies        *GCEBetaRegionTargetHttpProxies
	gceRegionTargetHttpProxies            *GCERegionTargetHttpProxies
	gceTargetHttpsProxies                 *GCETargetHttpsProxies
	gceAlphaTargetHttpsProxies            *GCEAlphaTargetHttpsProxies
	gceBetaTargetHttpsProxies             *GCEBetaTargetHttpsProxies
	gceAlphaRegionTargetHttpsProxies      *GCEAlphaRegionTargetHttpsProxies
	gceBetaRegionTargetHttpsProxies       *GCEBetaRegionTargetHttpsProxies
	gceRegionTargetHttpsProxies           *GCERegionTargetHttpsProxies
	gceTargetPools                        *GCETargetPools
	gceAlphaTargetTcpProxies              *GCEAlphaTargetTcpProxies
	gceBetaTargetTcpProxies               *GCEBetaTargetTcpProxies
	gceTargetTcpProxies                   *GCETargetTcpProxies
	gceAlphaUrlMaps                       *GCEAlphaUrlMaps
	gceBetaUrlMaps                        *GCEBetaUrlMaps
	gceUrlMaps                            *GCEUrlMaps
	gceAlphaRegionUrlMaps                 *GCEAlphaRegionUrlMaps
	gceBetaRegionUrlMaps                  *GCEBetaRegionUrlMaps
	gceRegionUrlMaps                      *GCERegionUrlMaps
	gceZones                              *GCEZones
	tdTcpRoutes                           *TDTcpRoutes
	tdBetaTcpRoutes                       *TDBetaTcpRoutes
	tdMeshes                              *TDMeshes
	tdBetaMeshes                          *TDBetaMeshes
}

// Addresses returns the interface for the ga Addresses.
func (gce *GCE) Addresses() Addresses {
	return gce.gceAddresses
}

// AlphaAddresses returns the interface for the alpha Addresses.
func (gce *GCE) AlphaAddresses() AlphaAddresses {
	return gce.gceAlphaAddresses
}

// BetaAddresses returns the interface for the beta Addresses.
func (gce *GCE) BetaAddresses() BetaAddresses {
	return gce.gceBetaAddresses
}

// AlphaGlobalAddresses returns the interface for the alpha GlobalAddresses.
func (gce *GCE) AlphaGlobalAddresses() AlphaGlobalAddresses {
	return gce.gceAlphaGlobalAddresses
}

// BetaGlobalAddresses returns the interface for the beta GlobalAddresses.
func (gce *GCE) BetaGlobalAddresses() BetaGlobalAddresses {
	return gce.gceBetaGlobalAddresses
}

// GlobalAddresses returns the interface for the ga GlobalAddresses.
func (gce *GCE) GlobalAddresses() GlobalAddresses {
	return gce.gceGlobalAddresses
}

// BackendServices returns the interface for the ga BackendServices.
func (gce *GCE) BackendServices() BackendServices {
	return gce.gceBackendServices
}

// BetaBackendServices returns the interface for the beta BackendServices.
func (gce *GCE) BetaBackendServices() BetaBackendServices {
	return gce.gceBetaBackendServices
}

// AlphaBackendServices returns the interface for the alpha BackendServices.
func (gce *GCE) AlphaBackendServices() AlphaBackendServices {
	return gce.gceAlphaBackendServices
}

// RegionBackendServices returns the interface for the ga RegionBackendServices.
func (gce *GCE) RegionBackendServices() RegionBackendServices {
	return gce.gceRegionBackendServices
}

// AlphaRegionBackendServices returns the interface for the alpha RegionBackendServices.
func (gce *GCE) AlphaRegionBackendServices() AlphaRegionBackendServices {
	return gce.gceAlphaRegionBackendServices
}

// BetaRegionBackendServices returns the interface for the beta RegionBackendServices.
func (gce *GCE) BetaRegionBackendServices() BetaRegionBackendServices {
	return gce.gceBetaRegionBackendServices
}

// Disks returns the interface for the ga Disks.
func (gce *GCE) Disks() Disks {
	return gce.gceDisks
}

// RegionDisks returns the interface for the ga RegionDisks.
func (gce *GCE) RegionDisks() RegionDisks {
	return gce.gceRegionDisks
}

// AlphaFirewalls returns the interface for the alpha Firewalls.
func (gce *GCE) AlphaFirewalls() AlphaFirewalls {
	return gce.gceAlphaFirewalls
}

// BetaFirewalls returns the interface for the beta Firewalls.
func (gce *GCE) BetaFirewalls() BetaFirewalls {
	return gce.gceBetaFirewalls
}

// Firewalls returns the interface for the ga Firewalls.
func (gce *GCE) Firewalls() Firewalls {
	return gce.gceFirewalls
}

// AlphaNetworkFirewallPolicies returns the interface for the alpha NetworkFirewallPolicies.
func (gce *GCE) AlphaNetworkFirewallPolicies() AlphaNetworkFirewallPolicies {
	return gce.gceAlphaNetworkFirewallPolicies
}

// AlphaRegionNetworkFirewallPolicies returns the interface for the alpha RegionNetworkFirewallPolicies.
func (gce *GCE) AlphaRegionNetworkFirewallPolicies() AlphaRegionNetworkFirewallPolicies {
	return gce.gceAlphaRegionNetworkFirewallPolicies
}

// ForwardingRules returns the interface for the ga ForwardingRules.
func (gce *GCE) ForwardingRules() ForwardingRules {
	return gce.gceForwardingRules
}

// AlphaForwardingRules returns the interface for the alpha ForwardingRules.
func (gce *GCE) AlphaForwardingRules() AlphaForwardingRules {
	return gce.gceAlphaForwardingRules
}

// BetaForwardingRules returns the interface for the beta ForwardingRules.
func (gce *GCE) BetaForwardingRules() BetaForwardingRules {
	return gce.gceBetaForwardingRules
}

// AlphaGlobalForwardingRules returns the interface for the alpha GlobalForwardingRules.
func (gce *GCE) AlphaGlobalForwardingRules() AlphaGlobalForwardingRules {
	return gce.gceAlphaGlobalForwardingRules
}

// BetaGlobalForwardingRules returns the interface for the beta GlobalForwardingRules.
func (gce *GCE) BetaGlobalForwardingRules() BetaGlobalForwardingRules {
	return gce.gceBetaGlobalForwardingRules
}

// GlobalForwardingRules returns the interface for the ga GlobalForwardingRules.
func (gce *GCE) GlobalForwardingRules() GlobalForwardingRules {
	return gce.gceGlobalForwardingRules
}

// HealthChecks returns the interface for the ga HealthChecks.
func (gce *GCE) HealthChecks() HealthChecks {
	return gce.gceHealthChecks
}

// AlphaHealthChecks returns the interface for the alpha HealthChecks.
func (gce *GCE) AlphaHealthChecks() AlphaHealthChecks {
	return gce.gceAlphaHealthChecks
}

// BetaHealthChecks returns the interface for the beta HealthChecks.
func (gce *GCE) BetaHealthChecks() BetaHealthChecks {
	return gce.gceBetaHealthChecks
}

// AlphaRegionHealthChecks returns the interface for the alpha RegionHealthChecks.
func (gce *GCE) AlphaRegionHealthChecks() AlphaRegionHealthChecks {
	return gce.gceAlphaRegionHealthChecks
}

// BetaRegionHealthChecks returns the interface for the beta RegionHealthChecks.
func (gce *GCE) BetaRegionHealthChecks() BetaRegionHealthChecks {
	return gce.gceBetaRegionHealthChecks
}

// RegionHealthChecks returns the interface for the ga RegionHealthChecks.
func (gce *GCE) RegionHealthChecks() RegionHealthChecks {
	return gce.gceRegionHealthChecks
}

// HttpHealthChecks returns the interface for the ga HttpHealthChecks.
func (gce *GCE) HttpHealthChecks() HttpHealthChecks {
	return gce.gceHttpHealthChecks
}

// HttpsHealthChecks returns the interface for the ga HttpsHealthChecks.
func (gce *GCE) HttpsHealthChecks() HttpsHealthChecks {
	return gce.gceHttpsHealthChecks
}

// InstanceGroups returns the interface for the ga InstanceGroups.
func (gce *GCE) InstanceGroups() InstanceGroups {
	return gce.gceInstanceGroups
}

// Instances returns the interface for the ga Instances.
func (gce *GCE) Instances() Instances {
	return gce.gceInstances
}

// BetaInstances returns the interface for the beta Instances.
func (gce *GCE) BetaInstances() BetaInstances {
	return gce.gceBetaInstances
}

// AlphaInstances returns the interface for the alpha Instances.
func (gce *GCE) AlphaInstances() AlphaInstances {
	return gce.gceAlphaInstances
}

// InstanceGroupManagers returns the interface for the ga InstanceGroupManagers.
func (gce *GCE) InstanceGroupManagers() InstanceGroupManagers {
	return gce.gceInstanceGroupManagers
}

// InstanceTemplates returns the interface for the ga InstanceTemplates.
func (gce *GCE) InstanceTemplates() InstanceTemplates {
	return gce.gceInstanceTemplates
}

// Images returns the interface for the ga Images.
func (gce *GCE) Images() Images {
	return gce.gceImages
}

// BetaImages returns the interface for the beta Images.
func (gce *GCE) BetaImages() BetaImages {
	return gce.gceBetaImages
}

// AlphaImages returns the interface for the alpha Images.
func (gce *GCE) AlphaImages() AlphaImages {
	return gce.gceAlphaImages
}

// AlphaNetworks returns the interface for the alpha Networks.
func (gce *GCE) AlphaNetworks() AlphaNetworks {
	return gce.gceAlphaNetworks
}

// BetaNetworks returns the interface for the beta Networks.
func (gce *GCE) BetaNetworks() BetaNetworks {
	return gce.gceBetaNetworks
}

// Networks returns the interface for the ga Networks.
func (gce *GCE) Networks() Networks {
	return gce.gceNetworks
}

// AlphaNetworkEndpointGroups returns the interface for the alpha NetworkEndpointGroups.
func (gce *GCE) AlphaNetworkEndpointGroups() AlphaNetworkEndpointGroups {
	return gce.gceAlphaNetworkEndpointGroups
}

// BetaNetworkEndpointGroups returns the interface for the beta NetworkEndpointGroups.
func (gce *GCE) BetaNetworkEndpointGroups() BetaNetworkEndpointGroups {
	return gce.gceBetaNetworkEndpointGroups
}

// NetworkEndpointGroups returns the interface for the ga NetworkEndpointGroups.
func (gce *GCE) NetworkEndpointGroups() NetworkEndpointGroups {
	return gce.gceNetworkEndpointGroups
}

// AlphaGlobalNetworkEndpointGroups returns the interface for the alpha GlobalNetworkEndpointGroups.
func (gce *GCE) AlphaGlobalNetworkEndpointGroups() AlphaGlobalNetworkEndpointGroups {
	return gce.gceAlphaGlobalNetworkEndpointGroups
}

// BetaGlobalNetworkEndpointGroups returns the interface for the beta GlobalNetworkEndpointGroups.
func (gce *GCE) BetaGlobalNetworkEndpointGroups() BetaGlobalNetworkEndpointGroups {
	return gce.gceBetaGlobalNetworkEndpointGroups
}

// GlobalNetworkEndpointGroups returns the interface for the ga GlobalNetworkEndpointGroups.
func (gce *GCE) GlobalNetworkEndpointGroups() GlobalNetworkEndpointGroups {
	return gce.gceGlobalNetworkEndpointGroups
}

// Projects returns the interface for the ga Projects.
func (gce *GCE) Projects() Projects {
	return gce.gceProjects
}

// Regions returns the interface for the ga Regions.
func (gce *GCE) Regions() Regions {
	return gce.gceRegions
}

// AlphaRouters returns the interface for the alpha Routers.
func (gce *GCE) AlphaRouters() AlphaRouters {
	return gce.gceAlphaRouters
}

// BetaRouters returns the interface for the beta Routers.
func (gce *GCE) BetaRouters() BetaRouters {
	return gce.gceBetaRouters
}

// Routers returns the interface for the ga Routers.
func (gce *GCE) Routers() Routers {
	return gce.gceRouters
}

// Routes returns the interface for the ga Routes.
func (gce *GCE) Routes() Routes {
	return gce.gceRoutes
}

// BetaSecurityPolicies returns the interface for the beta SecurityPolicies.
func (gce *GCE) BetaSecurityPolicies() BetaSecurityPolicies {
	return gce.gceBetaSecurityPolicies
}

// ServiceAttachments returns the interface for the ga ServiceAttachments.
func (gce *GCE) ServiceAttachments() ServiceAttachments {
	return gce.gceServiceAttachments
}

// BetaServiceAttachments returns the interface for the beta ServiceAttachments.
func (gce *GCE) BetaServiceAttachments() BetaServiceAttachments {
	return gce.gceBetaServiceAttachments
}

// AlphaServiceAttachments returns the interface for the alpha ServiceAttachments.
func (gce *GCE) AlphaServiceAttachments() AlphaServiceAttachments {
	return gce.gceAlphaServiceAttachments
}

// SslCertificates returns the interface for the ga SslCertificates.
func (gce *GCE) SslCertificates() SslCertificates {
	return gce.gceSslCertificates
}

// BetaSslCertificates returns the interface for the beta SslCertificates.
func (gce *GCE) BetaSslCertificates() BetaSslCertificates {
	return gce.gceBetaSslCertificates
}

// AlphaSslCertificates returns the interface for the alpha SslCertificates.
func (gce *GCE) AlphaSslCertificates() AlphaSslCertificates {
	return gce.gceAlphaSslCertificates
}

// AlphaRegionSslCertificates returns the interface for the alpha RegionSslCertificates.
func (gce *GCE) AlphaRegionSslCertificates() AlphaRegionSslCertificates {
	return gce.gceAlphaRegionSslCertificates
}

// BetaRegionSslCertificates returns the interface for the beta RegionSslCertificates.
func (gce *GCE) BetaRegionSslCertificates() BetaRegionSslCertificates {
	return gce.gceBetaRegionSslCertificates
}

// RegionSslCertificates returns the interface for the ga RegionSslCertificates.
func (gce *GCE) RegionSslCertificates() RegionSslCertificates {
	return gce.gceRegionSslCertificates
}

// SslPolicies returns the interface for the ga SslPolicies.
func (gce *GCE) SslPolicies() SslPolicies {
	return gce.gceSslPolicies
}

// RegionSslPolicies returns the interface for the ga RegionSslPolicies.
func (gce *GCE) RegionSslPolicies() RegionSslPolicies {
	return gce.gceRegionSslPolicies
}

// AlphaSubnetworks returns the interface for the alpha Subnetworks.
func (gce *GCE) AlphaSubnetworks() AlphaSubnetworks {
	return gce.gceAlphaSubnetworks
}

// BetaSubnetworks returns the interface for the beta Subnetworks.
func (gce *GCE) BetaSubnetworks() BetaSubnetworks {
	return gce.gceBetaSubnetworks
}

// Subnetworks returns the interface for the ga Subnetworks.
func (gce *GCE) Subnetworks() Subnetworks {
	return gce.gceSubnetworks
}

// AlphaTargetHttpProxies returns the interface for the alpha TargetHttpProxies.
func (gce *GCE) AlphaTargetHttpProxies() AlphaTargetHttpProxies {
	return gce.gceAlphaTargetHttpProxies
}

// BetaTargetHttpProxies returns the interface for the beta TargetHttpProxies.
func (gce *GCE) BetaTargetHttpProxies() BetaTargetHttpProxies {
	return gce.gceBetaTargetHttpProxies
}

// TargetHttpProxies returns the interface for the ga TargetHttpProxies.
func (gce *GCE) TargetHttpProxies() TargetHttpProxies {
	return gce.gceTargetHttpProxies
}

// AlphaRegionTargetHttpProxies returns the interface for the alpha RegionTargetHttpProxies.
func (gce *GCE) AlphaRegionTargetHttpProxies() AlphaRegionTargetHttpProxies {
	return gce.gceAlphaRegionTargetHttpProxies
}

// BetaRegionTargetHttpProxies returns the interface for the beta RegionTargetHttpProxies.
func (gce *GCE) BetaRegionTargetHttpProxies() BetaRegionTargetHttpProxies {
	return gce.gceBetaRegionTargetHttpProxies
}

// RegionTargetHttpProxies returns the interface for the ga RegionTargetHttpProxies.
func (gce *GCE) RegionTargetHttpProxies() RegionTargetHttpProxies {
	return gce.gceRegionTargetHttpProxies
}

// TargetHttpsProxies returns the interface for the ga TargetHttpsProxies.
func (gce *GCE) TargetHttpsProxies() TargetHttpsProxies {
	return gce.gceTargetHttpsProxies
}

// AlphaTargetHttpsProxies returns the interface for the alpha TargetHttpsProxies.
func (gce *GCE) AlphaTargetHttpsProxies() AlphaTargetHttpsProxies {
	return gce.gceAlphaTargetHttpsProxies
}

// BetaTargetHttpsProxies returns the interface for the beta TargetHttpsProxies.
func (gce *GCE) BetaTargetHttpsProxies() BetaTargetHttpsProxies {
	return gce.gceBetaTargetHttpsProxies
}

// AlphaRegionTargetHttpsProxies returns the interface for the alpha RegionTargetHttpsProxies.
func (gce *GCE) AlphaRegionTargetHttpsProxies() AlphaRegionTargetHttpsProxies {
	return gce.gceAlphaRegionTargetHttpsProxies
}

// BetaRegionTargetHttpsProxies returns the interface for the beta RegionTargetHttpsProxies.
func (gce *GCE) BetaRegionTargetHttpsProxies() BetaRegionTargetHttpsProxies {
	return gce.gceBetaRegionTargetHttpsProxies
}

// RegionTargetHttpsProxies returns the interface for the ga RegionTargetHttpsProxies.
func (gce *GCE) RegionTargetHttpsProxies() RegionTargetHttpsProxies {
	return gce.gceRegionTargetHttpsProxies
}

// TargetPools returns the interface for the ga TargetPools.
func (gce *GCE) TargetPools() TargetPools {
	return gce.gceTargetPools
}

// AlphaTargetTcpProxies returns the interface for the alpha TargetTcpProxies.
func (gce *GCE) AlphaTargetTcpProxies() AlphaTargetTcpProxies {
	return gce.gceAlphaTargetTcpProxies
}

// BetaTargetTcpProxies returns the interface for the beta TargetTcpProxies.
func (gce *GCE) BetaTargetTcpProxies() BetaTargetTcpProxies {
	return gce.gceBetaTargetTcpProxies
}

// TargetTcpProxies returns the interface for the ga TargetTcpProxies.
func (gce *GCE) TargetTcpProxies() TargetTcpProxies {
	return gce.gceTargetTcpProxies
}

// AlphaUrlMaps returns the interface for the alpha UrlMaps.
func (gce *GCE) AlphaUrlMaps() AlphaUrlMaps {
	return gce.gceAlphaUrlMaps
}

// BetaUrlMaps returns the interface for the beta UrlMaps.
func (gce *GCE) BetaUrlMaps() BetaUrlMaps {
	return gce.gceBetaUrlMaps
}

// UrlMaps returns the interface for the ga UrlMaps.
func (gce *GCE) UrlMaps() UrlMaps {
	return gce.gceUrlMaps
}

// AlphaRegionUrlMaps returns the interface for the alpha RegionUrlMaps.
func (gce *GCE) AlphaRegionUrlMaps() AlphaRegionUrlMaps {
	return gce.gceAlphaRegionUrlMaps
}

// BetaRegionUrlMaps returns the interface for the beta RegionUrlMaps.
func (gce *GCE) BetaRegionUrlMaps() BetaRegionUrlMaps {
	return gce.gceBetaRegionUrlMaps
}

// RegionUrlMaps returns the interface for the ga RegionUrlMaps.
func (gce *GCE) RegionUrlMaps() RegionUrlMaps {
	return gce.gceRegionUrlMaps
}

// Zones returns the interface for the ga Zones.
func (gce *GCE) Zones() Zones {
	return gce.gceZones
}

// TcpRoutes returns the interface for the ga TcpRoutes.
func (gce *GCE) TcpRoutes() TcpRoutes {
	return gce.tdTcpRoutes
}

// BetaTcpRoutes returns the interface for the beta TcpRoutes.
func (gce *GCE) BetaTcpRoutes() BetaTcpRoutes {
	return gce.tdBetaTcpRoutes
}

// Meshes returns the interface for the ga Meshes.
func (gce *GCE) Meshes() Meshes {
	return gce.tdMeshes
}

// BetaMeshes returns the interface for the beta Meshes.
func (gce *GCE) BetaMeshes() BetaMeshes {
	return gce.tdBetaMeshes
}

// NewMockGCE returns a new mock for GCE.
func NewMockGCE(projectRouter ProjectRouter) *MockGCE {
	mockAddressesObjs := map[meta.Key]*MockAddressesObj{}
	mockBackendServicesObjs := map[meta.Key]*MockBackendServicesObj{}
	mockDisksObjs := map[meta.Key]*MockDisksObj{}
	mockFirewallsObjs := map[meta.Key]*MockFirewallsObj{}
	mockForwardingRulesObjs := map[meta.Key]*MockForwardingRulesObj{}
	mockGlobalAddressesObjs := map[meta.Key]*MockGlobalAddressesObj{}
	mockGlobalForwardingRulesObjs := map[meta.Key]*MockGlobalForwardingRulesObj{}
	mockGlobalNetworkEndpointGroupsObjs := map[meta.Key]*MockGlobalNetworkEndpointGroupsObj{}
	mockHealthChecksObjs := map[meta.Key]*MockHealthChecksObj{}
	mockHttpHealthChecksObjs := map[meta.Key]*MockHttpHealthChecksObj{}
	mockHttpsHealthChecksObjs := map[meta.Key]*MockHttpsHealthChecksObj{}
	mockImagesObjs := map[meta.Key]*MockImagesObj{}
	mockInstanceGroupManagersObjs := map[meta.Key]*MockInstanceGroupManagersObj{}
	mockInstanceGroupsObjs := map[meta.Key]*MockInstanceGroupsObj{}
	mockInstanceTemplatesObjs := map[meta.Key]*MockInstanceTemplatesObj{}
	mockInstancesObjs := map[meta.Key]*MockInstancesObj{}
	mockMeshesObjs := map[meta.Key]*MockMeshesObj{}
	mockNetworkEndpointGroupsObjs := map[meta.Key]*MockNetworkEndpointGroupsObj{}
	mockNetworkFirewallPoliciesObjs := map[meta.Key]*MockNetworkFirewallPoliciesObj{}
	mockNetworksObjs := map[meta.Key]*MockNetworksObj{}
	mockProjectsObjs := map[meta.Key]*MockProjectsObj{}
	mockRegionBackendServicesObjs := map[meta.Key]*MockRegionBackendServicesObj{}
	mockRegionDisksObjs := map[meta.Key]*MockRegionDisksObj{}
	mockRegionHealthChecksObjs := map[meta.Key]*MockRegionHealthChecksObj{}
	mockRegionNetworkFirewallPoliciesObjs := map[meta.Key]*MockRegionNetworkFirewallPoliciesObj{}
	mockRegionSslCertificatesObjs := map[meta.Key]*MockRegionSslCertificatesObj{}
	mockRegionSslPoliciesObjs := map[meta.Key]*MockRegionSslPoliciesObj{}
	mockRegionTargetHttpProxiesObjs := map[meta.Key]*MockRegionTargetHttpProxiesObj{}
	mockRegionTargetHttpsProxiesObjs := map[meta.Key]*MockRegionTargetHttpsProxiesObj{}
	mockRegionUrlMapsObjs := map[meta.Key]*MockRegionUrlMapsObj{}
	mockRegionsObjs := map[meta.Key]*MockRegionsObj{}
	mockRoutersObjs := map[meta.Key]*MockRoutersObj{}
	mockRoutesObjs := map[meta.Key]*MockRoutesObj{}
	mockSecurityPoliciesObjs := map[meta.Key]*MockSecurityPoliciesObj{}
	mockServiceAttachmentsObjs := map[meta.Key]*MockServiceAttachmentsObj{}
	mockSslCertificatesObjs := map[meta.Key]*MockSslCertificatesObj{}
	mockSslPoliciesObjs := map[meta.Key]*MockSslPoliciesObj{}
	mockSubnetworksObjs := map[meta.Key]*MockSubnetworksObj{}
	mockTargetHttpProxiesObjs := map[meta.Key]*MockTargetHttpProxiesObj{}
	mockTargetHttpsProxiesObjs := map[meta.Key]*MockTargetHttpsProxiesObj{}
	mockTargetPoolsObjs := map[meta.Key]*MockTargetPoolsObj{}
	mockTargetTcpProxiesObjs := map[meta.Key]*MockTargetTcpProxiesObj{}
	mockTcpRoutesObjs := map[meta.Key]*MockTcpRoutesObj{}
	mockUrlMapsObjs := map[meta.Key]*MockUrlMapsObj{}
	mockZonesObjs := map[meta.Key]*MockZonesObj{}

	mock := &MockGCE{
		MockAddresses:                          NewMockAddresses(projectRouter, mockAddressesObjs),
		MockAlphaAddresses:                     NewMockAlphaAddresses(projectRouter, mockAddressesObjs),
		MockBetaAddresses:                      NewMockBetaAddresses(projectRouter, mockAddressesObjs),
		MockAlphaGlobalAddresses:               NewMockAlphaGlobalAddresses(projectRouter, mockGlobalAddressesObjs),
		MockBetaGlobalAddresses:                NewMockBetaGlobalAddresses(projectRouter, mockGlobalAddressesObjs),
		MockGlobalAddresses:                    NewMockGlobalAddresses(projectRouter, mockGlobalAddressesObjs),
		MockBackendServices:                    NewMockBackendServices(projectRouter, mockBackendServicesObjs),
		MockBetaBackendServices:                NewMockBetaBackendServices(projectRouter, mockBackendServicesObjs),
		MockAlphaBackendServices:               NewMockAlphaBackendServices(projectRouter, mockBackendServicesObjs),
		MockRegionBackendServices:              NewMockRegionBackendServices(projectRouter, mockRegionBackendServicesObjs),
		MockAlphaRegionBackendServices:         NewMockAlphaRegionBackendServices(projectRouter, mockRegionBackendServicesObjs),
		MockBetaRegionBackendServices:          NewMockBetaRegionBackendServices(projectRouter, mockRegionBackendServicesObjs),
		MockDisks:                              NewMockDisks(projectRouter, mockDisksObjs),
		MockRegionDisks:                        NewMockRegionDisks(projectRouter, mockRegionDisksObjs),
		MockAlphaFirewalls:                     NewMockAlphaFirewalls(projectRouter, mockFirewallsObjs),
		MockBetaFirewalls:                      NewMockBetaFirewalls(projectRouter, mockFirewallsObjs),
		MockFirewalls:                          NewMockFirewalls(projectRouter, mockFirewallsObjs),
		MockAlphaNetworkFirewallPolicies:       NewMockAlphaNetworkFirewallPolicies(projectRouter, mockNetworkFirewallPoliciesObjs),
		MockAlphaRegionNetworkFirewallPolicies: NewMockAlphaRegionNetworkFirewallPolicies(projectRouter, mockRegionNetworkFirewallPoliciesObjs),
		MockForwardingRules:                    NewMockForwardingRules(projectRouter, mockForwardingRulesObjs),
		MockAlphaForwardingRules:               NewMockAlphaForwardingRules(projectRouter, mockForwardingRulesObjs),
		MockBetaForwardingRules:                NewMockBetaForwardingRules(projectRouter, mockForwardingRulesObjs),
		MockAlphaGlobalForwardingRules:         NewMockAlphaGlobalForwardingRules(projectRouter, mockGlobalForwardingRulesObjs),
		MockBetaGlobalForwardingRules:          NewMockBetaGlobalForwardingRules(projectRouter, mockGlobalForwardingRulesObjs),
		MockGlobalForwardingRules:              NewMockGlobalForwardingRules(projectRouter, mockGlobalForwardingRulesObjs),
		MockHealthChecks:                       NewMockHealthChecks(projectRouter, mockHealthChecksObjs),
		MockAlphaHealthChecks:                  NewMockAlphaHealthChecks(projectRouter, mockHealthChecksObjs),
		MockBetaHealthChecks:                   NewMockBetaHealthChecks(projectRouter, mockHealthChecksObjs),
		MockAlphaRegionHealthChecks:            NewMockAlphaRegionHealthChecks(projectRouter, mockRegionHealthChecksObjs),
		MockBetaRegionHealthChecks:             NewMockBetaRegionHealthChecks(projectRouter, mockRegionHealthChecksObjs),
		MockRegionHealthChecks:                 NewMockRegionHealthChecks(projectRouter, mockRegionHealthChecksObjs),
		MockHttpHealthChecks:                   NewMockHttpHealthChecks(projectRouter, mockHttpHealthChecksObjs),
		MockHttpsHealthChecks:                  NewMockHttpsHealthChecks(projectRouter, mockHttpsHealthChecksObjs),
		MockInstanceGroups:                     NewMockInstanceGroups(projectRouter, mockInstanceGroupsObjs),
		MockInstances:                          NewMockInstances(projectRouter, mockInstancesObjs),
		MockBetaInstances:                      NewMockBetaInstances(projectRouter, mockInstancesObjs),
		MockAlphaInstances:                     NewMockAlphaInstances(projectRouter, mockInstancesObjs),
		MockInstanceGroupManagers:              NewMockInstanceGroupManagers(projectRouter, mockInstanceGroupManagersObjs),
		MockInstanceTemplates:                  NewMockInstanceTemplates(projectRouter, mockInstanceTemplatesObjs),
		MockImages:                             NewMockImages(projectRouter, mockImagesObjs),
		MockBetaImages:                         NewMockBetaImages(projectRouter, mockImagesObjs),
		MockAlphaImages:                        NewMockAlphaImages(projectRouter, mockImagesObjs),
		MockAlphaNetworks:                      NewMockAlphaNetworks(projectRouter, mockNetworksObjs),
		MockBetaNetworks:                       NewMockBetaNetworks(projectRouter, mockNetworksObjs),
		MockNetworks:                           NewMockNetworks(projectRouter, mockNetworksObjs),
		MockAlphaNetworkEndpointGroups:         NewMockAlphaNetworkEndpointGroups(projectRouter, mockNetworkEndpointGroupsObjs),
		MockBetaNetworkEndpointGroups:          NewMockBetaNetworkEndpointGroups(projectRouter, mockNetworkEndpointGroupsObjs),
		MockNetworkEndpointGroups:              NewMockNetworkEndpointGroups(projectRouter, mockNetworkEndpointGroupsObjs),
		MockAlphaGlobalNetworkEndpointGroups:   NewMockAlphaGlobalNetworkEndpointGroups(projectRouter, mockGlobalNetworkEndpointGroupsObjs),
		MockBetaGlobalNetworkEndpointGroups:    NewMockBetaGlobalNetworkEndpointGroups(projectRouter, mockGlobalNetworkEndpointGroupsObjs),
		MockGlobalNetworkEndpointGroups:        NewMockGlobalNetworkEndpointGroups(projectRouter, mockGlobalNetworkEndpointGroupsObjs),
		MockProjects:                           NewMockProjects(projectRouter, mockProjectsObjs),
		MockRegions:                            NewMockRegions(projectRouter, mockRegionsObjs),
		MockAlphaRouters:                       NewMockAlphaRouters(projectRouter, mockRoutersObjs),
		MockBetaRouters:                        NewMockBetaRouters(projectRouter, mockRoutersObjs),
		MockRouters:                            NewMockRouters(projectRouter, mockRoutersObjs),
		MockRoutes:                             NewMockRoutes(projectRouter, mockRoutesObjs),
		MockBetaSecurityPolicies:               NewMockBetaSecurityPolicies(projectRouter, mockSecurityPoliciesObjs),
		MockServiceAttachments:                 NewMockServiceAttachments(projectRouter, mockServiceAttachmentsObjs),
		MockBetaServiceAttachments:             NewMockBetaServiceAttachments(projectRouter, mockServiceAttachmentsObjs),
		MockAlphaServiceAttachments:            NewMockAlphaServiceAttachments(projectRouter, mockServiceAttachmentsObjs),
		MockSslCertificates:                    NewMockSslCertificates(projectRouter, mockSslCertificatesObjs),
		MockBetaSslCertificates:                NewMockBetaSslCertificates(projectRouter, mockSslCertificatesObjs),
		MockAlphaSslCertificates:               NewMockAlphaSslCertificates(projectRouter, mockSslCertificatesObjs),
		MockAlphaRegionSslCertificates:         NewMockAlphaRegionSslCertificates(projectRouter, mockRegionSslCertificatesObjs),
		MockBetaRegionSslCertificates:          NewMockBetaRegionSslCertificates(projectRouter, mockRegionSslCertificatesObjs),
		MockRegionSslCertificates:              NewMockRegionSslCertificates(projectRouter, mockRegionSslCertificatesObjs),
		MockSslPolicies:                        NewMockSslPolicies(projectRouter, mockSslPoliciesObjs),
		MockRegionSslPolicies:                  NewMockRegionSslPolicies(projectRouter, mockRegionSslPoliciesObjs),
		MockAlphaSubnetworks:                   NewMockAlphaSubnetworks(projectRouter, mockSubnetworksObjs),
		MockBetaSubnetworks:                    NewMockBetaSubnetworks(projectRouter, mockSubnetworksObjs),
		MockSubnetworks:                        NewMockSubnetworks(projectRouter, mockSubnetworksObjs),
		MockAlphaTargetHttpProxies:             NewMockAlphaTargetHttpProxies(projectRouter, mockTargetHttpProxiesObjs),
		MockBetaTargetHttpProxies:              NewMockBetaTargetHttpProxies(projectRouter, mockTargetHttpProxiesObjs),
		MockTargetHttpProxies:                  NewMockTargetHttpProxies(projectRouter, mockTargetHttpProxiesObjs),
		MockAlphaRegionTargetHttpProxies:       NewMockAlphaRegionTargetHttpProxies(projectRouter, mockRegionTargetHttpProxiesObjs),
		MockBetaRegionTargetHttpProxies:        NewMockBetaRegionTargetHttpProxies(projectRouter, mockRegionTargetHttpProxiesObjs),
		MockRegionTargetHttpProxies:            NewMockRegionTargetHttpProxies(projectRouter, mockRegionTargetHttpProxiesObjs),
		MockTargetHttpsProxies:                 NewMockTargetHttpsProxies(projectRouter, mockTargetHttpsProxiesObjs),
		MockAlphaTargetHttpsProxies:            NewMockAlphaTargetHttpsProxies(projectRouter, mockTargetHttpsProxiesObjs),
		MockBetaTargetHttpsProxies:             NewMockBetaTargetHttpsProxies(projectRouter, mockTargetHttpsProxiesObjs),
		MockAlphaRegionTargetHttpsProxies:      NewMockAlphaRegionTargetHttpsProxies(projectRouter, mockRegionTargetHttpsProxiesObjs),
		MockBetaRegionTargetHttpsProxies:       NewMockBetaRegionTargetHttpsProxies(projectRouter, mockRegionTargetHttpsProxiesObjs),
		MockRegionTargetHttpsProxies:           NewMockRegionTargetHttpsProxies(projectRouter, mockRegionTargetHttpsProxiesObjs),
		MockTargetPools:                        NewMockTargetPools(projectRouter, mockTargetPoolsObjs),
		MockAlphaTargetTcpProxies:              NewMockAlphaTargetTcpProxies(projectRouter, mockTargetTcpProxiesObjs),
		MockBetaTargetTcpProxies:               NewMockBetaTargetTcpProxies(projectRouter, mockTargetTcpProxiesObjs),
		MockTargetTcpProxies:                   NewMockTargetTcpProxies(projectRouter, mockTargetTcpProxiesObjs),
		MockAlphaUrlMaps:                       NewMockAlphaUrlMaps(projectRouter, mockUrlMapsObjs),
		MockBetaUrlMaps:                        NewMockBetaUrlMaps(projectRouter, mockUrlMapsObjs),
		MockUrlMaps:                            NewMockUrlMaps(projectRouter, mockUrlMapsObjs),
		MockAlphaRegionUrlMaps:                 NewMockAlphaRegionUrlMaps(projectRouter, mockRegionUrlMapsObjs),
		MockBetaRegionUrlMaps:                  NewMockBetaRegionUrlMaps(projectRouter, mockRegionUrlMapsObjs),
		MockRegionUrlMaps:                      NewMockRegionUrlMaps(projectRouter, mockRegionUrlMapsObjs),
		MockZones:                              NewMockZones(projectRouter, mockZonesObjs),
		MockTcpRoutes:                          NewMockTcpRoutes(projectRouter, mockTcpRoutesObjs),
		MockBetaTcpRoutes:                      NewMockBetaTcpRoutes(projectRouter, mockTcpRoutesObjs),
		MockMeshes:                             NewMockMeshes(projectRouter, mockMeshesObjs),
		MockBetaMeshes:                         NewMockBetaMeshes(projectRouter, mockMeshesObjs),
	}
	return mock
}

// MockGCE implements Cloud.
var _ Cloud = (*MockGCE)(nil)

// MockGCE is the mock for the compute API.
type MockGCE struct {
	MockAddresses                          *MockAddresses
	MockAlphaAddresses                     *MockAlphaAddresses
	MockBetaAddresses                      *MockBetaAddresses
	MockAlphaGlobalAddresses               *MockAlphaGlobalAddresses
	MockBetaGlobalAddresses                *MockBetaGlobalAddresses
	MockGlobalAddresses                    *MockGlobalAddresses
	MockBackendServices                    *MockBackendServices
	MockBetaBackendServices                *MockBetaBackendServices
	MockAlphaBackendServices               *MockAlphaBackendServices
	MockRegionBackendServices              *MockRegionBackendServices
	MockAlphaRegionBackendServices         *MockAlphaRegionBackendServices
	MockBetaRegionBackendServices          *MockBetaRegionBackendServices
	MockDisks                              *MockDisks
	MockRegionDisks                        *MockRegionDisks
	MockAlphaFirewalls                     *MockAlphaFirewalls
	MockBetaFirewalls                      *MockBetaFirewalls
	MockFirewalls                          *MockFirewalls
	MockAlphaNetworkFirewallPolicies       *MockAlphaNetworkFirewallPolicies
	MockAlphaRegionNetworkFirewallPolicies *MockAlphaRegionNetworkFirewallPolicies
	MockForwardingRules                    *MockForwardingRules
	MockAlphaForwardingRules               *MockAlphaForwardingRules
	MockBetaForwardingRules                *MockBetaForwardingRules
	MockAlphaGlobalForwardingRules         *MockAlphaGlobalForwardingRules
	MockBetaGlobalForwardingRules          *MockBetaGlobalForwardingRules
	MockGlobalForwardingRules              *MockGlobalForwardingRules
	MockHealthChecks                       *MockHealthChecks
	MockAlphaHealthChecks                  *MockAlphaHealthChecks
	MockBetaHealthChecks                   *MockBetaHealthChecks
	MockAlphaRegionHealthChecks            *MockAlphaRegionHealthChecks
	MockBetaRegionHealthChecks             *MockBetaRegionHealthChecks
	MockRegionHealthChecks                 *MockRegionHealthChecks
	MockHttpHealthChecks                   *MockHttpHealthChecks
	MockHttpsHealthChecks                  *MockHttpsHealthChecks
	MockInstanceGroups                     *MockInstanceGroups
	MockInstances                          *MockInstances
	MockBetaInstances                      *MockBetaInstances
	MockAlphaInstances                     *MockAlphaInstances
	MockInstanceGroupManagers              *MockInstanceGroupManagers
	MockInstanceTemplates                  *MockInstanceTemplates
	MockImages                             *MockImages
	MockBetaImages                         *MockBetaImages
	MockAlphaImages                        *MockAlphaImages
	MockAlphaNetworks                      *MockAlphaNetworks
	MockBetaNetworks                       *MockBetaNetworks
	MockNetworks                           *MockNetworks
	MockAlphaNetworkEndpointGroups         *MockAlphaNetworkEndpointGroups
	MockBetaNetworkEndpointGroups          *MockBetaNetworkEndpointGroups
	MockNetworkEndpointGroups              *MockNetworkEndpointGroups
	MockAlphaGlobalNetworkEndpointGroups   *MockAlphaGlobalNetworkEndpointGroups
	MockBetaGlobalNetworkEndpointGroups    *MockBetaGlobalNetworkEndpointGroups
	MockGlobalNetworkEndpointGroups        *MockGlobalNetworkEndpointGroups
	MockProjects                           *MockProjects
	MockRegions                            *MockRegions
	MockAlphaRouters                       *MockAlphaRouters
	MockBetaRouters                        *MockBetaRouters
	MockRouters                            *MockRouters
	MockRoutes                             *MockRoutes
	MockBetaSecurityPolicies               *MockBetaSecurityPolicies
	MockServiceAttachments                 *MockServiceAttachments
	MockBetaServiceAttachments             *MockBetaServiceAttachments
	MockAlphaServiceAttachments            *MockAlphaServiceAttachments
	MockSslCertificates                    *MockSslCertificates
	MockBetaSslCertificates                *MockBetaSslCertificates
	MockAlphaSslCertificates               *MockAlphaSslCertificates
	MockAlphaRegionSslCertificates         *MockAlphaRegionSslCertificates
	MockBetaRegionSslCertificates          *MockBetaRegionSslCertificates
	MockRegionSslCertificates              *MockRegionSslCertificates
	MockSslPolicies                        *MockSslPolicies
	MockRegionSslPolicies                  *MockRegionSslPolicies
	MockAlphaSubnetworks                   *MockAlphaSubnetworks
	MockBetaSubnetworks                    *MockBetaSubnetworks
	MockSubnetworks                        *MockSubnetworks
	MockAlphaTargetHttpProxies             *MockAlphaTargetHttpProxies
	MockBetaTargetHttpProxies              *MockBetaTargetHttpProxies
	MockTargetHttpProxies                  *MockTargetHttpProxies
	MockAlphaRegionTargetHttpProxies       *MockAlphaRegionTargetHttpProxies
	MockBetaRegionTargetHttpProxies        *MockBetaRegionTargetHttpProxies
	MockRegionTargetHttpProxies            *MockRegionTargetHttpProxies
	MockTargetHttpsProxies                 *MockTargetHttpsProxies
	MockAlphaTargetHttpsProxies            *MockAlphaTargetHttpsProxies
	MockBetaTargetHttpsProxies             *MockBetaTargetHttpsProxies
	MockAlphaRegionTargetHttpsProxies      *MockAlphaRegionTargetHttpsProxies
	MockBetaRegionTargetHttpsProxies       *MockBetaRegionTargetHttpsProxies
	MockRegionTargetHttpsProxies           *MockRegionTargetHttpsProxies
	MockTargetPools                        *MockTargetPools
	MockAlphaTargetTcpProxies              *MockAlphaTargetTcpProxies
	MockBetaTargetTcpProxies               *MockBetaTargetTcpProxies
	MockTargetTcpProxies                   *MockTargetTcpProxies
	MockAlphaUrlMaps                       *MockAlphaUrlMaps
	MockBetaUrlMaps                        *MockBetaUrlMaps
	MockUrlMaps                            *MockUrlMaps
	MockAlphaRegionUrlMaps                 *MockAlphaRegionUrlMaps
	MockBetaRegionUrlMaps                  *MockBetaRegionUrlMaps
	MockRegionUrlMaps                      *MockRegionUrlMaps
	MockZones                              *MockZones
	MockTcpRoutes                          *MockTcpRoutes
	MockBetaTcpRoutes                      *MockBetaTcpRoutes
	MockMeshes                             *MockMeshes
	MockBetaMeshes                         *MockBetaMeshes
}

// Addresses returns the interface for the ga Addresses.
func (mock *MockGCE) Addresses() Addresses {
	return mock.MockAddresses
}

// AlphaAddresses returns the interface for the alpha Addresses.
func (mock *MockGCE) AlphaAddresses() AlphaAddresses {
	return mock.MockAlphaAddresses
}

// BetaAddresses returns the interface for the beta Addresses.
func (mock *MockGCE) BetaAddresses() BetaAddresses {
	return mock.MockBetaAddresses
}

// AlphaGlobalAddresses returns the interface for the alpha GlobalAddresses.
func (mock *MockGCE) AlphaGlobalAddresses() AlphaGlobalAddresses {
	return mock.MockAlphaGlobalAddresses
}

// BetaGlobalAddresses returns the interface for the beta GlobalAddresses.
func (mock *MockGCE) BetaGlobalAddresses() BetaGlobalAddresses {
	return mock.MockBetaGlobalAddresses
}

// GlobalAddresses returns the interface for the ga GlobalAddresses.
func (mock *MockGCE) GlobalAddresses() GlobalAddresses {
	return mock.MockGlobalAddresses
}

// BackendServices returns the interface for the ga BackendServices.
func (mock *MockGCE) BackendServices() BackendServices {
	return mock.MockBackendServices
}

// BetaBackendServices returns the interface for the beta BackendServices.
func (mock *MockGCE) BetaBackendServices() BetaBackendServices {
	return mock.MockBetaBackendServices
}

// AlphaBackendServices returns the interface for the alpha BackendServices.
func (mock *MockGCE) AlphaBackendServices() AlphaBackendServices {
	return mock.MockAlphaBackendServices
}

// RegionBackendServices returns the interface for the ga RegionBackendServices.
func (mock *MockGCE) RegionBackendServices() RegionBackendServices {
	return mock.MockRegionBackendServices
}

// AlphaRegionBackendServices returns the interface for the alpha RegionBackendServices.
func (mock *MockGCE) AlphaRegionBackendServices() AlphaRegionBackendServices {
	return mock.MockAlphaRegionBackendServices
}

// BetaRegionBackendServices returns the interface for the beta RegionBackendServices.
func (mock *MockGCE) BetaRegionBackendServices() BetaRegionBackendServices {
	return mock.MockBetaRegionBackendServices
}

// Disks returns the interface for the ga Disks.
func (mock *MockGCE) Disks() Disks {
	return mock.MockDisks
}

// RegionDisks returns the interface for the ga RegionDisks.
func (mock *MockGCE) RegionDisks() RegionDisks {
	return mock.MockRegionDisks
}

// AlphaFirewalls returns the interface for the alpha Firewalls.
func (mock *MockGCE) AlphaFirewalls() AlphaFirewalls {
	return mock.MockAlphaFirewalls
}

// BetaFirewalls returns the interface for the beta Firewalls.
func (mock *MockGCE) BetaFirewalls() BetaFirewalls {
	return mock.MockBetaFirewalls
}

// Firewalls returns the interface for the ga Firewalls.
func (mock *MockGCE) Firewalls() Firewalls {
	return mock.MockFirewalls
}

// AlphaNetworkFirewallPolicies returns the interface for the alpha NetworkFirewallPolicies.
func (mock *MockGCE) AlphaNetworkFirewallPolicies() AlphaNetworkFirewallPolicies {
	return mock.MockAlphaNetworkFirewallPolicies
}

// AlphaRegionNetworkFirewallPolicies returns the interface for the alpha RegionNetworkFirewallPolicies.
func (mock *MockGCE) AlphaRegionNetworkFirewallPolicies() AlphaRegionNetworkFirewallPolicies {
	return mock.MockAlphaRegionNetworkFirewallPolicies
}

// ForwardingRules returns the interface for the ga ForwardingRules.
func (mock *MockGCE) ForwardingRules() ForwardingRules {
	return mock.MockForwardingRules
}

// AlphaForwardingRules returns the interface for the alpha ForwardingRules.
func (mock *MockGCE) AlphaForwardingRules() AlphaForwardingRules {
	return mock.MockAlphaForwardingRules
}

// BetaForwardingRules returns the interface for the beta ForwardingRules.
func (mock *MockGCE) BetaForwardingRules() BetaForwardingRules {
	return mock.MockBetaForwardingRules
}

// AlphaGlobalForwardingRules returns the interface for the alpha GlobalForwardingRules.
func (mock *MockGCE) AlphaGlobalForwardingRules() AlphaGlobalForwardingRules {
	return mock.MockAlphaGlobalForwardingRules
}

// BetaGlobalForwardingRules returns the interface for the beta GlobalForwardingRules.
func (mock *MockGCE) BetaGlobalForwardingRules() BetaGlobalForwardingRules {
	return mock.MockBetaGlobalForwardingRules
}

// GlobalForwardingRules returns the interface for the ga GlobalForwardingRules.
func (mock *MockGCE) GlobalForwardingRules() GlobalForwardingRules {
	return mock.MockGlobalForwardingRules
}

// HealthChecks returns the interface for the ga HealthChecks.
func (mock *MockGCE) HealthChecks() HealthChecks {
	return mock.MockHealthChecks
}

// AlphaHealthChecks returns the interface for the alpha HealthChecks.
func (mock *MockGCE) AlphaHealthChecks() AlphaHealthChecks {
	return mock.MockAlphaHealthChecks
}

// BetaHealthChecks returns the interface for the beta HealthChecks.
func (mock *MockGCE) BetaHealthChecks() BetaHealthChecks {
	return mock.MockBetaHealthChecks
}

// AlphaRegionHealthChecks returns the interface for the alpha RegionHealthChecks.
func (mock *MockGCE) AlphaRegionHealthChecks() AlphaRegionHealthChecks {
	return mock.MockAlphaRegionHealthChecks
}

// BetaRegionHealthChecks returns the interface for the beta RegionHealthChecks.
func (mock *MockGCE) BetaRegionHealthChecks() BetaRegionHealthChecks {
	return mock.MockBetaRegionHealthChecks
}

// RegionHealthChecks returns the interface for the ga RegionHealthChecks.
func (mock *MockGCE) RegionHealthChecks() RegionHealthChecks {
	return mock.MockRegionHealthChecks
}

// HttpHealthChecks returns the interface for the ga HttpHealthChecks.
func (mock *MockGCE) HttpHealthChecks() HttpHealthChecks {
	return mock.MockHttpHealthChecks
}

// HttpsHealthChecks returns the interface for the ga HttpsHealthChecks.
func (mock *MockGCE) HttpsHealthChecks() HttpsHealthChecks {
	return mock.MockHttpsHealthChecks
}

// InstanceGroups returns the interface for the ga InstanceGroups.
func (mock *MockGCE) InstanceGroups() InstanceGroups {
	return mock.MockInstanceGroups
}

// Instances returns the interface for the ga Instances.
func (mock *MockGCE) Instances() Instances {
	return mock.MockInstances
}

// BetaInstances returns the interface for the beta Instances.
func (mock *MockGCE) BetaInstances() BetaInstances {
	return mock.MockBetaInstances
}

// AlphaInstances returns the interface for the alpha Instances.
func (mock *MockGCE) AlphaInstances() AlphaInstances {
	return mock.MockAlphaInstances
}

// InstanceGroupManagers returns the interface for the ga InstanceGroupManagers.
func (mock *MockGCE) InstanceGroupManagers() InstanceGroupManagers {
	return mock.MockInstanceGroupManagers
}

// InstanceTemplates returns the interface for the ga InstanceTemplates.
func (mock *MockGCE) InstanceTemplates() InstanceTemplates {
	return mock.MockInstanceTemplates
}

// Images returns the interface for the ga Images.
func (mock *MockGCE) Images() Images {
	return mock.MockImages
}

// BetaImages returns the interface for the beta Images.
func (mock *MockGCE) BetaImages() BetaImages {
	return mock.MockBetaImages
}

// AlphaImages returns the interface for the alpha Images.
func (mock *MockGCE) AlphaImages() AlphaImages {
	return mock.MockAlphaImages
}

// AlphaNetworks returns the interface for the alpha Networks.
func (mock *MockGCE) AlphaNetworks() AlphaNetworks {
	return mock.MockAlphaNetworks
}

// BetaNetworks returns the interface for the beta Networks.
func (mock *MockGCE) BetaNetworks() BetaNetworks {
	return mock.MockBetaNetworks
}

// Networks returns the interface for the ga Networks.
func (mock *MockGCE) Networks() Networks {
	return mock.MockNetworks
}

// AlphaNetworkEndpointGroups returns the interface for the alpha NetworkEndpointGroups.
func (mock *MockGCE) AlphaNetworkEndpointGroups() AlphaNetworkEndpointGroups {
	return mock.MockAlphaNetworkEndpointGroups
}

// BetaNetworkEndpointGroups returns the interface for the beta NetworkEndpointGroups.
func (mock *MockGCE) BetaNetworkEndpointGroups() BetaNetworkEndpointGroups {
	return mock.MockBetaNetworkEndpointGroups
}

// NetworkEndpointGroups returns the interface for the ga NetworkEndpointGroups.
func (mock *MockGCE) NetworkEndpointGroups() NetworkEndpointGroups {
	return mock.MockNetworkEndpointGroups
}

// AlphaGlobalNetworkEndpointGroups returns the interface for the alpha GlobalNetworkEndpointGroups.
func (mock *MockGCE) AlphaGlobalNetworkEndpointGroups() AlphaGlobalNetworkEndpointGroups {
	return mock.MockAlphaGlobalNetworkEndpointGroups
}

// BetaGlobalNetworkEndpointGroups returns the interface for the beta GlobalNetworkEndpointGroups.
func (mock *MockGCE) BetaGlobalNetworkEndpointGroups() BetaGlobalNetworkEndpointGroups {
	return mock.MockBetaGlobalNetworkEndpointGroups
}

// GlobalNetworkEndpointGroups returns the interface for the ga GlobalNetworkEndpointGroups.
func (mock *MockGCE) GlobalNetworkEndpointGroups() GlobalNetworkEndpointGroups {
	return mock.MockGlobalNetworkEndpointGroups
}

// Projects returns the interface for the ga Projects.
func (mock *MockGCE) Projects() Projects {
	return mock.MockProjects
}

// Regions returns the interface for the ga Regions.
func (mock *MockGCE) Regions() Regions {
	return mock.MockRegions
}

// AlphaRouters returns the interface for the alpha Routers.
func (mock *MockGCE) AlphaRouters() AlphaRouters {
	return mock.MockAlphaRouters
}

// BetaRouters returns the interface for the beta Routers.
func (mock *MockGCE) BetaRouters() BetaRouters {
	return mock.MockBetaRouters
}

// Routers returns the interface for the ga Routers.
func (mock *MockGCE) Routers() Routers {
	return mock.MockRouters
}

// Routes returns the interface for the ga Routes.
func (mock *MockGCE) Routes() Routes {
	return mock.MockRoutes
}

// BetaSecurityPolicies returns the interface for the beta SecurityPolicies.
func (mock *MockGCE) BetaSecurityPolicies() BetaSecurityPolicies {
	return mock.MockBetaSecurityPolicies
}

// ServiceAttachments returns the interface for the ga ServiceAttachments.
func (mock *MockGCE) ServiceAttachments() ServiceAttachments {
	return mock.MockServiceAttachments
}

// BetaServiceAttachments returns the interface for the beta ServiceAttachments.
func (mock *MockGCE) BetaServiceAttachments() BetaServiceAttachments {
	return mock.MockBetaServiceAttachments
}

// AlphaServiceAttachments returns the interface for the alpha ServiceAttachments.
func (mock *MockGCE) AlphaServiceAttachments() AlphaServiceAttachments {
	return mock.MockAlphaServiceAttachments
}

// SslCertificates returns the interface for the ga SslCertificates.
func (mock *MockGCE) SslCertificates() SslCertificates {
	return mock.MockSslCertificates
}

// BetaSslCertificates returns the interface for the beta SslCertificates.
func (mock *MockGCE) BetaSslCertificates() BetaSslCertificates {
	return mock.MockBetaSslCertificates
}

// AlphaSslCertificates returns the interface for the alpha SslCertificates.
func (mock *MockGCE) AlphaSslCertificates() AlphaSslCertificates {
	return mock.MockAlphaSslCertificates
}

// AlphaRegionSslCertificates returns the interface for the alpha RegionSslCertificates.
func (mock *MockGCE) AlphaRegionSslCertificates() AlphaRegionSslCertificates {
	return mock.MockAlphaRegionSslCertificates
}

// BetaRegionSslCertificates returns the interface for the beta RegionSslCertificates.
func (mock *MockGCE) BetaRegionSslCertificates() BetaRegionSslCertificates {
	return mock.MockBetaRegionSslCertificates
}

// RegionSslCertificates returns the interface for the ga RegionSslCertificates.
func (mock *MockGCE) RegionSslCertificates() RegionSslCertificates {
	return mock.MockRegionSslCertificates
}

// SslPolicies returns the interface for the ga SslPolicies.
func (mock *MockGCE) SslPolicies() SslPolicies {
	return mock.MockSslPolicies
}

// RegionSslPolicies returns the interface for the ga RegionSslPolicies.
func (mock *MockGCE) RegionSslPolicies() RegionSslPolicies {
	return mock.MockRegionSslPolicies
}

// AlphaSubnetworks returns the interface for the alpha Subnetworks.
func (mock *MockGCE) AlphaSubnetworks() AlphaSubnetworks {
	return mock.MockAlphaSubnetworks
}

// BetaSubnetworks returns the interface for the beta Subnetworks.
func (mock *MockGCE) BetaSubnetworks() BetaSubnetworks {
	return mock.MockBetaSubnetworks
}

// Subnetworks returns the interface for the ga Subnetworks.
func (mock *MockGCE) Subnetworks() Subnetworks {
	return mock.MockSubnetworks
}

// AlphaTargetHttpProxies returns the interface for the alpha TargetHttpProxies.
func (mock *MockGCE) AlphaTargetHttpProxies() AlphaTargetHttpProxies {
	return mock.MockAlphaTargetHttpProxies
}

// BetaTargetHttpProxies returns the interface for the beta TargetHttpProxies.
func (mock *MockGCE) BetaTargetHttpProxies() BetaTargetHttpProxies {
	return mock.MockBetaTargetHttpProxies
}

// TargetHttpProxies returns the interface for the ga TargetHttpProxies.
func (mock *MockGCE) TargetHttpProxies() TargetHttpProxies {
	return mock.MockTargetHttpProxies
}

// AlphaRegionTargetHttpProxies returns the interface for the alpha RegionTargetHttpProxies.
func (mock *MockGCE) AlphaRegionTargetHttpProxies() AlphaRegionTargetHttpProxies {
	return mock.MockAlphaRegionTargetHttpProxies
}

// BetaRegionTargetHttpProxies returns the interface for the beta RegionTargetHttpProxies.
func (mock *MockGCE) BetaRegionTargetHttpProxies() BetaRegionTargetHttpProxies {
	return mock.MockBetaRegionTargetHttpProxies
}

// RegionTargetHttpProxies returns the interface for the ga RegionTargetHttpProxies.
func (mock *MockGCE) RegionTargetHttpProxies() RegionTargetHttpProxies {
	return mock.MockRegionTargetHttpProxies
}

// TargetHttpsProxies returns the interface for the ga TargetHttpsProxies.
func (mock *MockGCE) TargetHttpsProxies() TargetHttpsProxies {
	return mock.MockTargetHttpsProxies
}

// AlphaTargetHttpsProxies returns the interface for the alpha TargetHttpsProxies.
func (mock *MockGCE) AlphaTargetHttpsProxies() AlphaTargetHttpsProxies {
	return mock.MockAlphaTargetHttpsProxies
}

// BetaTargetHttpsProxies returns the interface for the beta TargetHttpsProxies.
func (mock *MockGCE) BetaTargetHttpsProxies() BetaTargetHttpsProxies {
	return mock.MockBetaTargetHttpsProxies
}

// AlphaRegionTargetHttpsProxies returns the interface for the alpha RegionTargetHttpsProxies.
func (mock *MockGCE) AlphaRegionTargetHttpsProxies() AlphaRegionTargetHttpsProxies {
	return mock.MockAlphaRegionTargetHttpsProxies
}

// BetaRegionTargetHttpsProxies returns the interface for the beta RegionTargetHttpsProxies.
func (mock *MockGCE) BetaRegionTargetHttpsProxies() BetaRegionTargetHttpsProxies {
	return mock.MockBetaRegionTargetHttpsProxies
}

// RegionTargetHttpsProxies returns the interface for the ga RegionTargetHttpsProxies.
func (mock *MockGCE) RegionTargetHttpsProxies() RegionTargetHttpsProxies {
	return mock.MockRegionTargetHttpsProxies
}

// TargetPools returns the interface for the ga TargetPools.
func (mock *MockGCE) TargetPools() TargetPools {
	return mock.MockTargetPools
}

// AlphaTargetTcpProxies returns the interface for the alpha TargetTcpProxies.
func (mock *MockGCE) AlphaTargetTcpProxies() AlphaTargetTcpProxies {
	return mock.MockAlphaTargetTcpProxies
}

// BetaTargetTcpProxies returns the interface for the beta TargetTcpProxies.
func (mock *MockGCE) BetaTargetTcpProxies() BetaTargetTcpProxies {
	return mock.MockBetaTargetTcpProxies
}

// TargetTcpProxies returns the interface for the ga TargetTcpProxies.
func (mock *MockGCE) TargetTcpProxies() TargetTcpProxies {
	return mock.MockTargetTcpProxies
}

// AlphaUrlMaps returns the interface for the alpha UrlMaps.
func (mock *MockGCE) AlphaUrlMaps() AlphaUrlMaps {
	return mock.MockAlphaUrlMaps
}

// BetaUrlMaps returns the interface for the beta UrlMaps.
func (mock *MockGCE) BetaUrlMaps() BetaUrlMaps {
	return mock.MockBetaUrlMaps
}

// UrlMaps returns the interface for the ga UrlMaps.
func (mock *MockGCE) UrlMaps() UrlMaps {
	return mock.MockUrlMaps
}

// AlphaRegionUrlMaps returns the interface for the alpha RegionUrlMaps.
func (mock *MockGCE) AlphaRegionUrlMaps() AlphaRegionUrlMaps {
	return mock.MockAlphaRegionUrlMaps
}

// BetaRegionUrlMaps returns the interface for the beta RegionUrlMaps.
func (mock *MockGCE) BetaRegionUrlMaps() BetaRegionUrlMaps {
	return mock.MockBetaRegionUrlMaps
}

// RegionUrlMaps returns the interface for the ga RegionUrlMaps.
func (mock *MockGCE) RegionUrlMaps() RegionUrlMaps {
	return mock.MockRegionUrlMaps
}

// Zones returns the interface for the ga Zones.
func (mock *MockGCE) Zones() Zones {
	return mock.MockZones
}

// TcpRoutes returns the interface for the ga TcpRoutes.
func (mock *MockGCE) TcpRoutes() TcpRoutes {
	return mock.MockTcpRoutes
}

// BetaTcpRoutes returns the interface for the beta TcpRoutes.
func (mock *MockGCE) BetaTcpRoutes() BetaTcpRoutes {
	return mock.MockBetaTcpRoutes
}

// Meshes returns the interface for the ga Meshes.
func (mock *MockGCE) Meshes() Meshes {
	return mock.MockMeshes
}

// BetaMeshes returns the interface for the beta Meshes.
func (mock *MockGCE) BetaMeshes() BetaMeshes {
	return mock.MockBetaMeshes
}

// MockAddressesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockAddressesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockAddressesObj) ToAlpha() *computealpha.Address {
	if ret, ok := m.Obj.(*computealpha.Address); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Address{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Address via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockAddressesObj) ToBeta() *computebeta.Address {
	if ret, ok := m.Obj.(*computebeta.Address); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Address{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Address via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockAddressesObj) ToGA() *computega.Address {
	if ret, ok := m.Obj.(*computega.Address); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Address{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Address via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockBackendServicesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockBackendServicesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockBackendServicesObj) ToAlpha() *computealpha.BackendService {
	if ret, ok := m.Obj.(*computealpha.BackendService); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.BackendService{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.BackendService via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockBackendServicesObj) ToBeta() *computebeta.BackendService {
	if ret, ok := m.Obj.(*computebeta.BackendService); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.BackendService{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.BackendService via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockBackendServicesObj) ToGA() *computega.BackendService {
	if ret, ok := m.Obj.(*computega.BackendService); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.BackendService{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.BackendService via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockDisksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockDisksObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockDisksObj) ToGA() *computega.Disk {
	if ret, ok := m.Obj.(*computega.Disk); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Disk{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Disk via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockFirewallsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockFirewallsObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockFirewallsObj) ToAlpha() *computealpha.Firewall {
	if ret, ok := m.Obj.(*computealpha.Firewall); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Firewall{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Firewall via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockFirewallsObj) ToBeta() *computebeta.Firewall {
	if ret, ok := m.Obj.(*computebeta.Firewall); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Firewall{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Firewall via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockFirewallsObj) ToGA() *computega.Firewall {
	if ret, ok := m.Obj.(*computega.Firewall); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Firewall{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Firewall via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockForwardingRulesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockForwardingRulesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockForwardingRulesObj) ToAlpha() *computealpha.ForwardingRule {
	if ret, ok := m.Obj.(*computealpha.ForwardingRule); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.ForwardingRule{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.ForwardingRule via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockForwardingRulesObj) ToBeta() *computebeta.ForwardingRule {
	if ret, ok := m.Obj.(*computebeta.ForwardingRule); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.ForwardingRule{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.ForwardingRule via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockForwardingRulesObj) ToGA() *computega.ForwardingRule {
	if ret, ok := m.Obj.(*computega.ForwardingRule); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.ForwardingRule{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.ForwardingRule via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockGlobalAddressesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockGlobalAddressesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockGlobalAddressesObj) ToAlpha() *computealpha.Address {
	if ret, ok := m.Obj.(*computealpha.Address); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Address{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Address via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockGlobalAddressesObj) ToBeta() *computebeta.Address {
	if ret, ok := m.Obj.(*computebeta.Address); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Address{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Address via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockGlobalAddressesObj) ToGA() *computega.Address {
	if ret, ok := m.Obj.(*computega.Address); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Address{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Address via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockGlobalForwardingRulesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockGlobalForwardingRulesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockGlobalForwardingRulesObj) ToAlpha() *computealpha.ForwardingRule {
	if ret, ok := m.Obj.(*computealpha.ForwardingRule); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.ForwardingRule{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.ForwardingRule via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockGlobalForwardingRulesObj) ToBeta() *computebeta.ForwardingRule {
	if ret, ok := m.Obj.(*computebeta.ForwardingRule); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.ForwardingRule{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.ForwardingRule via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockGlobalForwardingRulesObj) ToGA() *computega.ForwardingRule {
	if ret, ok := m.Obj.(*computega.ForwardingRule); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.ForwardingRule{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.ForwardingRule via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockGlobalNetworkEndpointGroupsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockGlobalNetworkEndpointGroupsObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockGlobalNetworkEndpointGroupsObj) ToAlpha() *computealpha.NetworkEndpointGroup {
	if ret, ok := m.Obj.(*computealpha.NetworkEndpointGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.NetworkEndpointGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.NetworkEndpointGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockGlobalNetworkEndpointGroupsObj) ToBeta() *computebeta.NetworkEndpointGroup {
	if ret, ok := m.Obj.(*computebeta.NetworkEndpointGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.NetworkEndpointGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.NetworkEndpointGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockGlobalNetworkEndpointGroupsObj) ToGA() *computega.NetworkEndpointGroup {
	if ret, ok := m.Obj.(*computega.NetworkEndpointGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.NetworkEndpointGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.NetworkEndpointGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockHealthChecksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockHealthChecksObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockHealthChecksObj) ToAlpha() *computealpha.HealthCheck {
	if ret, ok := m.Obj.(*computealpha.HealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.HealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.HealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockHealthChecksObj) ToBeta() *computebeta.HealthCheck {
	if ret, ok := m.Obj.(*computebeta.HealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.HealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.HealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockHealthChecksObj) ToGA() *computega.HealthCheck {
	if ret, ok := m.Obj.(*computega.HealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.HealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.HealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockHttpHealthChecksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockHttpHealthChecksObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockHttpHealthChecksObj) ToGA() *computega.HttpHealthCheck {
	if ret, ok := m.Obj.(*computega.HttpHealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.HttpHealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.HttpHealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockHttpsHealthChecksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockHttpsHealthChecksObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockHttpsHealthChecksObj) ToGA() *computega.HttpsHealthCheck {
	if ret, ok := m.Obj.(*computega.HttpsHealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.HttpsHealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.HttpsHealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockImagesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockImagesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockImagesObj) ToAlpha() *computealpha.Image {
	if ret, ok := m.Obj.(*computealpha.Image); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Image{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Image via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockImagesObj) ToBeta() *computebeta.Image {
	if ret, ok := m.Obj.(*computebeta.Image); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Image{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Image via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockImagesObj) ToGA() *computega.Image {
	if ret, ok := m.Obj.(*computega.Image); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Image{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Image via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockInstanceGroupManagersObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockInstanceGroupManagersObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockInstanceGroupManagersObj) ToGA() *computega.InstanceGroupManager {
	if ret, ok := m.Obj.(*computega.InstanceGroupManager); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.InstanceGroupManager{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.InstanceGroupManager via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockInstanceGroupsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockInstanceGroupsObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockInstanceGroupsObj) ToGA() *computega.InstanceGroup {
	if ret, ok := m.Obj.(*computega.InstanceGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.InstanceGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.InstanceGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockInstanceTemplatesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockInstanceTemplatesObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockInstanceTemplatesObj) ToGA() *computega.InstanceTemplate {
	if ret, ok := m.Obj.(*computega.InstanceTemplate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.InstanceTemplate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.InstanceTemplate via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockInstancesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockInstancesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockInstancesObj) ToAlpha() *computealpha.Instance {
	if ret, ok := m.Obj.(*computealpha.Instance); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Instance{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Instance via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockInstancesObj) ToBeta() *computebeta.Instance {
	if ret, ok := m.Obj.(*computebeta.Instance); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Instance{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Instance via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockInstancesObj) ToGA() *computega.Instance {
	if ret, ok := m.Obj.(*computega.Instance); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Instance{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Instance via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockMeshesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockMeshesObj struct {
	Obj interface{}
}

// ToBeta retrieves the given version of the object.
func (m *MockMeshesObj) ToBeta() *networkservicesbeta.Mesh {
	if ret, ok := m.Obj.(*networkservicesbeta.Mesh); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &networkservicesbeta.Mesh{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *networkservicesbeta.Mesh via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockMeshesObj) ToGA() *networkservicesga.Mesh {
	if ret, ok := m.Obj.(*networkservicesga.Mesh); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &networkservicesga.Mesh{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *networkservicesga.Mesh via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockNetworkEndpointGroupsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockNetworkEndpointGroupsObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockNetworkEndpointGroupsObj) ToAlpha() *computealpha.NetworkEndpointGroup {
	if ret, ok := m.Obj.(*computealpha.NetworkEndpointGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.NetworkEndpointGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.NetworkEndpointGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockNetworkEndpointGroupsObj) ToBeta() *computebeta.NetworkEndpointGroup {
	if ret, ok := m.Obj.(*computebeta.NetworkEndpointGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.NetworkEndpointGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.NetworkEndpointGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockNetworkEndpointGroupsObj) ToGA() *computega.NetworkEndpointGroup {
	if ret, ok := m.Obj.(*computega.NetworkEndpointGroup); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.NetworkEndpointGroup{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.NetworkEndpointGroup via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockNetworkFirewallPoliciesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockNetworkFirewallPoliciesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockNetworkFirewallPoliciesObj) ToAlpha() *computealpha.FirewallPolicy {
	if ret, ok := m.Obj.(*computealpha.FirewallPolicy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.FirewallPolicy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.FirewallPolicy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockNetworksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockNetworksObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockNetworksObj) ToAlpha() *computealpha.Network {
	if ret, ok := m.Obj.(*computealpha.Network); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Network{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Network via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockNetworksObj) ToBeta() *computebeta.Network {
	if ret, ok := m.Obj.(*computebeta.Network); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Network{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Network via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockNetworksObj) ToGA() *computega.Network {
	if ret, ok := m.Obj.(*computega.Network); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Network{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Network via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockProjectsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockProjectsObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockProjectsObj) ToGA() *computega.Project {
	if ret, ok := m.Obj.(*computega.Project); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Project{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Project via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionBackendServicesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionBackendServicesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionBackendServicesObj) ToAlpha() *computealpha.BackendService {
	if ret, ok := m.Obj.(*computealpha.BackendService); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.BackendService{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.BackendService via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRegionBackendServicesObj) ToBeta() *computebeta.BackendService {
	if ret, ok := m.Obj.(*computebeta.BackendService); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.BackendService{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.BackendService via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRegionBackendServicesObj) ToGA() *computega.BackendService {
	if ret, ok := m.Obj.(*computega.BackendService); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.BackendService{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.BackendService via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionDisksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionDisksObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockRegionDisksObj) ToGA() *computega.Disk {
	if ret, ok := m.Obj.(*computega.Disk); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Disk{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Disk via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionHealthChecksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionHealthChecksObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionHealthChecksObj) ToAlpha() *computealpha.HealthCheck {
	if ret, ok := m.Obj.(*computealpha.HealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.HealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.HealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRegionHealthChecksObj) ToBeta() *computebeta.HealthCheck {
	if ret, ok := m.Obj.(*computebeta.HealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.HealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.HealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRegionHealthChecksObj) ToGA() *computega.HealthCheck {
	if ret, ok := m.Obj.(*computega.HealthCheck); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.HealthCheck{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.HealthCheck via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionNetworkFirewallPoliciesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionNetworkFirewallPoliciesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionNetworkFirewallPoliciesObj) ToAlpha() *computealpha.FirewallPolicy {
	if ret, ok := m.Obj.(*computealpha.FirewallPolicy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.FirewallPolicy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.FirewallPolicy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionSslCertificatesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionSslCertificatesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionSslCertificatesObj) ToAlpha() *computealpha.SslCertificate {
	if ret, ok := m.Obj.(*computealpha.SslCertificate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.SslCertificate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.SslCertificate via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRegionSslCertificatesObj) ToBeta() *computebeta.SslCertificate {
	if ret, ok := m.Obj.(*computebeta.SslCertificate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.SslCertificate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.SslCertificate via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRegionSslCertificatesObj) ToGA() *computega.SslCertificate {
	if ret, ok := m.Obj.(*computega.SslCertificate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.SslCertificate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.SslCertificate via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionSslPoliciesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionSslPoliciesObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockRegionSslPoliciesObj) ToGA() *computega.SslPolicy {
	if ret, ok := m.Obj.(*computega.SslPolicy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.SslPolicy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.SslPolicy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionTargetHttpProxiesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionTargetHttpProxiesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionTargetHttpProxiesObj) ToAlpha() *computealpha.TargetHttpProxy {
	if ret, ok := m.Obj.(*computealpha.TargetHttpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.TargetHttpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.TargetHttpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRegionTargetHttpProxiesObj) ToBeta() *computebeta.TargetHttpProxy {
	if ret, ok := m.Obj.(*computebeta.TargetHttpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.TargetHttpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.TargetHttpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRegionTargetHttpProxiesObj) ToGA() *computega.TargetHttpProxy {
	if ret, ok := m.Obj.(*computega.TargetHttpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.TargetHttpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.TargetHttpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionTargetHttpsProxiesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionTargetHttpsProxiesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionTargetHttpsProxiesObj) ToAlpha() *computealpha.TargetHttpsProxy {
	if ret, ok := m.Obj.(*computealpha.TargetHttpsProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.TargetHttpsProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.TargetHttpsProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRegionTargetHttpsProxiesObj) ToBeta() *computebeta.TargetHttpsProxy {
	if ret, ok := m.Obj.(*computebeta.TargetHttpsProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.TargetHttpsProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.TargetHttpsProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRegionTargetHttpsProxiesObj) ToGA() *computega.TargetHttpsProxy {
	if ret, ok := m.Obj.(*computega.TargetHttpsProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.TargetHttpsProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.TargetHttpsProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionUrlMapsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionUrlMapsObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRegionUrlMapsObj) ToAlpha() *computealpha.UrlMap {
	if ret, ok := m.Obj.(*computealpha.UrlMap); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.UrlMap{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.UrlMap via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRegionUrlMapsObj) ToBeta() *computebeta.UrlMap {
	if ret, ok := m.Obj.(*computebeta.UrlMap); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.UrlMap{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.UrlMap via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRegionUrlMapsObj) ToGA() *computega.UrlMap {
	if ret, ok := m.Obj.(*computega.UrlMap); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.UrlMap{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.UrlMap via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRegionsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRegionsObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockRegionsObj) ToGA() *computega.Region {
	if ret, ok := m.Obj.(*computega.Region); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Region{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Region via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRoutersObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRoutersObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockRoutersObj) ToAlpha() *computealpha.Router {
	if ret, ok := m.Obj.(*computealpha.Router); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Router{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Router via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockRoutersObj) ToBeta() *computebeta.Router {
	if ret, ok := m.Obj.(*computebeta.Router); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Router{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Router via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockRoutersObj) ToGA() *computega.Router {
	if ret, ok := m.Obj.(*computega.Router); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Router{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Router via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockRoutesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockRoutesObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockRoutesObj) ToGA() *computega.Route {
	if ret, ok := m.Obj.(*computega.Route); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Route{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Route via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockSecurityPoliciesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockSecurityPoliciesObj struct {
	Obj interface{}
}

// ToBeta retrieves the given version of the object.
func (m *MockSecurityPoliciesObj) ToBeta() *computebeta.SecurityPolicy {
	if ret, ok := m.Obj.(*computebeta.SecurityPolicy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.SecurityPolicy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.SecurityPolicy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockServiceAttachmentsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockServiceAttachmentsObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockServiceAttachmentsObj) ToAlpha() *computealpha.ServiceAttachment {
	if ret, ok := m.Obj.(*computealpha.ServiceAttachment); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.ServiceAttachment{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.ServiceAttachment via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockServiceAttachmentsObj) ToBeta() *computebeta.ServiceAttachment {
	if ret, ok := m.Obj.(*computebeta.ServiceAttachment); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.ServiceAttachment{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.ServiceAttachment via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockServiceAttachmentsObj) ToGA() *computega.ServiceAttachment {
	if ret, ok := m.Obj.(*computega.ServiceAttachment); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.ServiceAttachment{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.ServiceAttachment via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockSslCertificatesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockSslCertificatesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockSslCertificatesObj) ToAlpha() *computealpha.SslCertificate {
	if ret, ok := m.Obj.(*computealpha.SslCertificate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.SslCertificate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.SslCertificate via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockSslCertificatesObj) ToBeta() *computebeta.SslCertificate {
	if ret, ok := m.Obj.(*computebeta.SslCertificate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.SslCertificate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.SslCertificate via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockSslCertificatesObj) ToGA() *computega.SslCertificate {
	if ret, ok := m.Obj.(*computega.SslCertificate); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.SslCertificate{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.SslCertificate via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockSslPoliciesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockSslPoliciesObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockSslPoliciesObj) ToGA() *computega.SslPolicy {
	if ret, ok := m.Obj.(*computega.SslPolicy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.SslPolicy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.SslPolicy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockSubnetworksObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockSubnetworksObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockSubnetworksObj) ToAlpha() *computealpha.Subnetwork {
	if ret, ok := m.Obj.(*computealpha.Subnetwork); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.Subnetwork{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.Subnetwork via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockSubnetworksObj) ToBeta() *computebeta.Subnetwork {
	if ret, ok := m.Obj.(*computebeta.Subnetwork); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.Subnetwork{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.Subnetwork via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockSubnetworksObj) ToGA() *computega.Subnetwork {
	if ret, ok := m.Obj.(*computega.Subnetwork); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Subnetwork{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Subnetwork via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockTargetHttpProxiesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockTargetHttpProxiesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockTargetHttpProxiesObj) ToAlpha() *computealpha.TargetHttpProxy {
	if ret, ok := m.Obj.(*computealpha.TargetHttpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.TargetHttpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.TargetHttpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockTargetHttpProxiesObj) ToBeta() *computebeta.TargetHttpProxy {
	if ret, ok := m.Obj.(*computebeta.TargetHttpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.TargetHttpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.TargetHttpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockTargetHttpProxiesObj) ToGA() *computega.TargetHttpProxy {
	if ret, ok := m.Obj.(*computega.TargetHttpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.TargetHttpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.TargetHttpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockTargetHttpsProxiesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockTargetHttpsProxiesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockTargetHttpsProxiesObj) ToAlpha() *computealpha.TargetHttpsProxy {
	if ret, ok := m.Obj.(*computealpha.TargetHttpsProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.TargetHttpsProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.TargetHttpsProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockTargetHttpsProxiesObj) ToBeta() *computebeta.TargetHttpsProxy {
	if ret, ok := m.Obj.(*computebeta.TargetHttpsProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.TargetHttpsProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.TargetHttpsProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockTargetHttpsProxiesObj) ToGA() *computega.TargetHttpsProxy {
	if ret, ok := m.Obj.(*computega.TargetHttpsProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.TargetHttpsProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.TargetHttpsProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockTargetPoolsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockTargetPoolsObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockTargetPoolsObj) ToGA() *computega.TargetPool {
	if ret, ok := m.Obj.(*computega.TargetPool); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.TargetPool{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.TargetPool via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockTargetTcpProxiesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockTargetTcpProxiesObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockTargetTcpProxiesObj) ToAlpha() *computealpha.TargetTcpProxy {
	if ret, ok := m.Obj.(*computealpha.TargetTcpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.TargetTcpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.TargetTcpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockTargetTcpProxiesObj) ToBeta() *computebeta.TargetTcpProxy {
	if ret, ok := m.Obj.(*computebeta.TargetTcpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.TargetTcpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.TargetTcpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockTargetTcpProxiesObj) ToGA() *computega.TargetTcpProxy {
	if ret, ok := m.Obj.(*computega.TargetTcpProxy); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.TargetTcpProxy{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.TargetTcpProxy via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockTcpRoutesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockTcpRoutesObj struct {
	Obj interface{}
}

// ToBeta retrieves the given version of the object.
func (m *MockTcpRoutesObj) ToBeta() *networkservicesbeta.TcpRoute {
	if ret, ok := m.Obj.(*networkservicesbeta.TcpRoute); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &networkservicesbeta.TcpRoute{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *networkservicesbeta.TcpRoute via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockTcpRoutesObj) ToGA() *networkservicesga.TcpRoute {
	if ret, ok := m.Obj.(*networkservicesga.TcpRoute); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &networkservicesga.TcpRoute{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *networkservicesga.TcpRoute via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockUrlMapsObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockUrlMapsObj struct {
	Obj interface{}
}

// ToAlpha retrieves the given version of the object.
func (m *MockUrlMapsObj) ToAlpha() *computealpha.UrlMap {
	if ret, ok := m.Obj.(*computealpha.UrlMap); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computealpha.UrlMap{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computealpha.UrlMap via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToBeta retrieves the given version of the object.
func (m *MockUrlMapsObj) ToBeta() *computebeta.UrlMap {
	if ret, ok := m.Obj.(*computebeta.UrlMap); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computebeta.UrlMap{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computebeta.UrlMap via JSON: %v", m.Obj, err)
	}
	return ret
}

// ToGA retrieves the given version of the object.
func (m *MockUrlMapsObj) ToGA() *computega.UrlMap {
	if ret, ok := m.Obj.(*computega.UrlMap); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.UrlMap{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.UrlMap via JSON: %v", m.Obj, err)
	}
	return ret
}

// MockZonesObj is used to store the various object versions in the shared
// map of mocked objects. This allows for multiple API versions to co-exist and
// share the same "view" of the objects in the backend.
type MockZonesObj struct {
	Obj interface{}
}

// ToGA retrieves the given version of the object.
func (m *MockZonesObj) ToGA() *computega.Zone {
	if ret, ok := m.Obj.(*computega.Zone); ok {
		return ret
	}
	// Convert the object via JSON copying to the type that was requested.
	ret := &computega.Zone{}
	if err := copyViaJSON(ret, m.Obj); err != nil {
		klog.Errorf("Could not convert %T to *computega.Zone via JSON: %v", m.Obj, err)
	}
	return ret
}

// Addresses is an interface that allows for mocking of Addresses.
type Addresses interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Address, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Address, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Address, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.Address, error)
}

// NewMockAddresses returns a new mock for Addresses.
func NewMockAddresses(pr ProjectRouter, objs map[meta.Key]*MockAddressesObj) *MockAddresses {
	mock := &MockAddresses{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAddresses is the mock for Addresses.
type MockAddresses struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockAddressesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook            func(ctx context.Context, key *meta.Key, m *MockAddresses, options ...Option) (bool, *computega.Address, error)
	ListHook           func(ctx context.Context, region string, fl *filter.F, m *MockAddresses, options ...Option) (bool, []*computega.Address, error)
	InsertHook         func(ctx context.Context, key *meta.Key, obj *computega.Address, m *MockAddresses, options ...Option) (bool, error)
	DeleteHook         func(ctx context.Context, key *meta.Key, m *MockAddresses, options ...Option) (bool, error)
	AggregatedListHook func(ctx context.Context, fl *filter.F, m *MockAddresses, options ...Option) (bool, map[string][]*computega.Address, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAddresses.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockAddresses.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAddresses %v not found", key),
	}
	klog.V(5).Infof("MockAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAddresses) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAddresses.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAddresses.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Address
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockAddresses.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAddresses) Insert(ctx context.Context, key *meta.Key, obj *computega.Address, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAddresses %v exists", key),
		}
		klog.V(5).Infof("MockAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "addresses")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "addresses", key)

	m.Objects[*key] = &MockAddressesObj{obj}
	klog.V(5).Infof("MockAddresses.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAddresses.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAddresses %v not found", key),
		}
		klog.V(5).Infof("MockAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAddresses.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockAddresses) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.Address, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAddresses.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockAddresses.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computega.Address{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToGA().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockAddresses.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToGA())
	}
	klog.V(5).Infof("MockAddresses.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockAddresses) Obj(o *computega.Address) *MockAddressesObj {
	return &MockAddressesObj{o}
}

// GCEAddresses is a simplifying adapter for the GCE Addresses.
type GCEAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAddresses.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAddresses.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Addresses",
	}

	klog.V(5).Infof("GCEAddresses.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAddresses.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Addresses.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAddresses.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Address objects.
func (g *GCEAddresses) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAddresses.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Addresses",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAddresses.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.Addresses.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Address
	f := func(l *computega.AddressList) error {
		klog.V(5).Infof("GCEAddresses.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAddresses.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEAddresses) Insert(ctx context.Context, key *meta.Key, obj *computega.Address, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAddresses.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAddresses.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Addresses",
	}
	klog.V(5).Infof("GCEAddresses.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAddresses.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Addresses.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAddresses.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAddresses.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Address referenced by key.
func (g *GCEAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAddresses.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAddresses.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Addresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Addresses",
	}
	klog.V(5).Infof("GCEAddresses.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAddresses.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Addresses.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAddresses.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEAddresses) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAddresses.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Addresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("ga"),
		Service:   "Addresses",
	}

	klog.V(5).Infof("GCEAddresses.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEAddresses.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.GA.Addresses.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computega.Address{}
	f := func(l *computega.AddressAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEAddresses.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.Addresses...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAddresses.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAddresses.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAddresses.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AlphaAddresses is an interface that allows for mocking of Addresses.
type AlphaAddresses interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Address, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Address, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Address, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.Address, error)
}

// NewMockAlphaAddresses returns a new mock for Addresses.
func NewMockAlphaAddresses(pr ProjectRouter, objs map[meta.Key]*MockAddressesObj) *MockAlphaAddresses {
	mock := &MockAlphaAddresses{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaAddresses is the mock for Addresses.
type MockAlphaAddresses struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockAddressesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook            func(ctx context.Context, key *meta.Key, m *MockAlphaAddresses, options ...Option) (bool, *computealpha.Address, error)
	ListHook           func(ctx context.Context, region string, fl *filter.F, m *MockAlphaAddresses, options ...Option) (bool, []*computealpha.Address, error)
	InsertHook         func(ctx context.Context, key *meta.Key, obj *computealpha.Address, m *MockAlphaAddresses, options ...Option) (bool, error)
	DeleteHook         func(ctx context.Context, key *meta.Key, m *MockAlphaAddresses, options ...Option) (bool, error)
	AggregatedListHook func(ctx context.Context, fl *filter.F, m *MockAlphaAddresses, options ...Option) (bool, map[string][]*computealpha.Address, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaAddresses.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaAddresses.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaAddresses %v not found", key),
	}
	klog.V(5).Infof("MockAlphaAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaAddresses) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaAddresses.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaAddresses.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Address
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaAddresses.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaAddresses) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Address, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaAddresses %v exists", key),
		}
		klog.V(5).Infof("MockAlphaAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "addresses")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "addresses", key)

	m.Objects[*key] = &MockAddressesObj{obj}
	klog.V(5).Infof("MockAlphaAddresses.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaAddresses.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaAddresses %v not found", key),
		}
		klog.V(5).Infof("MockAlphaAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaAddresses.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockAlphaAddresses) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.Address, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaAddresses.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockAlphaAddresses.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computealpha.Address{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToAlpha().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockAlphaAddresses.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToAlpha())
	}
	klog.V(5).Infof("MockAlphaAddresses.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaAddresses) Obj(o *computealpha.Address) *MockAddressesObj {
	return &MockAddressesObj{o}
}

// GCEAlphaAddresses is a simplifying adapter for the GCE Addresses.
type GCEAlphaAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEAlphaAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaAddresses.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaAddresses.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Addresses",
	}

	klog.V(5).Infof("GCEAlphaAddresses.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaAddresses.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Addresses.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaAddresses.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Address objects.
func (g *GCEAlphaAddresses) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaAddresses.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Addresses",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaAddresses.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.Addresses.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Address
	f := func(l *computealpha.AddressList) error {
		klog.V(5).Infof("GCEAlphaAddresses.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaAddresses.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEAlphaAddresses) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Address, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaAddresses.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaAddresses.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Addresses",
	}
	klog.V(5).Infof("GCEAlphaAddresses.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaAddresses.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Addresses.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaAddresses.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaAddresses.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Address referenced by key.
func (g *GCEAlphaAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaAddresses.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaAddresses.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Addresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Addresses",
	}
	klog.V(5).Infof("GCEAlphaAddresses.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaAddresses.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Addresses.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaAddresses.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEAlphaAddresses) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaAddresses.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Addresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("alpha"),
		Service:   "Addresses",
	}

	klog.V(5).Infof("GCEAlphaAddresses.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEAlphaAddresses.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Alpha.Addresses.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computealpha.Address{}
	f := func(l *computealpha.AddressAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEAlphaAddresses.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.Addresses...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaAddresses.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaAddresses.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaAddresses.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// BetaAddresses is an interface that allows for mocking of Addresses.
type BetaAddresses interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Address, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Address, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Address, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.Address, error)
}

// NewMockBetaAddresses returns a new mock for Addresses.
func NewMockBetaAddresses(pr ProjectRouter, objs map[meta.Key]*MockAddressesObj) *MockBetaAddresses {
	mock := &MockBetaAddresses{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaAddresses is the mock for Addresses.
type MockBetaAddresses struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockAddressesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook            func(ctx context.Context, key *meta.Key, m *MockBetaAddresses, options ...Option) (bool, *computebeta.Address, error)
	ListHook           func(ctx context.Context, region string, fl *filter.F, m *MockBetaAddresses, options ...Option) (bool, []*computebeta.Address, error)
	InsertHook         func(ctx context.Context, key *meta.Key, obj *computebeta.Address, m *MockBetaAddresses, options ...Option) (bool, error)
	DeleteHook         func(ctx context.Context, key *meta.Key, m *MockBetaAddresses, options ...Option) (bool, error)
	AggregatedListHook func(ctx context.Context, fl *filter.F, m *MockBetaAddresses, options ...Option) (bool, map[string][]*computebeta.Address, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaAddresses.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaAddresses.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaAddresses %v not found", key),
	}
	klog.V(5).Infof("MockBetaAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaAddresses) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaAddresses.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaAddresses.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Address
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaAddresses.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaAddresses) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Address, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaAddresses %v exists", key),
		}
		klog.V(5).Infof("MockBetaAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "addresses")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "addresses", key)

	m.Objects[*key] = &MockAddressesObj{obj}
	klog.V(5).Infof("MockBetaAddresses.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaAddresses.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaAddresses %v not found", key),
		}
		klog.V(5).Infof("MockBetaAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaAddresses.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockBetaAddresses) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.Address, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaAddresses.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockBetaAddresses.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computebeta.Address{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToBeta().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockBetaAddresses.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToBeta())
	}
	klog.V(5).Infof("MockBetaAddresses.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaAddresses) Obj(o *computebeta.Address) *MockAddressesObj {
	return &MockAddressesObj{o}
}

// GCEBetaAddresses is a simplifying adapter for the GCE Addresses.
type GCEBetaAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEBetaAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaAddresses.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaAddresses.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Addresses",
	}

	klog.V(5).Infof("GCEBetaAddresses.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaAddresses.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Addresses.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaAddresses.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Address objects.
func (g *GCEBetaAddresses) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaAddresses.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Addresses",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaAddresses.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.Addresses.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Address
	f := func(l *computebeta.AddressList) error {
		klog.V(5).Infof("GCEBetaAddresses.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaAddresses.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEBetaAddresses) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Address, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaAddresses.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaAddresses.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Addresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Addresses",
	}
	klog.V(5).Infof("GCEBetaAddresses.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaAddresses.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Addresses.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaAddresses.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaAddresses.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Address referenced by key.
func (g *GCEBetaAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaAddresses.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaAddresses.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Addresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Addresses",
	}
	klog.V(5).Infof("GCEBetaAddresses.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaAddresses.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Addresses.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaAddresses.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEBetaAddresses) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaAddresses.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Addresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("beta"),
		Service:   "Addresses",
	}

	klog.V(5).Infof("GCEBetaAddresses.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEBetaAddresses.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Beta.Addresses.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computebeta.Address{}
	f := func(l *computebeta.AddressAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEBetaAddresses.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.Addresses...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaAddresses.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaAddresses.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaAddresses.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AlphaGlobalAddresses is an interface that allows for mocking of GlobalAddresses.
type AlphaGlobalAddresses interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Address, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Address, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Address, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockAlphaGlobalAddresses returns a new mock for GlobalAddresses.
func NewMockAlphaGlobalAddresses(pr ProjectRouter, objs map[meta.Key]*MockGlobalAddressesObj) *MockAlphaGlobalAddresses {
	mock := &MockAlphaGlobalAddresses{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaGlobalAddresses is the mock for GlobalAddresses.
type MockAlphaGlobalAddresses struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalAddressesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaGlobalAddresses, options ...Option) (bool, *computealpha.Address, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockAlphaGlobalAddresses, options ...Option) (bool, []*computealpha.Address, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.Address, m *MockAlphaGlobalAddresses, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaGlobalAddresses, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaGlobalAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalAddresses.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaGlobalAddresses.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaGlobalAddresses %v not found", key),
	}
	klog.V(5).Infof("MockAlphaGlobalAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaGlobalAddresses) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalAddresses.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaGlobalAddresses.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Address
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaGlobalAddresses.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaGlobalAddresses) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Address, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaGlobalAddresses %v exists", key),
		}
		klog.V(5).Infof("MockAlphaGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "addresses")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "addresses", key)

	m.Objects[*key] = &MockGlobalAddressesObj{obj}
	klog.V(5).Infof("MockAlphaGlobalAddresses.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaGlobalAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaGlobalAddresses %v not found", key),
		}
		klog.V(5).Infof("MockAlphaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaGlobalAddresses.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaGlobalAddresses) Obj(o *computealpha.Address) *MockGlobalAddressesObj {
	return &MockGlobalAddressesObj{o}
}

// GCEAlphaGlobalAddresses is a simplifying adapter for the GCE GlobalAddresses.
type GCEAlphaGlobalAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEAlphaGlobalAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalAddresses.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalAddresses.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "GlobalAddresses",
	}

	klog.V(5).Infof("GCEAlphaGlobalAddresses.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalAddresses.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.GlobalAddresses.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaGlobalAddresses.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Address objects.
func (g *GCEAlphaGlobalAddresses) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalAddresses.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "GlobalAddresses",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaGlobalAddresses.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.GlobalAddresses.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Address
	f := func(l *computealpha.AddressList) error {
		klog.V(5).Infof("GCEAlphaGlobalAddresses.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaGlobalAddresses.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaGlobalAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEAlphaGlobalAddresses) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Address, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalAddresses.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalAddresses.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "GlobalAddresses",
	}
	klog.V(5).Infof("GCEAlphaGlobalAddresses.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalAddresses.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.GlobalAddresses.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaGlobalAddresses.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaGlobalAddresses.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Address referenced by key.
func (g *GCEAlphaGlobalAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalAddresses.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalAddresses.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalAddresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "GlobalAddresses",
	}
	klog.V(5).Infof("GCEAlphaGlobalAddresses.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalAddresses.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalAddresses.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// BetaGlobalAddresses is an interface that allows for mocking of GlobalAddresses.
type BetaGlobalAddresses interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Address, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Address, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Address, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockBetaGlobalAddresses returns a new mock for GlobalAddresses.
func NewMockBetaGlobalAddresses(pr ProjectRouter, objs map[meta.Key]*MockGlobalAddressesObj) *MockBetaGlobalAddresses {
	mock := &MockBetaGlobalAddresses{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaGlobalAddresses is the mock for GlobalAddresses.
type MockBetaGlobalAddresses struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalAddressesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaGlobalAddresses, options ...Option) (bool, *computebeta.Address, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaGlobalAddresses, options ...Option) (bool, []*computebeta.Address, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.Address, m *MockBetaGlobalAddresses, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaGlobalAddresses, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaGlobalAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalAddresses.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaGlobalAddresses.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaGlobalAddresses %v not found", key),
	}
	klog.V(5).Infof("MockBetaGlobalAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaGlobalAddresses) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalAddresses.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaGlobalAddresses.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Address
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaGlobalAddresses.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaGlobalAddresses) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Address, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaGlobalAddresses %v exists", key),
		}
		klog.V(5).Infof("MockBetaGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "addresses")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "addresses", key)

	m.Objects[*key] = &MockGlobalAddressesObj{obj}
	klog.V(5).Infof("MockBetaGlobalAddresses.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaGlobalAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaGlobalAddresses %v not found", key),
		}
		klog.V(5).Infof("MockBetaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaGlobalAddresses.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaGlobalAddresses) Obj(o *computebeta.Address) *MockGlobalAddressesObj {
	return &MockGlobalAddressesObj{o}
}

// GCEBetaGlobalAddresses is a simplifying adapter for the GCE GlobalAddresses.
type GCEBetaGlobalAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEBetaGlobalAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalAddresses.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalAddresses.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "GlobalAddresses",
	}

	klog.V(5).Infof("GCEBetaGlobalAddresses.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalAddresses.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.GlobalAddresses.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaGlobalAddresses.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Address objects.
func (g *GCEBetaGlobalAddresses) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalAddresses.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "GlobalAddresses",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaGlobalAddresses.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.GlobalAddresses.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Address
	f := func(l *computebeta.AddressList) error {
		klog.V(5).Infof("GCEBetaGlobalAddresses.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaGlobalAddresses.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaGlobalAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEBetaGlobalAddresses) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Address, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalAddresses.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalAddresses.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "GlobalAddresses",
	}
	klog.V(5).Infof("GCEBetaGlobalAddresses.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalAddresses.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.GlobalAddresses.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaGlobalAddresses.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaGlobalAddresses.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Address referenced by key.
func (g *GCEBetaGlobalAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalAddresses.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalAddresses.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalAddresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "GlobalAddresses",
	}
	klog.V(5).Infof("GCEBetaGlobalAddresses.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalAddresses.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalAddresses.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GlobalAddresses is an interface that allows for mocking of GlobalAddresses.
type GlobalAddresses interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Address, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Address, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Address, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockGlobalAddresses returns a new mock for GlobalAddresses.
func NewMockGlobalAddresses(pr ProjectRouter, objs map[meta.Key]*MockGlobalAddressesObj) *MockGlobalAddresses {
	mock := &MockGlobalAddresses{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockGlobalAddresses is the mock for GlobalAddresses.
type MockGlobalAddresses struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalAddressesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockGlobalAddresses, options ...Option) (bool, *computega.Address, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockGlobalAddresses, options ...Option) (bool, []*computega.Address, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.Address, m *MockGlobalAddresses, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockGlobalAddresses, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockGlobalAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Address, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockGlobalAddresses.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockGlobalAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockGlobalAddresses.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockGlobalAddresses %v not found", key),
	}
	klog.V(5).Infof("MockGlobalAddresses.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockGlobalAddresses) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Address, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockGlobalAddresses.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockGlobalAddresses.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Address
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockGlobalAddresses.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockGlobalAddresses) Insert(ctx context.Context, key *meta.Key, obj *computega.Address, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockGlobalAddresses %v exists", key),
		}
		klog.V(5).Infof("MockGlobalAddresses.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "addresses")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "addresses", key)

	m.Objects[*key] = &MockGlobalAddressesObj{obj}
	klog.V(5).Infof("MockGlobalAddresses.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockGlobalAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockGlobalAddresses %v not found", key),
		}
		klog.V(5).Infof("MockGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockGlobalAddresses.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockGlobalAddresses) Obj(o *computega.Address) *MockGlobalAddressesObj {
	return &MockGlobalAddressesObj{o}
}

// GCEGlobalAddresses is a simplifying adapter for the GCE GlobalAddresses.
type GCEGlobalAddresses struct {
	s *Service
}

// Get the Address named by key.
func (g *GCEGlobalAddresses) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalAddresses.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalAddresses.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "GlobalAddresses",
	}

	klog.V(5).Infof("GCEGlobalAddresses.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalAddresses.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.GlobalAddresses.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEGlobalAddresses.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Address objects.
func (g *GCEGlobalAddresses) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Address, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalAddresses.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "GlobalAddresses",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEGlobalAddresses.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.GlobalAddresses.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Address
	f := func(l *computega.AddressList) error {
		klog.V(5).Infof("GCEGlobalAddresses.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEGlobalAddresses.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEGlobalAddresses.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Address with key of value obj.
func (g *GCEGlobalAddresses) Insert(ctx context.Context, key *meta.Key, obj *computega.Address, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalAddresses.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalAddresses.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalAddresses")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "GlobalAddresses",
	}
	klog.V(5).Infof("GCEGlobalAddresses.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalAddresses.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.GlobalAddresses.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEGlobalAddresses.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEGlobalAddresses.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Address referenced by key.
func (g *GCEGlobalAddresses) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalAddresses.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalAddresses.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalAddresses")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "GlobalAddresses",
	}
	klog.V(5).Infof("GCEGlobalAddresses.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalAddresses.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalAddresses.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEGlobalAddresses.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// BackendServices is an interface that allows for mocking of BackendServices.
type BackendServices interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.BackendService, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.BackendService, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.BackendService, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.BackendService, error)
	AddSignedUrlKey(context.Context, *meta.Key, *computega.SignedUrlKey, ...Option) error
	DeleteSignedUrlKey(context.Context, *meta.Key, string, ...Option) error
	GetHealth(context.Context, *meta.Key, *computega.ResourceGroupReference, ...Option) (*computega.BackendServiceGroupHealth, error)
	Patch(context.Context, *meta.Key, *computega.BackendService, ...Option) error
	SetSecurityPolicy(context.Context, *meta.Key, *computega.SecurityPolicyReference, ...Option) error
	Update(context.Context, *meta.Key, *computega.BackendService, ...Option) error
}

// NewMockBackendServices returns a new mock for BackendServices.
func NewMockBackendServices(pr ProjectRouter, objs map[meta.Key]*MockBackendServicesObj) *MockBackendServices {
	mock := &MockBackendServices{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBackendServices is the mock for BackendServices.
type MockBackendServices struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockBackendServicesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockBackendServices, options ...Option) (bool, *computega.BackendService, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockBackendServices, options ...Option) (bool, []*computega.BackendService, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computega.BackendService, m *MockBackendServices, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockBackendServices, options ...Option) (bool, error)
	AggregatedListHook     func(ctx context.Context, fl *filter.F, m *MockBackendServices, options ...Option) (bool, map[string][]*computega.BackendService, error)
	AddSignedUrlKeyHook    func(context.Context, *meta.Key, *computega.SignedUrlKey, *MockBackendServices, ...Option) error
	DeleteSignedUrlKeyHook func(context.Context, *meta.Key, string, *MockBackendServices, ...Option) error
	GetHealthHook          func(context.Context, *meta.Key, *computega.ResourceGroupReference, *MockBackendServices, ...Option) (*computega.BackendServiceGroupHealth, error)
	PatchHook              func(context.Context, *meta.Key, *computega.BackendService, *MockBackendServices, ...Option) error
	SetSecurityPolicyHook  func(context.Context, *meta.Key, *computega.SecurityPolicyReference, *MockBackendServices, ...Option) error
	UpdateHook             func(context.Context, *meta.Key, *computega.BackendService, *MockBackendServices, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBackendServices.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockBackendServices.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBackendServices %v not found", key),
	}
	klog.V(5).Infof("MockBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBackendServices) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBackendServices.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBackendServices.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.BackendService
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockBackendServices.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computega.BackendService, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBackendServices %v exists", key),
		}
		klog.V(5).Infof("MockBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "backendServices")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "backendServices", key)

	m.Objects[*key] = &MockBackendServicesObj{obj}
	klog.V(5).Infof("MockBackendServices.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBackendServices.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBackendServices %v not found", key),
		}
		klog.V(5).Infof("MockBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBackendServices.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockBackendServices) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.BackendService, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBackendServices.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockBackendServices.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computega.BackendService{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToGA().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockBackendServices.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToGA())
	}
	klog.V(5).Infof("MockBackendServices.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockBackendServices) Obj(o *computega.BackendService) *MockBackendServicesObj {
	return &MockBackendServicesObj{o}
}

// AddSignedUrlKey is a mock for the corresponding method.
func (m *MockBackendServices) AddSignedUrlKey(ctx context.Context, key *meta.Key, arg0 *computega.SignedUrlKey, options ...Option) error {
	if m.AddSignedUrlKeyHook != nil {
		return m.AddSignedUrlKeyHook(ctx, key, arg0, m)
	}
	return nil
}

// DeleteSignedUrlKey is a mock for the corresponding method.
func (m *MockBackendServices) DeleteSignedUrlKey(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	if m.DeleteSignedUrlKeyHook != nil {
		return m.DeleteSignedUrlKeyHook(ctx, key, arg0, m)
	}
	return nil
}

// GetHealth is a mock for the corresponding method.
func (m *MockBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computega.ResourceGroupReference, options ...Option) (*computega.BackendServiceGroupHealth, error) {
	if m.GetHealthHook != nil {
		return m.GetHealthHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("GetHealthHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSecurityPolicy is a mock for the corresponding method.
func (m *MockBackendServices) SetSecurityPolicy(ctx context.Context, key *meta.Key, arg0 *computega.SecurityPolicyReference, options ...Option) error {
	if m.SetSecurityPolicyHook != nil {
		return m.SetSecurityPolicyHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBackendServices is a simplifying adapter for the GCE BackendServices.
type GCEBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}

	klog.V(5).Infof("GCEBackendServices.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.BackendServices.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBackendServices.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all BackendService objects.
func (g *GCEBackendServices) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBackendServices.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.BackendServices.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.BackendService
	f := func(l *computega.BackendServiceList) error {
		klog.V(5).Infof("GCEBackendServices.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBackendServices.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computega.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.BackendServices.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBackendServices.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBackendServices.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the BackendService referenced by key.
func (g *GCEBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.BackendServices.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBackendServices.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEBackendServices) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}

	klog.V(5).Infof("GCEBackendServices.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEBackendServices.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.GA.BackendServices.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computega.BackendService{}
	f := func(l *computega.BackendServiceAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEBackendServices.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.BackendServices...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBackendServices.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBackendServices.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AddSignedUrlKey is a method on GCEBackendServices.
func (g *GCEBackendServices) AddSignedUrlKey(ctx context.Context, key *meta.Key, arg0 *computega.SignedUrlKey, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.AddSignedUrlKey(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.AddSignedUrlKey(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddSignedUrlKey",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.AddSignedUrlKey(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.AddSignedUrlKey(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.BackendServices.AddSignedUrlKey(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.AddSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBackendServices.AddSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DeleteSignedUrlKey is a method on GCEBackendServices.
func (g *GCEBackendServices) DeleteSignedUrlKey(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.DeleteSignedUrlKey(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.DeleteSignedUrlKey(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DeleteSignedUrlKey",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.DeleteSignedUrlKey(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.DeleteSignedUrlKey(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.BackendServices.DeleteSignedUrlKey(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.DeleteSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBackendServices.DeleteSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// GetHealth is a method on GCEBackendServices.
func (g *GCEBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computega.ResourceGroupReference, options ...Option) (*computega.BackendServiceGroupHealth, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.GetHealth(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.GetHealth(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetHealth",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.GetHealth(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.GetHealth(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.BackendServices.GetHealth(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBackendServices.GetHealth(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEBackendServices.
func (g *GCEBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.BackendServices.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSecurityPolicy is a method on GCEBackendServices.
func (g *GCEBackendServices) SetSecurityPolicy(ctx context.Context, key *meta.Key, arg0 *computega.SecurityPolicyReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.SetSecurityPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.SetSecurityPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSecurityPolicy",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.SetSecurityPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.SetSecurityPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.BackendServices.SetSecurityPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.SetSecurityPolicy(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBackendServices.SetSecurityPolicy(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEBackendServices.
func (g *GCEBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBackendServices.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBackendServices.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBackendServices.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBackendServices.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.BackendServices.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaBackendServices is an interface that allows for mocking of BackendServices.
type BetaBackendServices interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.BackendService, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.BackendService, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.BackendService, error)
	AddSignedUrlKey(context.Context, *meta.Key, *computebeta.SignedUrlKey, ...Option) error
	DeleteSignedUrlKey(context.Context, *meta.Key, string, ...Option) error
	Patch(context.Context, *meta.Key, *computebeta.BackendService, ...Option) error
	SetSecurityPolicy(context.Context, *meta.Key, *computebeta.SecurityPolicyReference, ...Option) error
	Update(context.Context, *meta.Key, *computebeta.BackendService, ...Option) error
}

// NewMockBetaBackendServices returns a new mock for BackendServices.
func NewMockBetaBackendServices(pr ProjectRouter, objs map[meta.Key]*MockBackendServicesObj) *MockBetaBackendServices {
	mock := &MockBetaBackendServices{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaBackendServices is the mock for BackendServices.
type MockBetaBackendServices struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockBackendServicesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockBetaBackendServices, options ...Option) (bool, *computebeta.BackendService, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockBetaBackendServices, options ...Option) (bool, []*computebeta.BackendService, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, m *MockBetaBackendServices, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockBetaBackendServices, options ...Option) (bool, error)
	AggregatedListHook     func(ctx context.Context, fl *filter.F, m *MockBetaBackendServices, options ...Option) (bool, map[string][]*computebeta.BackendService, error)
	AddSignedUrlKeyHook    func(context.Context, *meta.Key, *computebeta.SignedUrlKey, *MockBetaBackendServices, ...Option) error
	DeleteSignedUrlKeyHook func(context.Context, *meta.Key, string, *MockBetaBackendServices, ...Option) error
	PatchHook              func(context.Context, *meta.Key, *computebeta.BackendService, *MockBetaBackendServices, ...Option) error
	SetSecurityPolicyHook  func(context.Context, *meta.Key, *computebeta.SecurityPolicyReference, *MockBetaBackendServices, ...Option) error
	UpdateHook             func(context.Context, *meta.Key, *computebeta.BackendService, *MockBetaBackendServices, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaBackendServices.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaBackendServices.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaBackendServices %v not found", key),
	}
	klog.V(5).Infof("MockBetaBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaBackendServices) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaBackendServices.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaBackendServices.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.BackendService
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaBackendServices.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaBackendServices %v exists", key),
		}
		klog.V(5).Infof("MockBetaBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "backendServices")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "backendServices", key)

	m.Objects[*key] = &MockBackendServicesObj{obj}
	klog.V(5).Infof("MockBetaBackendServices.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaBackendServices %v not found", key),
		}
		klog.V(5).Infof("MockBetaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaBackendServices.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockBetaBackendServices) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.BackendService, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaBackendServices.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockBetaBackendServices.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computebeta.BackendService{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToBeta().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockBetaBackendServices.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToBeta())
	}
	klog.V(5).Infof("MockBetaBackendServices.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaBackendServices) Obj(o *computebeta.BackendService) *MockBackendServicesObj {
	return &MockBackendServicesObj{o}
}

// AddSignedUrlKey is a mock for the corresponding method.
func (m *MockBetaBackendServices) AddSignedUrlKey(ctx context.Context, key *meta.Key, arg0 *computebeta.SignedUrlKey, options ...Option) error {
	if m.AddSignedUrlKeyHook != nil {
		return m.AddSignedUrlKeyHook(ctx, key, arg0, m)
	}
	return nil
}

// DeleteSignedUrlKey is a mock for the corresponding method.
func (m *MockBetaBackendServices) DeleteSignedUrlKey(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	if m.DeleteSignedUrlKeyHook != nil {
		return m.DeleteSignedUrlKeyHook(ctx, key, arg0, m)
	}
	return nil
}

// Patch is a mock for the corresponding method.
func (m *MockBetaBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSecurityPolicy is a mock for the corresponding method.
func (m *MockBetaBackendServices) SetSecurityPolicy(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicyReference, options ...Option) error {
	if m.SetSecurityPolicyHook != nil {
		return m.SetSecurityPolicyHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockBetaBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaBackendServices is a simplifying adapter for the GCE BackendServices.
type GCEBetaBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEBetaBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}

	klog.V(5).Infof("GCEBetaBackendServices.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.BackendServices.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaBackendServices.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all BackendService objects.
func (g *GCEBetaBackendServices) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaBackendServices.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.BackendServices.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.BackendService
	f := func(l *computebeta.BackendServiceList) error {
		klog.V(5).Infof("GCEBetaBackendServices.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaBackendServices.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEBetaBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.BackendServices.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaBackendServices.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the BackendService referenced by key.
func (g *GCEBetaBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.BackendServices.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEBetaBackendServices) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}

	klog.V(5).Infof("GCEBetaBackendServices.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEBetaBackendServices.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Beta.BackendServices.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computebeta.BackendService{}
	f := func(l *computebeta.BackendServiceAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEBetaBackendServices.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.BackendServices...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaBackendServices.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaBackendServices.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AddSignedUrlKey is a method on GCEBetaBackendServices.
func (g *GCEBetaBackendServices) AddSignedUrlKey(ctx context.Context, key *meta.Key, arg0 *computebeta.SignedUrlKey, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.AddSignedUrlKey(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.AddSignedUrlKey(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddSignedUrlKey",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.AddSignedUrlKey(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.AddSignedUrlKey(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.BackendServices.AddSignedUrlKey(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.AddSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaBackendServices.AddSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DeleteSignedUrlKey is a method on GCEBetaBackendServices.
func (g *GCEBetaBackendServices) DeleteSignedUrlKey(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.DeleteSignedUrlKey(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.DeleteSignedUrlKey(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DeleteSignedUrlKey",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.DeleteSignedUrlKey(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.DeleteSignedUrlKey(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.BackendServices.DeleteSignedUrlKey(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.DeleteSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaBackendServices.DeleteSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Patch is a method on GCEBetaBackendServices.
func (g *GCEBetaBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.BackendServices.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSecurityPolicy is a method on GCEBetaBackendServices.
func (g *GCEBetaBackendServices) SetSecurityPolicy(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicyReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.SetSecurityPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.SetSecurityPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSecurityPolicy",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.SetSecurityPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.SetSecurityPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.BackendServices.SetSecurityPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.SetSecurityPolicy(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaBackendServices.SetSecurityPolicy(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaBackendServices.
func (g *GCEBetaBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaBackendServices.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaBackendServices.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEBetaBackendServices.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaBackendServices.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.BackendServices.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaBackendServices is an interface that allows for mocking of BackendServices.
type AlphaBackendServices interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.BackendService, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.BackendService, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.BackendService, error)
	AddSignedUrlKey(context.Context, *meta.Key, *computealpha.SignedUrlKey, ...Option) error
	DeleteSignedUrlKey(context.Context, *meta.Key, string, ...Option) error
	Patch(context.Context, *meta.Key, *computealpha.BackendService, ...Option) error
	SetSecurityPolicy(context.Context, *meta.Key, *computealpha.SecurityPolicyReference, ...Option) error
	Update(context.Context, *meta.Key, *computealpha.BackendService, ...Option) error
}

// NewMockAlphaBackendServices returns a new mock for BackendServices.
func NewMockAlphaBackendServices(pr ProjectRouter, objs map[meta.Key]*MockBackendServicesObj) *MockAlphaBackendServices {
	mock := &MockAlphaBackendServices{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaBackendServices is the mock for BackendServices.
type MockAlphaBackendServices struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockBackendServicesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaBackendServices, options ...Option) (bool, *computealpha.BackendService, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockAlphaBackendServices, options ...Option) (bool, []*computealpha.BackendService, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, m *MockAlphaBackendServices, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaBackendServices, options ...Option) (bool, error)
	AggregatedListHook     func(ctx context.Context, fl *filter.F, m *MockAlphaBackendServices, options ...Option) (bool, map[string][]*computealpha.BackendService, error)
	AddSignedUrlKeyHook    func(context.Context, *meta.Key, *computealpha.SignedUrlKey, *MockAlphaBackendServices, ...Option) error
	DeleteSignedUrlKeyHook func(context.Context, *meta.Key, string, *MockAlphaBackendServices, ...Option) error
	PatchHook              func(context.Context, *meta.Key, *computealpha.BackendService, *MockAlphaBackendServices, ...Option) error
	SetSecurityPolicyHook  func(context.Context, *meta.Key, *computealpha.SecurityPolicyReference, *MockAlphaBackendServices, ...Option) error
	UpdateHook             func(context.Context, *meta.Key, *computealpha.BackendService, *MockAlphaBackendServices, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaBackendServices.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaBackendServices.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaBackendServices %v not found", key),
	}
	klog.V(5).Infof("MockAlphaBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaBackendServices) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaBackendServices.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaBackendServices.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.BackendService
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaBackendServices.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaBackendServices %v exists", key),
		}
		klog.V(5).Infof("MockAlphaBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "backendServices")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "backendServices", key)

	m.Objects[*key] = &MockBackendServicesObj{obj}
	klog.V(5).Infof("MockAlphaBackendServices.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaBackendServices %v not found", key),
		}
		klog.V(5).Infof("MockAlphaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaBackendServices.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockAlphaBackendServices) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.BackendService, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaBackendServices.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockAlphaBackendServices.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computealpha.BackendService{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToAlpha().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockAlphaBackendServices.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToAlpha())
	}
	klog.V(5).Infof("MockAlphaBackendServices.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaBackendServices) Obj(o *computealpha.BackendService) *MockBackendServicesObj {
	return &MockBackendServicesObj{o}
}

// AddSignedUrlKey is a mock for the corresponding method.
func (m *MockAlphaBackendServices) AddSignedUrlKey(ctx context.Context, key *meta.Key, arg0 *computealpha.SignedUrlKey, options ...Option) error {
	if m.AddSignedUrlKeyHook != nil {
		return m.AddSignedUrlKeyHook(ctx, key, arg0, m)
	}
	return nil
}

// DeleteSignedUrlKey is a mock for the corresponding method.
func (m *MockAlphaBackendServices) DeleteSignedUrlKey(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	if m.DeleteSignedUrlKeyHook != nil {
		return m.DeleteSignedUrlKeyHook(ctx, key, arg0, m)
	}
	return nil
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSecurityPolicy is a mock for the corresponding method.
func (m *MockAlphaBackendServices) SetSecurityPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.SecurityPolicyReference, options ...Option) error {
	if m.SetSecurityPolicyHook != nil {
		return m.SetSecurityPolicyHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockAlphaBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaBackendServices is a simplifying adapter for the GCE BackendServices.
type GCEAlphaBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEAlphaBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}

	klog.V(5).Infof("GCEAlphaBackendServices.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.BackendServices.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaBackendServices.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all BackendService objects.
func (g *GCEAlphaBackendServices) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaBackendServices.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.BackendServices.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.BackendService
	f := func(l *computealpha.BackendServiceList) error {
		klog.V(5).Infof("GCEAlphaBackendServices.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaBackendServices.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEAlphaBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.BackendServices.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaBackendServices.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the BackendService referenced by key.
func (g *GCEAlphaBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.BackendServices.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaBackendServices.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEAlphaBackendServices) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}

	klog.V(5).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Alpha.BackendServices.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computealpha.BackendService{}
	f := func(l *computealpha.BackendServiceAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.BackendServices...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaBackendServices.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AddSignedUrlKey is a method on GCEAlphaBackendServices.
func (g *GCEAlphaBackendServices) AddSignedUrlKey(ctx context.Context, key *meta.Key, arg0 *computealpha.SignedUrlKey, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.AddSignedUrlKey(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.AddSignedUrlKey(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddSignedUrlKey",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.AddSignedUrlKey(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.AddSignedUrlKey(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.BackendServices.AddSignedUrlKey(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.AddSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaBackendServices.AddSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DeleteSignedUrlKey is a method on GCEAlphaBackendServices.
func (g *GCEAlphaBackendServices) DeleteSignedUrlKey(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.DeleteSignedUrlKey(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.DeleteSignedUrlKey(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DeleteSignedUrlKey",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.DeleteSignedUrlKey(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.DeleteSignedUrlKey(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.BackendServices.DeleteSignedUrlKey(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.DeleteSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaBackendServices.DeleteSignedUrlKey(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Patch is a method on GCEAlphaBackendServices.
func (g *GCEAlphaBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.BackendServices.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSecurityPolicy is a method on GCEAlphaBackendServices.
func (g *GCEAlphaBackendServices) SetSecurityPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.SecurityPolicyReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.SetSecurityPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.SetSecurityPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSecurityPolicy",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.SetSecurityPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.SetSecurityPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.BackendServices.SetSecurityPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.SetSecurityPolicy(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaBackendServices.SetSecurityPolicy(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaBackendServices.
func (g *GCEAlphaBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaBackendServices.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaBackendServices.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "BackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "BackendServices",
	}
	klog.V(5).Infof("GCEAlphaBackendServices.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaBackendServices.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.BackendServices.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RegionBackendServices is an interface that allows for mocking of RegionBackendServices.
type RegionBackendServices interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.BackendService, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.BackendService, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.BackendService, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	GetHealth(context.Context, *meta.Key, *computega.ResourceGroupReference, ...Option) (*computega.BackendServiceGroupHealth, error)
	Patch(context.Context, *meta.Key, *computega.BackendService, ...Option) error
	Update(context.Context, *meta.Key, *computega.BackendService, ...Option) error
}

// NewMockRegionBackendServices returns a new mock for RegionBackendServices.
func NewMockRegionBackendServices(pr ProjectRouter, objs map[meta.Key]*MockRegionBackendServicesObj) *MockRegionBackendServices {
	mock := &MockRegionBackendServices{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionBackendServices is the mock for RegionBackendServices.
type MockRegionBackendServices struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionBackendServicesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockRegionBackendServices, options ...Option) (bool, *computega.BackendService, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockRegionBackendServices, options ...Option) (bool, []*computega.BackendService, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computega.BackendService, m *MockRegionBackendServices, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockRegionBackendServices, options ...Option) (bool, error)
	GetHealthHook func(context.Context, *meta.Key, *computega.ResourceGroupReference, *MockRegionBackendServices, ...Option) (*computega.BackendServiceGroupHealth, error)
	PatchHook     func(context.Context, *meta.Key, *computega.BackendService, *MockRegionBackendServices, ...Option) error
	UpdateHook    func(context.Context, *meta.Key, *computega.BackendService, *MockRegionBackendServices, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionBackendServices.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionBackendServices.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionBackendServices %v not found", key),
	}
	klog.V(5).Infof("MockRegionBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionBackendServices) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionBackendServices.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionBackendServices.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.BackendService
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionBackendServices.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computega.BackendService, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionBackendServices %v exists", key),
		}
		klog.V(5).Infof("MockRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "backendServices")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "backendServices", key)

	m.Objects[*key] = &MockRegionBackendServicesObj{obj}
	klog.V(5).Infof("MockRegionBackendServices.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionBackendServices %v not found", key),
		}
		klog.V(5).Infof("MockRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionBackendServices.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionBackendServices) Obj(o *computega.BackendService) *MockRegionBackendServicesObj {
	return &MockRegionBackendServicesObj{o}
}

// GetHealth is a mock for the corresponding method.
func (m *MockRegionBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computega.ResourceGroupReference, options ...Option) (*computega.BackendServiceGroupHealth, error) {
	if m.GetHealthHook != nil {
		return m.GetHealthHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("GetHealthHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockRegionBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockRegionBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCERegionBackendServices is a simplifying adapter for the GCE RegionBackendServices.
type GCERegionBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCERegionBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionBackendServices.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}

	klog.V(5).Infof("GCERegionBackendServices.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionBackendServices.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionBackendServices.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all BackendService objects.
func (g *GCERegionBackendServices) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionBackendServices.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionBackendServices.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.BackendService
	f := func(l *computega.BackendServiceList) error {
		klog.V(5).Infof("GCERegionBackendServices.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionBackendServices.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCERegionBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computega.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionBackendServices.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCERegionBackendServices.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionBackendServices.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionBackendServices.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the BackendService referenced by key.
func (g *GCERegionBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionBackendServices.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCERegionBackendServices.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionBackendServices.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GetHealth is a method on GCERegionBackendServices.
func (g *GCERegionBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computega.ResourceGroupReference, options ...Option) (*computega.BackendServiceGroupHealth, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.GetHealth(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionBackendServices.GetHealth(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetHealth",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCERegionBackendServices.GetHealth(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionBackendServices.GetHealth(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionBackendServices.GetHealth(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCERegionBackendServices.GetHealth(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCERegionBackendServices.
func (g *GCERegionBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionBackendServices.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCERegionBackendServices.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionBackendServices.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCERegionBackendServices.
func (g *GCERegionBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computega.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionBackendServices.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionBackendServices.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCERegionBackendServices.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionBackendServices.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionBackendServices.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaRegionBackendServices is an interface that allows for mocking of RegionBackendServices.
type AlphaRegionBackendServices interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.BackendService, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.BackendService, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	GetHealth(context.Context, *meta.Key, *computealpha.ResourceGroupReference, ...Option) (*computealpha.BackendServiceGroupHealth, error)
	Patch(context.Context, *meta.Key, *computealpha.BackendService, ...Option) error
	Update(context.Context, *meta.Key, *computealpha.BackendService, ...Option) error
}

// NewMockAlphaRegionBackendServices returns a new mock for RegionBackendServices.
func NewMockAlphaRegionBackendServices(pr ProjectRouter, objs map[meta.Key]*MockRegionBackendServicesObj) *MockAlphaRegionBackendServices {
	mock := &MockAlphaRegionBackendServices{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionBackendServices is the mock for RegionBackendServices.
type MockAlphaRegionBackendServices struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionBackendServicesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockAlphaRegionBackendServices, options ...Option) (bool, *computealpha.BackendService, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionBackendServices, options ...Option) (bool, []*computealpha.BackendService, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, m *MockAlphaRegionBackendServices, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockAlphaRegionBackendServices, options ...Option) (bool, error)
	GetHealthHook func(context.Context, *meta.Key, *computealpha.ResourceGroupReference, *MockAlphaRegionBackendServices, ...Option) (*computealpha.BackendServiceGroupHealth, error)
	PatchHook     func(context.Context, *meta.Key, *computealpha.BackendService, *MockAlphaRegionBackendServices, ...Option) error
	UpdateHook    func(context.Context, *meta.Key, *computealpha.BackendService, *MockAlphaRegionBackendServices, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionBackendServices.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionBackendServices.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionBackendServices %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionBackendServices) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionBackendServices.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionBackendServices.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.BackendService
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionBackendServices.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionBackendServices %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "backendServices")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "backendServices", key)

	m.Objects[*key] = &MockRegionBackendServicesObj{obj}
	klog.V(5).Infof("MockAlphaRegionBackendServices.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionBackendServices %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionBackendServices.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionBackendServices) Obj(o *computealpha.BackendService) *MockRegionBackendServicesObj {
	return &MockRegionBackendServicesObj{o}
}

// GetHealth is a mock for the corresponding method.
func (m *MockAlphaRegionBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computealpha.ResourceGroupReference, options ...Option) (*computealpha.BackendServiceGroupHealth, error) {
	if m.GetHealthHook != nil {
		return m.GetHealthHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("GetHealthHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaRegionBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockAlphaRegionBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaRegionBackendServices is a simplifying adapter for the GCE RegionBackendServices.
type GCEAlphaRegionBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEAlphaRegionBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionBackendServices.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}

	klog.V(5).Infof("GCEAlphaRegionBackendServices.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionBackendServices.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionBackendServices.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all BackendService objects.
func (g *GCEAlphaRegionBackendServices) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionBackendServices.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionBackendServices.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.BackendService
	f := func(l *computealpha.BackendServiceList) error {
		klog.V(5).Infof("GCEAlphaRegionBackendServices.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEAlphaRegionBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computealpha.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionBackendServices.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionBackendServices.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionBackendServices.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the BackendService referenced by key.
func (g *GCEAlphaRegionBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionBackendServices.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionBackendServices.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GetHealth is a method on GCEAlphaRegionBackendServices.
func (g *GCEAlphaRegionBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computealpha.ResourceGroupReference, options ...Option) (*computealpha.BackendServiceGroupHealth, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.GetHealth(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionBackendServices.GetHealth(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetHealth",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEAlphaRegionBackendServices.GetHealth(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.GetHealth(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionBackendServices.GetHealth(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRegionBackendServices.GetHealth(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEAlphaRegionBackendServices.
func (g *GCEAlphaRegionBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionBackendServices.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionBackendServices.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaRegionBackendServices.
func (g *GCEAlphaRegionBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionBackendServices.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEAlphaRegionBackendServices.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionBackendServices.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionBackendServices.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaRegionBackendServices is an interface that allows for mocking of RegionBackendServices.
type BetaRegionBackendServices interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.BackendService, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.BackendService, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	GetHealth(context.Context, *meta.Key, *computebeta.ResourceGroupReference, ...Option) (*computebeta.BackendServiceGroupHealth, error)
	Patch(context.Context, *meta.Key, *computebeta.BackendService, ...Option) error
	Update(context.Context, *meta.Key, *computebeta.BackendService, ...Option) error
}

// NewMockBetaRegionBackendServices returns a new mock for RegionBackendServices.
func NewMockBetaRegionBackendServices(pr ProjectRouter, objs map[meta.Key]*MockRegionBackendServicesObj) *MockBetaRegionBackendServices {
	mock := &MockBetaRegionBackendServices{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRegionBackendServices is the mock for RegionBackendServices.
type MockBetaRegionBackendServices struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionBackendServicesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockBetaRegionBackendServices, options ...Option) (bool, *computebeta.BackendService, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockBetaRegionBackendServices, options ...Option) (bool, []*computebeta.BackendService, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, m *MockBetaRegionBackendServices, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockBetaRegionBackendServices, options ...Option) (bool, error)
	GetHealthHook func(context.Context, *meta.Key, *computebeta.ResourceGroupReference, *MockBetaRegionBackendServices, ...Option) (*computebeta.BackendServiceGroupHealth, error)
	PatchHook     func(context.Context, *meta.Key, *computebeta.BackendService, *MockBetaRegionBackendServices, ...Option) error
	UpdateHook    func(context.Context, *meta.Key, *computebeta.BackendService, *MockBetaRegionBackendServices, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRegionBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.BackendService, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionBackendServices.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRegionBackendServices.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRegionBackendServices %v not found", key),
	}
	klog.V(5).Infof("MockBetaRegionBackendServices.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRegionBackendServices) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.BackendService, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionBackendServices.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRegionBackendServices.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.BackendService
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRegionBackendServices.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRegionBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRegionBackendServices %v exists", key),
		}
		klog.V(5).Infof("MockBetaRegionBackendServices.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "backendServices")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "backendServices", key)

	m.Objects[*key] = &MockRegionBackendServicesObj{obj}
	klog.V(5).Infof("MockBetaRegionBackendServices.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRegionBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRegionBackendServices %v not found", key),
		}
		klog.V(5).Infof("MockBetaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRegionBackendServices.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRegionBackendServices) Obj(o *computebeta.BackendService) *MockRegionBackendServicesObj {
	return &MockRegionBackendServicesObj{o}
}

// GetHealth is a mock for the corresponding method.
func (m *MockBetaRegionBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computebeta.ResourceGroupReference, options ...Option) (*computebeta.BackendServiceGroupHealth, error) {
	if m.GetHealthHook != nil {
		return m.GetHealthHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("GetHealthHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockBetaRegionBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockBetaRegionBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaRegionBackendServices is a simplifying adapter for the GCE RegionBackendServices.
type GCEBetaRegionBackendServices struct {
	s *Service
}

// Get the BackendService named by key.
func (g *GCEBetaRegionBackendServices) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionBackendServices.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}

	klog.V(5).Infof("GCEBetaRegionBackendServices.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionBackendServices.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRegionBackendServices.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all BackendService objects.
func (g *GCEBetaRegionBackendServices) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.BackendService, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRegionBackendServices.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.RegionBackendServices.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.BackendService
	f := func(l *computebeta.BackendServiceList) error {
		klog.V(5).Infof("GCEBetaRegionBackendServices.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRegionBackendServices.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRegionBackendServices.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert BackendService with key of value obj.
func (g *GCEBetaRegionBackendServices) Insert(ctx context.Context, key *meta.Key, obj *computebeta.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionBackendServices.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEBetaRegionBackendServices.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.RegionBackendServices.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionBackendServices.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the BackendService referenced by key.
func (g *GCEBetaRegionBackendServices) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionBackendServices.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEBetaRegionBackendServices.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionBackendServices.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionBackendServices.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GetHealth is a method on GCEBetaRegionBackendServices.
func (g *GCEBetaRegionBackendServices) GetHealth(ctx context.Context, key *meta.Key, arg0 *computebeta.ResourceGroupReference, options ...Option) (*computebeta.BackendServiceGroupHealth, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.GetHealth(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionBackendServices.GetHealth(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetHealth",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEBetaRegionBackendServices.GetHealth(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.GetHealth(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionBackendServices.GetHealth(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaRegionBackendServices.GetHealth(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEBetaRegionBackendServices.
func (g *GCEBetaRegionBackendServices) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionBackendServices.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEBetaRegionBackendServices.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionBackendServices.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionBackendServices.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaRegionBackendServices.
func (g *GCEBetaRegionBackendServices) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.BackendService, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionBackendServices.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionBackendServices.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionBackendServices")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "RegionBackendServices",
	}
	klog.V(5).Infof("GCEBetaRegionBackendServices.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionBackendServices.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionBackendServices.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionBackendServices.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Disks is an interface that allows for mocking of Disks.
type Disks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Disk, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.Disk, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Disk, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Resize(context.Context, *meta.Key, *computega.DisksResizeRequest, ...Option) error
}

// NewMockDisks returns a new mock for Disks.
func NewMockDisks(pr ProjectRouter, objs map[meta.Key]*MockDisksObj) *MockDisks {
	mock := &MockDisks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockDisks is the mock for Disks.
type MockDisks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockDisksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockDisks, options ...Option) (bool, *computega.Disk, error)
	ListHook   func(ctx context.Context, zone string, fl *filter.F, m *MockDisks, options ...Option) (bool, []*computega.Disk, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.Disk, m *MockDisks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockDisks, options ...Option) (bool, error)
	ResizeHook func(context.Context, *meta.Key, *computega.DisksResizeRequest, *MockDisks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockDisks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Disk, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockDisks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockDisks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockDisks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockDisks %v not found", key),
	}
	klog.V(5).Infof("MockDisks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockDisks) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.Disk, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockDisks.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockDisks.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Disk
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockDisks.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockDisks) Insert(ctx context.Context, key *meta.Key, obj *computega.Disk, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockDisks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockDisks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockDisks %v exists", key),
		}
		klog.V(5).Infof("MockDisks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "disks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "disks", key)

	m.Objects[*key] = &MockDisksObj{obj}
	klog.V(5).Infof("MockDisks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockDisks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockDisks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockDisks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockDisks %v not found", key),
		}
		klog.V(5).Infof("MockDisks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockDisks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockDisks) Obj(o *computega.Disk) *MockDisksObj {
	return &MockDisksObj{o}
}

// Resize is a mock for the corresponding method.
func (m *MockDisks) Resize(ctx context.Context, key *meta.Key, arg0 *computega.DisksResizeRequest, options ...Option) error {
	if m.ResizeHook != nil {
		return m.ResizeHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEDisks is a simplifying adapter for the GCE Disks.
type GCEDisks struct {
	s *Service
}

// Get the Disk named by key.
func (g *GCEDisks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Disk, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEDisks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEDisks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Disks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Disks",
	}

	klog.V(5).Infof("GCEDisks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEDisks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Disks.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEDisks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Disk objects.
func (g *GCEDisks) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.Disk, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEDisks.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Disks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Disks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEDisks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.GA.Disks.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Disk
	f := func(l *computega.DiskList) error {
		klog.V(5).Infof("GCEDisks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEDisks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEDisks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEDisks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Disk with key of value obj.
func (g *GCEDisks) Insert(ctx context.Context, key *meta.Key, obj *computega.Disk, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEDisks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEDisks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Disks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Disks",
	}
	klog.V(5).Infof("GCEDisks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEDisks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Disks.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEDisks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEDisks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Disk referenced by key.
func (g *GCEDisks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEDisks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEDisks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Disks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Disks",
	}
	klog.V(5).Infof("GCEDisks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEDisks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Disks.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEDisks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEDisks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Resize is a method on GCEDisks.
func (g *GCEDisks) Resize(ctx context.Context, key *meta.Key, arg0 *computega.DisksResizeRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEDisks.Resize(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEDisks.Resize(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Disks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Resize",
		Version:   meta.Version("ga"),
		Service:   "Disks",
	}
	klog.V(5).Infof("GCEDisks.Resize(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEDisks.Resize(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Disks.Resize(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEDisks.Resize(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEDisks.Resize(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RegionDisks is an interface that allows for mocking of RegionDisks.
type RegionDisks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Disk, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Disk, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Disk, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Resize(context.Context, *meta.Key, *computega.RegionDisksResizeRequest, ...Option) error
}

// NewMockRegionDisks returns a new mock for RegionDisks.
func NewMockRegionDisks(pr ProjectRouter, objs map[meta.Key]*MockRegionDisksObj) *MockRegionDisks {
	mock := &MockRegionDisks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionDisks is the mock for RegionDisks.
type MockRegionDisks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionDisksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockRegionDisks, options ...Option) (bool, *computega.Disk, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockRegionDisks, options ...Option) (bool, []*computega.Disk, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.Disk, m *MockRegionDisks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockRegionDisks, options ...Option) (bool, error)
	ResizeHook func(context.Context, *meta.Key, *computega.RegionDisksResizeRequest, *MockRegionDisks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionDisks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Disk, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionDisks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionDisks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionDisks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionDisks %v not found", key),
	}
	klog.V(5).Infof("MockRegionDisks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionDisks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Disk, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionDisks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionDisks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Disk
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionDisks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionDisks) Insert(ctx context.Context, key *meta.Key, obj *computega.Disk, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionDisks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionDisks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionDisks %v exists", key),
		}
		klog.V(5).Infof("MockRegionDisks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "disks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "disks", key)

	m.Objects[*key] = &MockRegionDisksObj{obj}
	klog.V(5).Infof("MockRegionDisks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionDisks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionDisks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionDisks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionDisks %v not found", key),
		}
		klog.V(5).Infof("MockRegionDisks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionDisks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionDisks) Obj(o *computega.Disk) *MockRegionDisksObj {
	return &MockRegionDisksObj{o}
}

// Resize is a mock for the corresponding method.
func (m *MockRegionDisks) Resize(ctx context.Context, key *meta.Key, arg0 *computega.RegionDisksResizeRequest, options ...Option) error {
	if m.ResizeHook != nil {
		return m.ResizeHook(ctx, key, arg0, m)
	}
	return nil
}

// GCERegionDisks is a simplifying adapter for the GCE RegionDisks.
type GCERegionDisks struct {
	s *Service
}

// Get the Disk named by key.
func (g *GCERegionDisks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Disk, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionDisks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionDisks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionDisks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionDisks",
	}

	klog.V(5).Infof("GCERegionDisks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionDisks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionDisks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionDisks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Disk objects.
func (g *GCERegionDisks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Disk, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionDisks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionDisks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionDisks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionDisks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionDisks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Disk
	f := func(l *computega.DiskList) error {
		klog.V(5).Infof("GCERegionDisks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionDisks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionDisks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionDisks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Disk with key of value obj.
func (g *GCERegionDisks) Insert(ctx context.Context, key *meta.Key, obj *computega.Disk, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionDisks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionDisks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionDisks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionDisks",
	}
	klog.V(5).Infof("GCERegionDisks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionDisks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionDisks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionDisks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionDisks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Disk referenced by key.
func (g *GCERegionDisks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionDisks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionDisks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionDisks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionDisks",
	}
	klog.V(5).Infof("GCERegionDisks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionDisks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionDisks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionDisks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionDisks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Resize is a method on GCERegionDisks.
func (g *GCERegionDisks) Resize(ctx context.Context, key *meta.Key, arg0 *computega.RegionDisksResizeRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionDisks.Resize(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionDisks.Resize(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionDisks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Resize",
		Version:   meta.Version("ga"),
		Service:   "RegionDisks",
	}
	klog.V(5).Infof("GCERegionDisks.Resize(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionDisks.Resize(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionDisks.Resize(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionDisks.Resize(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionDisks.Resize(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaFirewalls is an interface that allows for mocking of Firewalls.
type AlphaFirewalls interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Firewall, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Firewall, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Firewall, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computealpha.Firewall, ...Option) error
	Update(context.Context, *meta.Key, *computealpha.Firewall, ...Option) error
}

// NewMockAlphaFirewalls returns a new mock for Firewalls.
func NewMockAlphaFirewalls(pr ProjectRouter, objs map[meta.Key]*MockFirewallsObj) *MockAlphaFirewalls {
	mock := &MockAlphaFirewalls{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaFirewalls is the mock for Firewalls.
type MockAlphaFirewalls struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockFirewallsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaFirewalls, options ...Option) (bool, *computealpha.Firewall, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockAlphaFirewalls, options ...Option) (bool, []*computealpha.Firewall, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.Firewall, m *MockAlphaFirewalls, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaFirewalls, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *computealpha.Firewall, *MockAlphaFirewalls, ...Option) error
	UpdateHook func(context.Context, *meta.Key, *computealpha.Firewall, *MockAlphaFirewalls, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaFirewalls) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Firewall, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaFirewalls.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaFirewalls.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaFirewalls.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaFirewalls %v not found", key),
	}
	klog.V(5).Infof("MockAlphaFirewalls.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaFirewalls) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Firewall, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaFirewalls.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaFirewalls.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Firewall
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaFirewalls.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaFirewalls) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Firewall, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaFirewalls %v exists", key),
		}
		klog.V(5).Infof("MockAlphaFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "firewalls")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "firewalls", key)

	m.Objects[*key] = &MockFirewallsObj{obj}
	klog.V(5).Infof("MockAlphaFirewalls.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaFirewalls) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaFirewalls %v not found", key),
		}
		klog.V(5).Infof("MockAlphaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaFirewalls.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaFirewalls) Obj(o *computealpha.Firewall) *MockFirewallsObj {
	return &MockFirewallsObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaFirewalls) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Firewall, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockAlphaFirewalls) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.Firewall, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaFirewalls is a simplifying adapter for the GCE Firewalls.
type GCEAlphaFirewalls struct {
	s *Service
}

// Get the Firewall named by key.
func (g *GCEAlphaFirewalls) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Firewall, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaFirewalls.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaFirewalls.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Firewalls",
	}

	klog.V(5).Infof("GCEAlphaFirewalls.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Firewalls.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaFirewalls.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Firewall objects.
func (g *GCEAlphaFirewalls) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Firewall, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaFirewalls.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Firewalls",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaFirewalls.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.Firewalls.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Firewall
	f := func(l *computealpha.FirewallList) error {
		klog.V(5).Infof("GCEAlphaFirewalls.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaFirewalls.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaFirewalls.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaFirewalls.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Firewall with key of value obj.
func (g *GCEAlphaFirewalls) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaFirewalls.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaFirewalls.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEAlphaFirewalls.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Firewalls.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaFirewalls.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Firewall referenced by key.
func (g *GCEAlphaFirewalls) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaFirewalls.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaFirewalls.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEAlphaFirewalls.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Firewalls.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEAlphaFirewalls.
func (g *GCEAlphaFirewalls) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaFirewalls.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaFirewalls.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEAlphaFirewalls.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Firewalls.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaFirewalls.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaFirewalls.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaFirewalls.
func (g *GCEAlphaFirewalls) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaFirewalls.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaFirewalls.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEAlphaFirewalls.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaFirewalls.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Firewalls.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaFirewalls.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaFirewalls.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaFirewalls is an interface that allows for mocking of Firewalls.
type BetaFirewalls interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Firewall, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Firewall, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Firewall, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computebeta.Firewall, ...Option) error
	Update(context.Context, *meta.Key, *computebeta.Firewall, ...Option) error
}

// NewMockBetaFirewalls returns a new mock for Firewalls.
func NewMockBetaFirewalls(pr ProjectRouter, objs map[meta.Key]*MockFirewallsObj) *MockBetaFirewalls {
	mock := &MockBetaFirewalls{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaFirewalls is the mock for Firewalls.
type MockBetaFirewalls struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockFirewallsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaFirewalls, options ...Option) (bool, *computebeta.Firewall, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaFirewalls, options ...Option) (bool, []*computebeta.Firewall, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.Firewall, m *MockBetaFirewalls, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaFirewalls, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *computebeta.Firewall, *MockBetaFirewalls, ...Option) error
	UpdateHook func(context.Context, *meta.Key, *computebeta.Firewall, *MockBetaFirewalls, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaFirewalls) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Firewall, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaFirewalls.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaFirewalls.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaFirewalls.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaFirewalls %v not found", key),
	}
	klog.V(5).Infof("MockBetaFirewalls.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaFirewalls) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Firewall, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaFirewalls.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaFirewalls.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Firewall
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaFirewalls.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaFirewalls) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Firewall, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaFirewalls %v exists", key),
		}
		klog.V(5).Infof("MockBetaFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "firewalls")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "firewalls", key)

	m.Objects[*key] = &MockFirewallsObj{obj}
	klog.V(5).Infof("MockBetaFirewalls.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaFirewalls) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaFirewalls %v not found", key),
		}
		klog.V(5).Infof("MockBetaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaFirewalls.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaFirewalls) Obj(o *computebeta.Firewall) *MockFirewallsObj {
	return &MockFirewallsObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockBetaFirewalls) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Firewall, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockBetaFirewalls) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.Firewall, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaFirewalls is a simplifying adapter for the GCE Firewalls.
type GCEBetaFirewalls struct {
	s *Service
}

// Get the Firewall named by key.
func (g *GCEBetaFirewalls) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Firewall, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaFirewalls.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaFirewalls.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Firewalls",
	}

	klog.V(5).Infof("GCEBetaFirewalls.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Firewalls.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaFirewalls.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Firewall objects.
func (g *GCEBetaFirewalls) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Firewall, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaFirewalls.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Firewalls",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaFirewalls.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.Firewalls.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Firewall
	f := func(l *computebeta.FirewallList) error {
		klog.V(5).Infof("GCEBetaFirewalls.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaFirewalls.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaFirewalls.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaFirewalls.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Firewall with key of value obj.
func (g *GCEBetaFirewalls) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaFirewalls.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaFirewalls.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEBetaFirewalls.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Firewalls.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaFirewalls.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Firewall referenced by key.
func (g *GCEBetaFirewalls) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaFirewalls.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaFirewalls.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEBetaFirewalls.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Firewalls.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaFirewalls.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEBetaFirewalls.
func (g *GCEBetaFirewalls) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaFirewalls.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaFirewalls.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEBetaFirewalls.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Firewalls.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaFirewalls.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaFirewalls.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaFirewalls.
func (g *GCEBetaFirewalls) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaFirewalls.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaFirewalls.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEBetaFirewalls.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaFirewalls.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Firewalls.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaFirewalls.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaFirewalls.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Firewalls is an interface that allows for mocking of Firewalls.
type Firewalls interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Firewall, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Firewall, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Firewall, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computega.Firewall, ...Option) error
	Update(context.Context, *meta.Key, *computega.Firewall, ...Option) error
}

// NewMockFirewalls returns a new mock for Firewalls.
func NewMockFirewalls(pr ProjectRouter, objs map[meta.Key]*MockFirewallsObj) *MockFirewalls {
	mock := &MockFirewalls{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockFirewalls is the mock for Firewalls.
type MockFirewalls struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockFirewallsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockFirewalls, options ...Option) (bool, *computega.Firewall, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockFirewalls, options ...Option) (bool, []*computega.Firewall, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.Firewall, m *MockFirewalls, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockFirewalls, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *computega.Firewall, *MockFirewalls, ...Option) error
	UpdateHook func(context.Context, *meta.Key, *computega.Firewall, *MockFirewalls, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockFirewalls) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Firewall, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockFirewalls.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockFirewalls.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockFirewalls.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockFirewalls %v not found", key),
	}
	klog.V(5).Infof("MockFirewalls.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockFirewalls) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Firewall, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockFirewalls.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockFirewalls.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Firewall
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockFirewalls.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockFirewalls) Insert(ctx context.Context, key *meta.Key, obj *computega.Firewall, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockFirewalls %v exists", key),
		}
		klog.V(5).Infof("MockFirewalls.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "firewalls")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "firewalls", key)

	m.Objects[*key] = &MockFirewallsObj{obj}
	klog.V(5).Infof("MockFirewalls.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockFirewalls) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockFirewalls.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockFirewalls %v not found", key),
		}
		klog.V(5).Infof("MockFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockFirewalls.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockFirewalls) Obj(o *computega.Firewall) *MockFirewallsObj {
	return &MockFirewallsObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockFirewalls) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Firewall, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Update is a mock for the corresponding method.
func (m *MockFirewalls) Update(ctx context.Context, key *meta.Key, arg0 *computega.Firewall, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEFirewalls is a simplifying adapter for the GCE Firewalls.
type GCEFirewalls struct {
	s *Service
}

// Get the Firewall named by key.
func (g *GCEFirewalls) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Firewall, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEFirewalls.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEFirewalls.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Firewalls",
	}

	klog.V(5).Infof("GCEFirewalls.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEFirewalls.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Firewalls.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEFirewalls.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Firewall objects.
func (g *GCEFirewalls) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Firewall, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEFirewalls.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Firewalls",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEFirewalls.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Firewalls.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Firewall
	f := func(l *computega.FirewallList) error {
		klog.V(5).Infof("GCEFirewalls.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEFirewalls.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEFirewalls.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEFirewalls.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Firewall with key of value obj.
func (g *GCEFirewalls) Insert(ctx context.Context, key *meta.Key, obj *computega.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEFirewalls.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEFirewalls.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Firewalls")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEFirewalls.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEFirewalls.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Firewalls.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEFirewalls.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEFirewalls.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Firewall referenced by key.
func (g *GCEFirewalls) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEFirewalls.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEFirewalls.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEFirewalls.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEFirewalls.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Firewalls.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEFirewalls.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEFirewalls.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEFirewalls.
func (g *GCEFirewalls) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEFirewalls.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEFirewalls.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEFirewalls.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEFirewalls.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Firewalls.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEFirewalls.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEFirewalls.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Update is a method on GCEFirewalls.
func (g *GCEFirewalls) Update(ctx context.Context, key *meta.Key, arg0 *computega.Firewall, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEFirewalls.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEFirewalls.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Firewalls")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "Firewalls",
	}
	klog.V(5).Infof("GCEFirewalls.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEFirewalls.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Firewalls.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEFirewalls.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEFirewalls.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaNetworkFirewallPolicies is an interface that allows for mocking of NetworkFirewallPolicies.
type AlphaNetworkFirewallPolicies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.FirewallPolicy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AddAssociation(context.Context, *meta.Key, *computealpha.FirewallPolicyAssociation, ...Option) error
	AddRule(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, ...Option) error
	CloneRules(context.Context, *meta.Key, ...Option) error
	GetAssociation(context.Context, *meta.Key, ...Option) (*computealpha.FirewallPolicyAssociation, error)
	GetIamPolicy(context.Context, *meta.Key, ...Option) (*computealpha.Policy, error)
	GetRule(context.Context, *meta.Key, ...Option) (*computealpha.FirewallPolicyRule, error)
	Patch(context.Context, *meta.Key, *computealpha.FirewallPolicy, ...Option) error
	PatchRule(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, ...Option) error
	RemoveAssociation(context.Context, *meta.Key, ...Option) error
	RemoveRule(context.Context, *meta.Key, ...Option) error
	SetIamPolicy(context.Context, *meta.Key, *computealpha.GlobalSetPolicyRequest, ...Option) (*computealpha.Policy, error)
	TestIamPermissions(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, ...Option) (*computealpha.TestPermissionsResponse, error)
}

// NewMockAlphaNetworkFirewallPolicies returns a new mock for NetworkFirewallPolicies.
func NewMockAlphaNetworkFirewallPolicies(pr ProjectRouter, objs map[meta.Key]*MockNetworkFirewallPoliciesObj) *MockAlphaNetworkFirewallPolicies {
	mock := &MockAlphaNetworkFirewallPolicies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaNetworkFirewallPolicies is the mock for NetworkFirewallPolicies.
type MockAlphaNetworkFirewallPolicies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworkFirewallPoliciesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaNetworkFirewallPolicies, options ...Option) (bool, *computealpha.FirewallPolicy, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockAlphaNetworkFirewallPolicies, options ...Option) (bool, []*computealpha.FirewallPolicy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, m *MockAlphaNetworkFirewallPolicies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaNetworkFirewallPolicies, options ...Option) (bool, error)
	AddAssociationHook     func(context.Context, *meta.Key, *computealpha.FirewallPolicyAssociation, *MockAlphaNetworkFirewallPolicies, ...Option) error
	AddRuleHook            func(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, *MockAlphaNetworkFirewallPolicies, ...Option) error
	CloneRulesHook         func(context.Context, *meta.Key, *MockAlphaNetworkFirewallPolicies, ...Option) error
	GetAssociationHook     func(context.Context, *meta.Key, *MockAlphaNetworkFirewallPolicies, ...Option) (*computealpha.FirewallPolicyAssociation, error)
	GetIamPolicyHook       func(context.Context, *meta.Key, *MockAlphaNetworkFirewallPolicies, ...Option) (*computealpha.Policy, error)
	GetRuleHook            func(context.Context, *meta.Key, *MockAlphaNetworkFirewallPolicies, ...Option) (*computealpha.FirewallPolicyRule, error)
	PatchHook              func(context.Context, *meta.Key, *computealpha.FirewallPolicy, *MockAlphaNetworkFirewallPolicies, ...Option) error
	PatchRuleHook          func(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, *MockAlphaNetworkFirewallPolicies, ...Option) error
	RemoveAssociationHook  func(context.Context, *meta.Key, *MockAlphaNetworkFirewallPolicies, ...Option) error
	RemoveRuleHook         func(context.Context, *meta.Key, *MockAlphaNetworkFirewallPolicies, ...Option) error
	SetIamPolicyHook       func(context.Context, *meta.Key, *computealpha.GlobalSetPolicyRequest, *MockAlphaNetworkFirewallPolicies, ...Option) (*computealpha.Policy, error)
	TestIamPermissionsHook func(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, *MockAlphaNetworkFirewallPolicies, ...Option) (*computealpha.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaNetworkFirewallPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaNetworkFirewallPolicies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaNetworkFirewallPolicies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.FirewallPolicy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.FirewallPolicy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaNetworkFirewallPolicies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaNetworkFirewallPolicies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "networkFirewallPolicies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "networkFirewallPolicies", key)

	m.Objects[*key] = &MockNetworkFirewallPoliciesObj{obj}
	klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaNetworkFirewallPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaNetworkFirewallPolicies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaNetworkFirewallPolicies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaNetworkFirewallPolicies) Obj(o *computealpha.FirewallPolicy) *MockNetworkFirewallPoliciesObj {
	return &MockNetworkFirewallPoliciesObj{o}
}

// AddAssociation is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) AddAssociation(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyAssociation, options ...Option) error {
	if m.AddAssociationHook != nil {
		return m.AddAssociationHook(ctx, key, arg0, m)
	}
	return nil
}

// AddRule is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) AddRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	if m.AddRuleHook != nil {
		return m.AddRuleHook(ctx, key, arg0, m)
	}
	return nil
}

// CloneRules is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) CloneRules(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.CloneRulesHook != nil {
		return m.CloneRulesHook(ctx, key, m)
	}
	return nil
}

// GetAssociation is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) GetAssociation(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyAssociation, error) {
	if m.GetAssociationHook != nil {
		return m.GetAssociationHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetAssociationHook must be set")
}

// GetIamPolicy is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Policy, error) {
	if m.GetIamPolicyHook != nil {
		return m.GetIamPolicyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetIamPolicyHook must be set")
}

// GetRule is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) GetRule(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyRule, error) {
	if m.GetRuleHook != nil {
		return m.GetRuleHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetRuleHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicy, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// PatchRule is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) PatchRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	if m.PatchRuleHook != nil {
		return m.PatchRuleHook(ctx, key, arg0, m)
	}
	return nil
}

// RemoveAssociation is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) RemoveAssociation(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.RemoveAssociationHook != nil {
		return m.RemoveAssociationHook(ctx, key, m)
	}
	return nil
}

// RemoveRule is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) RemoveRule(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.RemoveRuleHook != nil {
		return m.RemoveRuleHook(ctx, key, m)
	}
	return nil
}

// SetIamPolicy is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetPolicyRequest, options ...Option) (*computealpha.Policy, error) {
	if m.SetIamPolicyHook != nil {
		return m.SetIamPolicyHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("SetIamPolicyHook must be set")
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockAlphaNetworkFirewallPolicies) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEAlphaNetworkFirewallPolicies is a simplifying adapter for the GCE NetworkFirewallPolicies.
type GCEAlphaNetworkFirewallPolicies struct {
	s *Service
}

// Get the FirewallPolicy named by key.
func (g *GCEAlphaNetworkFirewallPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}

	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all FirewallPolicy objects.
func (g *GCEAlphaNetworkFirewallPolicies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.FirewallPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.NetworkFirewallPolicies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.FirewallPolicy
	f := func(l *computealpha.FirewallPolicyList) error {
		klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert FirewallPolicy with key of value obj.
func (g *GCEAlphaNetworkFirewallPolicies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.NetworkFirewallPolicies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the FirewallPolicy referenced by key.
func (g *GCEAlphaNetworkFirewallPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AddAssociation is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) AddAssociation(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyAssociation, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.AddAssociation(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.AddAssociation(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddAssociation",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.AddAssociation(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.AddAssociation(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.AddAssociation(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.AddAssociation(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.AddAssociation(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AddRule is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) AddRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.AddRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.AddRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddRule",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.AddRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.AddRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.AddRule(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.AddRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.AddRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// CloneRules is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) CloneRules(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.CloneRules(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.CloneRules(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "CloneRules",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.CloneRules(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.CloneRules(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.CloneRules(projectID, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.CloneRules(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.CloneRules(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// GetAssociation is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) GetAssociation(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyAssociation, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.GetAssociation(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.GetAssociation(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetAssociation",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.GetAssociation(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.GetAssociation(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.GetAssociation(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.GetAssociation(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetIamPolicy is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.GetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.GetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetIamPolicy",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.GetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.GetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.GetIamPolicy(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.GetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetRule is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) GetRule(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.GetRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.GetRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetRule",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.GetRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.GetRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.GetRule(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.GetRule(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// PatchRule is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) PatchRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.PatchRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.PatchRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "PatchRule",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.PatchRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.PatchRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.PatchRule(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.PatchRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.PatchRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RemoveAssociation is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) RemoveAssociation(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.RemoveAssociation(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.RemoveAssociation(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveAssociation",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.RemoveAssociation(projectID, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RemoveRule is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) RemoveRule(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.RemoveRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.RemoveRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveRule",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.RemoveRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.RemoveRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.RemoveRule(projectID, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.RemoveRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.RemoveRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetIamPolicy is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetPolicyRequest, options ...Option) (*computealpha.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.SetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.SetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetIamPolicy",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.SetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.SetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.SetIamPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.SetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// TestIamPermissions is a method on GCEAlphaNetworkFirewallPolicies.
func (g *GCEAlphaNetworkFirewallPolicies) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkFirewallPolicies.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("alpha"),
		Service:   "NetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaNetworkFirewallPolicies.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkFirewallPolicies.TestIamPermissions(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaNetworkFirewallPolicies.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// AlphaRegionNetworkFirewallPolicies is an interface that allows for mocking of RegionNetworkFirewallPolicies.
type AlphaRegionNetworkFirewallPolicies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.FirewallPolicy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AddAssociation(context.Context, *meta.Key, *computealpha.FirewallPolicyAssociation, ...Option) error
	AddRule(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, ...Option) error
	CloneRules(context.Context, *meta.Key, ...Option) error
	GetAssociation(context.Context, *meta.Key, ...Option) (*computealpha.FirewallPolicyAssociation, error)
	GetIamPolicy(context.Context, *meta.Key, ...Option) (*computealpha.Policy, error)
	GetRule(context.Context, *meta.Key, ...Option) (*computealpha.FirewallPolicyRule, error)
	Patch(context.Context, *meta.Key, *computealpha.FirewallPolicy, ...Option) error
	PatchRule(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, ...Option) error
	RemoveAssociation(context.Context, *meta.Key, ...Option) error
	RemoveRule(context.Context, *meta.Key, ...Option) error
	SetIamPolicy(context.Context, *meta.Key, *computealpha.RegionSetPolicyRequest, ...Option) (*computealpha.Policy, error)
	TestIamPermissions(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, ...Option) (*computealpha.TestPermissionsResponse, error)
}

// NewMockAlphaRegionNetworkFirewallPolicies returns a new mock for RegionNetworkFirewallPolicies.
func NewMockAlphaRegionNetworkFirewallPolicies(pr ProjectRouter, objs map[meta.Key]*MockRegionNetworkFirewallPoliciesObj) *MockAlphaRegionNetworkFirewallPolicies {
	mock := &MockAlphaRegionNetworkFirewallPolicies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionNetworkFirewallPolicies is the mock for RegionNetworkFirewallPolicies.
type MockAlphaRegionNetworkFirewallPolicies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionNetworkFirewallPoliciesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaRegionNetworkFirewallPolicies, options ...Option) (bool, *computealpha.FirewallPolicy, error)
	ListHook               func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionNetworkFirewallPolicies, options ...Option) (bool, []*computealpha.FirewallPolicy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, m *MockAlphaRegionNetworkFirewallPolicies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaRegionNetworkFirewallPolicies, options ...Option) (bool, error)
	AddAssociationHook     func(context.Context, *meta.Key, *computealpha.FirewallPolicyAssociation, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	AddRuleHook            func(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	CloneRulesHook         func(context.Context, *meta.Key, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	GetAssociationHook     func(context.Context, *meta.Key, *MockAlphaRegionNetworkFirewallPolicies, ...Option) (*computealpha.FirewallPolicyAssociation, error)
	GetIamPolicyHook       func(context.Context, *meta.Key, *MockAlphaRegionNetworkFirewallPolicies, ...Option) (*computealpha.Policy, error)
	GetRuleHook            func(context.Context, *meta.Key, *MockAlphaRegionNetworkFirewallPolicies, ...Option) (*computealpha.FirewallPolicyRule, error)
	PatchHook              func(context.Context, *meta.Key, *computealpha.FirewallPolicy, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	PatchRuleHook          func(context.Context, *meta.Key, *computealpha.FirewallPolicyRule, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	RemoveAssociationHook  func(context.Context, *meta.Key, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	RemoveRuleHook         func(context.Context, *meta.Key, *MockAlphaRegionNetworkFirewallPolicies, ...Option) error
	SetIamPolicyHook       func(context.Context, *meta.Key, *computealpha.RegionSetPolicyRequest, *MockAlphaRegionNetworkFirewallPolicies, ...Option) (*computealpha.Policy, error)
	TestIamPermissionsHook func(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, *MockAlphaRegionNetworkFirewallPolicies, ...Option) (*computealpha.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionNetworkFirewallPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionNetworkFirewallPolicies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionNetworkFirewallPolicies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.FirewallPolicy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.FirewallPolicy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionNetworkFirewallPolicies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionNetworkFirewallPolicies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "regionNetworkFirewallPolicies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "regionNetworkFirewallPolicies", key)

	m.Objects[*key] = &MockRegionNetworkFirewallPoliciesObj{obj}
	klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionNetworkFirewallPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionNetworkFirewallPolicies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionNetworkFirewallPolicies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionNetworkFirewallPolicies) Obj(o *computealpha.FirewallPolicy) *MockRegionNetworkFirewallPoliciesObj {
	return &MockRegionNetworkFirewallPoliciesObj{o}
}

// AddAssociation is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) AddAssociation(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyAssociation, options ...Option) error {
	if m.AddAssociationHook != nil {
		return m.AddAssociationHook(ctx, key, arg0, m)
	}
	return nil
}

// AddRule is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) AddRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	if m.AddRuleHook != nil {
		return m.AddRuleHook(ctx, key, arg0, m)
	}
	return nil
}

// CloneRules is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) CloneRules(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.CloneRulesHook != nil {
		return m.CloneRulesHook(ctx, key, m)
	}
	return nil
}

// GetAssociation is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) GetAssociation(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyAssociation, error) {
	if m.GetAssociationHook != nil {
		return m.GetAssociationHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetAssociationHook must be set")
}

// GetIamPolicy is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Policy, error) {
	if m.GetIamPolicyHook != nil {
		return m.GetIamPolicyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetIamPolicyHook must be set")
}

// GetRule is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) GetRule(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyRule, error) {
	if m.GetRuleHook != nil {
		return m.GetRuleHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetRuleHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicy, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// PatchRule is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) PatchRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	if m.PatchRuleHook != nil {
		return m.PatchRuleHook(ctx, key, arg0, m)
	}
	return nil
}

// RemoveAssociation is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) RemoveAssociation(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.RemoveAssociationHook != nil {
		return m.RemoveAssociationHook(ctx, key, m)
	}
	return nil
}

// RemoveRule is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) RemoveRule(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.RemoveRuleHook != nil {
		return m.RemoveRuleHook(ctx, key, m)
	}
	return nil
}

// SetIamPolicy is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.RegionSetPolicyRequest, options ...Option) (*computealpha.Policy, error) {
	if m.SetIamPolicyHook != nil {
		return m.SetIamPolicyHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("SetIamPolicyHook must be set")
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockAlphaRegionNetworkFirewallPolicies) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEAlphaRegionNetworkFirewallPolicies is a simplifying adapter for the GCE RegionNetworkFirewallPolicies.
type GCEAlphaRegionNetworkFirewallPolicies struct {
	s *Service
}

// Get the FirewallPolicy named by key.
func (g *GCEAlphaRegionNetworkFirewallPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}

	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all FirewallPolicy objects.
func (g *GCEAlphaRegionNetworkFirewallPolicies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.FirewallPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionNetworkFirewallPolicies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.FirewallPolicy
	f := func(l *computealpha.FirewallPolicyList) error {
		klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert FirewallPolicy with key of value obj.
func (g *GCEAlphaRegionNetworkFirewallPolicies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.FirewallPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionNetworkFirewallPolicies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the FirewallPolicy referenced by key.
func (g *GCEAlphaRegionNetworkFirewallPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AddAssociation is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) AddAssociation(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyAssociation, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddAssociation(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddAssociation(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddAssociation",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddAssociation(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddAssociation(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.AddAssociation(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddAssociation(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddAssociation(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AddRule is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) AddRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddRule",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.AddRule(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.AddRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// CloneRules is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) CloneRules(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.CloneRules(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.CloneRules(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "CloneRules",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.CloneRules(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.CloneRules(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.CloneRules(projectID, key.Region, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.CloneRules(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.CloneRules(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// GetAssociation is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) GetAssociation(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyAssociation, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetAssociation(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetAssociation(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetAssociation",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetAssociation(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetAssociation(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.GetAssociation(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetAssociation(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetIamPolicy is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetIamPolicy",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.GetIamPolicy(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetRule is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) GetRule(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.FirewallPolicyRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetRule",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.GetRule(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.GetRule(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// PatchRule is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) PatchRule(ctx context.Context, key *meta.Key, arg0 *computealpha.FirewallPolicyRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.PatchRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.PatchRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "PatchRule",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.PatchRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.PatchRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.PatchRule(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.PatchRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.PatchRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RemoveAssociation is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) RemoveAssociation(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveAssociation(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveAssociation(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveAssociation",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.RemoveAssociation(projectID, key.Region, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveAssociation(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RemoveRule is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) RemoveRule(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveRule",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.RemoveRule(projectID, key.Region, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.RemoveRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetIamPolicy is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.RegionSetPolicyRequest, options ...Option) (*computealpha.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.SetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.SetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetIamPolicy",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.SetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.SetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.SetIamPolicy(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.SetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// TestIamPermissions is a method on GCEAlphaRegionNetworkFirewallPolicies.
func (g *GCEAlphaRegionNetworkFirewallPolicies) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionNetworkFirewallPolicies.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionNetworkFirewallPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("alpha"),
		Service:   "RegionNetworkFirewallPolicies",
	}
	klog.V(5).Infof("GCEAlphaRegionNetworkFirewallPolicies.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionNetworkFirewallPolicies.TestIamPermissions(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRegionNetworkFirewallPolicies.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// ForwardingRules is an interface that allows for mocking of ForwardingRules.
type ForwardingRules interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ForwardingRule, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.ForwardingRule, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetLabels(context.Context, *meta.Key, *computega.RegionSetLabelsRequest, ...Option) error
	SetTarget(context.Context, *meta.Key, *computega.TargetReference, ...Option) error
}

// NewMockForwardingRules returns a new mock for ForwardingRules.
func NewMockForwardingRules(pr ProjectRouter, objs map[meta.Key]*MockForwardingRulesObj) *MockForwardingRules {
	mock := &MockForwardingRules{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockForwardingRules is the mock for ForwardingRules.
type MockForwardingRules struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockForwardingRulesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockForwardingRules, options ...Option) (bool, *computega.ForwardingRule, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockForwardingRules, options ...Option) (bool, []*computega.ForwardingRule, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, m *MockForwardingRules, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockForwardingRules, options ...Option) (bool, error)
	SetLabelsHook func(context.Context, *meta.Key, *computega.RegionSetLabelsRequest, *MockForwardingRules, ...Option) error
	SetTargetHook func(context.Context, *meta.Key, *computega.TargetReference, *MockForwardingRules, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockForwardingRules.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockForwardingRules.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockForwardingRules %v not found", key),
	}
	klog.V(5).Infof("MockForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockForwardingRules) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockForwardingRules.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockForwardingRules.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.ForwardingRule
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockForwardingRules.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockForwardingRules %v exists", key),
		}
		klog.V(5).Infof("MockForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "forwardingRules")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "forwardingRules", key)

	m.Objects[*key] = &MockForwardingRulesObj{obj}
	klog.V(5).Infof("MockForwardingRules.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockForwardingRules %v not found", key),
		}
		klog.V(5).Infof("MockForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockForwardingRules.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockForwardingRules) Obj(o *computega.ForwardingRule) *MockForwardingRulesObj {
	return &MockForwardingRulesObj{o}
}

// SetLabels is a mock for the corresponding method.
func (m *MockForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computega.RegionSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// SetTarget is a mock for the corresponding method.
func (m *MockForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computega.TargetReference, options ...Option) error {
	if m.SetTargetHook != nil {
		return m.SetTargetHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEForwardingRules is a simplifying adapter for the GCE ForwardingRules.
type GCEForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEForwardingRules.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEForwardingRules.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "ForwardingRules",
	}

	klog.V(5).Infof("GCEForwardingRules.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEForwardingRules.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.ForwardingRules.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEForwardingRules.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ForwardingRule objects.
func (g *GCEForwardingRules) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEForwardingRules.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "ForwardingRules",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEForwardingRules.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.ForwardingRules.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.ForwardingRule
	f := func(l *computega.ForwardingRuleList) error {
		klog.V(5).Infof("GCEForwardingRules.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEForwardingRules.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEForwardingRules.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEForwardingRules.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEForwardingRules.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEForwardingRules.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.ForwardingRules.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEForwardingRules.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEForwardingRules.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ForwardingRule referenced by key.
func (g *GCEForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEForwardingRules.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEForwardingRules.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEForwardingRules.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEForwardingRules.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.ForwardingRules.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetLabels is a method on GCEForwardingRules.
func (g *GCEForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computega.RegionSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEForwardingRules.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEForwardingRules.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("ga"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEForwardingRules.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEForwardingRules.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.ForwardingRules.SetLabels(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetTarget is a method on GCEForwardingRules.
func (g *GCEForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computega.TargetReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEForwardingRules.SetTarget(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEForwardingRules.SetTarget(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetTarget",
		Version:   meta.Version("ga"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEForwardingRules.SetTarget(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEForwardingRules.SetTarget(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.ForwardingRules.SetTarget(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaForwardingRules is an interface that allows for mocking of ForwardingRules.
type AlphaForwardingRules interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ForwardingRule, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.ForwardingRule, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetLabels(context.Context, *meta.Key, *computealpha.RegionSetLabelsRequest, ...Option) error
	SetTarget(context.Context, *meta.Key, *computealpha.TargetReference, ...Option) error
}

// NewMockAlphaForwardingRules returns a new mock for ForwardingRules.
func NewMockAlphaForwardingRules(pr ProjectRouter, objs map[meta.Key]*MockForwardingRulesObj) *MockAlphaForwardingRules {
	mock := &MockAlphaForwardingRules{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaForwardingRules is the mock for ForwardingRules.
type MockAlphaForwardingRules struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockForwardingRulesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockAlphaForwardingRules, options ...Option) (bool, *computealpha.ForwardingRule, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockAlphaForwardingRules, options ...Option) (bool, []*computealpha.ForwardingRule, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, m *MockAlphaForwardingRules, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockAlphaForwardingRules, options ...Option) (bool, error)
	SetLabelsHook func(context.Context, *meta.Key, *computealpha.RegionSetLabelsRequest, *MockAlphaForwardingRules, ...Option) error
	SetTargetHook func(context.Context, *meta.Key, *computealpha.TargetReference, *MockAlphaForwardingRules, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaForwardingRules.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaForwardingRules.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaForwardingRules %v not found", key),
	}
	klog.V(5).Infof("MockAlphaForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaForwardingRules) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaForwardingRules.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaForwardingRules.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.ForwardingRule
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaForwardingRules.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaForwardingRules %v exists", key),
		}
		klog.V(5).Infof("MockAlphaForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "forwardingRules")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "forwardingRules", key)

	m.Objects[*key] = &MockForwardingRulesObj{obj}
	klog.V(5).Infof("MockAlphaForwardingRules.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaForwardingRules %v not found", key),
		}
		klog.V(5).Infof("MockAlphaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaForwardingRules.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaForwardingRules) Obj(o *computealpha.ForwardingRule) *MockForwardingRulesObj {
	return &MockForwardingRulesObj{o}
}

// SetLabels is a mock for the corresponding method.
func (m *MockAlphaForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computealpha.RegionSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// SetTarget is a mock for the corresponding method.
func (m *MockAlphaForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetReference, options ...Option) error {
	if m.SetTargetHook != nil {
		return m.SetTargetHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaForwardingRules is a simplifying adapter for the GCE ForwardingRules.
type GCEAlphaForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEAlphaForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaForwardingRules.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaForwardingRules.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "ForwardingRules",
	}

	klog.V(5).Infof("GCEAlphaForwardingRules.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.ForwardingRules.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaForwardingRules.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ForwardingRule objects.
func (g *GCEAlphaForwardingRules) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaForwardingRules.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "ForwardingRules",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaForwardingRules.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.ForwardingRules.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.ForwardingRule
	f := func(l *computealpha.ForwardingRuleList) error {
		klog.V(5).Infof("GCEAlphaForwardingRules.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaForwardingRules.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEAlphaForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaForwardingRules.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaForwardingRules.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaForwardingRules.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.ForwardingRules.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaForwardingRules.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ForwardingRule referenced by key.
func (g *GCEAlphaForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaForwardingRules.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaForwardingRules.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaForwardingRules.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.ForwardingRules.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetLabels is a method on GCEAlphaForwardingRules.
func (g *GCEAlphaForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computealpha.RegionSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaForwardingRules.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaForwardingRules.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("alpha"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaForwardingRules.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.ForwardingRules.SetLabels(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetTarget is a method on GCEAlphaForwardingRules.
func (g *GCEAlphaForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaForwardingRules.SetTarget(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaForwardingRules.SetTarget(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetTarget",
		Version:   meta.Version("alpha"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaForwardingRules.SetTarget(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaForwardingRules.SetTarget(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.ForwardingRules.SetTarget(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaForwardingRules is an interface that allows for mocking of ForwardingRules.
type BetaForwardingRules interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ForwardingRule, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.ForwardingRule, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetLabels(context.Context, *meta.Key, *computebeta.RegionSetLabelsRequest, ...Option) error
	SetTarget(context.Context, *meta.Key, *computebeta.TargetReference, ...Option) error
}

// NewMockBetaForwardingRules returns a new mock for ForwardingRules.
func NewMockBetaForwardingRules(pr ProjectRouter, objs map[meta.Key]*MockForwardingRulesObj) *MockBetaForwardingRules {
	mock := &MockBetaForwardingRules{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaForwardingRules is the mock for ForwardingRules.
type MockBetaForwardingRules struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockForwardingRulesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockBetaForwardingRules, options ...Option) (bool, *computebeta.ForwardingRule, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockBetaForwardingRules, options ...Option) (bool, []*computebeta.ForwardingRule, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, m *MockBetaForwardingRules, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockBetaForwardingRules, options ...Option) (bool, error)
	SetLabelsHook func(context.Context, *meta.Key, *computebeta.RegionSetLabelsRequest, *MockBetaForwardingRules, ...Option) error
	SetTargetHook func(context.Context, *meta.Key, *computebeta.TargetReference, *MockBetaForwardingRules, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaForwardingRules.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaForwardingRules.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaForwardingRules %v not found", key),
	}
	klog.V(5).Infof("MockBetaForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaForwardingRules) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaForwardingRules.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaForwardingRules.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.ForwardingRule
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaForwardingRules.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaForwardingRules %v exists", key),
		}
		klog.V(5).Infof("MockBetaForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "forwardingRules")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "forwardingRules", key)

	m.Objects[*key] = &MockForwardingRulesObj{obj}
	klog.V(5).Infof("MockBetaForwardingRules.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaForwardingRules %v not found", key),
		}
		klog.V(5).Infof("MockBetaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaForwardingRules.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaForwardingRules) Obj(o *computebeta.ForwardingRule) *MockForwardingRulesObj {
	return &MockForwardingRulesObj{o}
}

// SetLabels is a mock for the corresponding method.
func (m *MockBetaForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computebeta.RegionSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// SetTarget is a mock for the corresponding method.
func (m *MockBetaForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetReference, options ...Option) error {
	if m.SetTargetHook != nil {
		return m.SetTargetHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaForwardingRules is a simplifying adapter for the GCE ForwardingRules.
type GCEBetaForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEBetaForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaForwardingRules.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaForwardingRules.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "ForwardingRules",
	}

	klog.V(5).Infof("GCEBetaForwardingRules.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.ForwardingRules.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaForwardingRules.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ForwardingRule objects.
func (g *GCEBetaForwardingRules) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaForwardingRules.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "ForwardingRules",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaForwardingRules.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.ForwardingRules.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.ForwardingRule
	f := func(l *computebeta.ForwardingRuleList) error {
		klog.V(5).Infof("GCEBetaForwardingRules.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaForwardingRules.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEBetaForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaForwardingRules.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaForwardingRules.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEBetaForwardingRules.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.ForwardingRules.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaForwardingRules.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ForwardingRule referenced by key.
func (g *GCEBetaForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaForwardingRules.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaForwardingRules.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEBetaForwardingRules.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.ForwardingRules.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetLabels is a method on GCEBetaForwardingRules.
func (g *GCEBetaForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computebeta.RegionSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaForwardingRules.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaForwardingRules.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("beta"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEBetaForwardingRules.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.ForwardingRules.SetLabels(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetTarget is a method on GCEBetaForwardingRules.
func (g *GCEBetaForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaForwardingRules.SetTarget(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaForwardingRules.SetTarget(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetTarget",
		Version:   meta.Version("beta"),
		Service:   "ForwardingRules",
	}
	klog.V(5).Infof("GCEBetaForwardingRules.SetTarget(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaForwardingRules.SetTarget(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.ForwardingRules.SetTarget(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaGlobalForwardingRules is an interface that allows for mocking of GlobalForwardingRules.
type AlphaGlobalForwardingRules interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ForwardingRule, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.ForwardingRule, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetLabels(context.Context, *meta.Key, *computealpha.GlobalSetLabelsRequest, ...Option) error
	SetTarget(context.Context, *meta.Key, *computealpha.TargetReference, ...Option) error
}

// NewMockAlphaGlobalForwardingRules returns a new mock for GlobalForwardingRules.
func NewMockAlphaGlobalForwardingRules(pr ProjectRouter, objs map[meta.Key]*MockGlobalForwardingRulesObj) *MockAlphaGlobalForwardingRules {
	mock := &MockAlphaGlobalForwardingRules{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaGlobalForwardingRules is the mock for GlobalForwardingRules.
type MockAlphaGlobalForwardingRules struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalForwardingRulesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockAlphaGlobalForwardingRules, options ...Option) (bool, *computealpha.ForwardingRule, error)
	ListHook      func(ctx context.Context, fl *filter.F, m *MockAlphaGlobalForwardingRules, options ...Option) (bool, []*computealpha.ForwardingRule, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, m *MockAlphaGlobalForwardingRules, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockAlphaGlobalForwardingRules, options ...Option) (bool, error)
	SetLabelsHook func(context.Context, *meta.Key, *computealpha.GlobalSetLabelsRequest, *MockAlphaGlobalForwardingRules, ...Option) error
	SetTargetHook func(context.Context, *meta.Key, *computealpha.TargetReference, *MockAlphaGlobalForwardingRules, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaGlobalForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalForwardingRules.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaGlobalForwardingRules %v not found", key),
	}
	klog.V(5).Infof("MockAlphaGlobalForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaGlobalForwardingRules) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalForwardingRules.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.ForwardingRule
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaGlobalForwardingRules.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaGlobalForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaGlobalForwardingRules %v exists", key),
		}
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "forwardingRules")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "forwardingRules", key)

	m.Objects[*key] = &MockGlobalForwardingRulesObj{obj}
	klog.V(5).Infof("MockAlphaGlobalForwardingRules.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaGlobalForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaGlobalForwardingRules %v not found", key),
		}
		klog.V(5).Infof("MockAlphaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaGlobalForwardingRules.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaGlobalForwardingRules) Obj(o *computealpha.ForwardingRule) *MockGlobalForwardingRulesObj {
	return &MockGlobalForwardingRulesObj{o}
}

// SetLabels is a mock for the corresponding method.
func (m *MockAlphaGlobalForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// SetTarget is a mock for the corresponding method.
func (m *MockAlphaGlobalForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetReference, options ...Option) error {
	if m.SetTargetHook != nil {
		return m.SetTargetHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaGlobalForwardingRules is a simplifying adapter for the GCE GlobalForwardingRules.
type GCEAlphaGlobalForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEAlphaGlobalForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalForwardingRules.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "GlobalForwardingRules",
	}

	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.GlobalForwardingRules.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ForwardingRule objects.
func (g *GCEAlphaGlobalForwardingRules) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "GlobalForwardingRules",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.GlobalForwardingRules.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.ForwardingRule
	f := func(l *computealpha.ForwardingRuleList) error {
		klog.V(5).Infof("GCEAlphaGlobalForwardingRules.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaGlobalForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEAlphaGlobalForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computealpha.ForwardingRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalForwardingRules.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.GlobalForwardingRules.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ForwardingRule referenced by key.
func (g *GCEAlphaGlobalForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalForwardingRules.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalForwardingRules.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetLabels is a method on GCEAlphaGlobalForwardingRules.
func (g *GCEAlphaGlobalForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalForwardingRules.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("alpha"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalForwardingRules.SetLabels(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaGlobalForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetTarget is a method on GCEAlphaGlobalForwardingRules.
func (g *GCEAlphaGlobalForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.SetTarget(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalForwardingRules.SetTarget(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetTarget",
		Version:   meta.Version("alpha"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEAlphaGlobalForwardingRules.SetTarget(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.SetTarget(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalForwardingRules.SetTarget(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaGlobalForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaGlobalForwardingRules is an interface that allows for mocking of GlobalForwardingRules.
type BetaGlobalForwardingRules interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ForwardingRule, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.ForwardingRule, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetLabels(context.Context, *meta.Key, *computebeta.GlobalSetLabelsRequest, ...Option) error
	SetTarget(context.Context, *meta.Key, *computebeta.TargetReference, ...Option) error
}

// NewMockBetaGlobalForwardingRules returns a new mock for GlobalForwardingRules.
func NewMockBetaGlobalForwardingRules(pr ProjectRouter, objs map[meta.Key]*MockGlobalForwardingRulesObj) *MockBetaGlobalForwardingRules {
	mock := &MockBetaGlobalForwardingRules{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaGlobalForwardingRules is the mock for GlobalForwardingRules.
type MockBetaGlobalForwardingRules struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalForwardingRulesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockBetaGlobalForwardingRules, options ...Option) (bool, *computebeta.ForwardingRule, error)
	ListHook      func(ctx context.Context, fl *filter.F, m *MockBetaGlobalForwardingRules, options ...Option) (bool, []*computebeta.ForwardingRule, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, m *MockBetaGlobalForwardingRules, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockBetaGlobalForwardingRules, options ...Option) (bool, error)
	SetLabelsHook func(context.Context, *meta.Key, *computebeta.GlobalSetLabelsRequest, *MockBetaGlobalForwardingRules, ...Option) error
	SetTargetHook func(context.Context, *meta.Key, *computebeta.TargetReference, *MockBetaGlobalForwardingRules, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaGlobalForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalForwardingRules.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaGlobalForwardingRules.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaGlobalForwardingRules %v not found", key),
	}
	klog.V(5).Infof("MockBetaGlobalForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaGlobalForwardingRules) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalForwardingRules.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaGlobalForwardingRules.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.ForwardingRule
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaGlobalForwardingRules.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaGlobalForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaGlobalForwardingRules %v exists", key),
		}
		klog.V(5).Infof("MockBetaGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "forwardingRules")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "forwardingRules", key)

	m.Objects[*key] = &MockGlobalForwardingRulesObj{obj}
	klog.V(5).Infof("MockBetaGlobalForwardingRules.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaGlobalForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaGlobalForwardingRules %v not found", key),
		}
		klog.V(5).Infof("MockBetaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaGlobalForwardingRules.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaGlobalForwardingRules) Obj(o *computebeta.ForwardingRule) *MockGlobalForwardingRulesObj {
	return &MockGlobalForwardingRulesObj{o}
}

// SetLabels is a mock for the corresponding method.
func (m *MockBetaGlobalForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// SetTarget is a mock for the corresponding method.
func (m *MockBetaGlobalForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetReference, options ...Option) error {
	if m.SetTargetHook != nil {
		return m.SetTargetHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaGlobalForwardingRules is a simplifying adapter for the GCE GlobalForwardingRules.
type GCEBetaGlobalForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEBetaGlobalForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalForwardingRules.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "GlobalForwardingRules",
	}

	klog.V(5).Infof("GCEBetaGlobalForwardingRules.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.GlobalForwardingRules.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaGlobalForwardingRules.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ForwardingRule objects.
func (g *GCEBetaGlobalForwardingRules) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "GlobalForwardingRules",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.GlobalForwardingRules.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.ForwardingRule
	f := func(l *computebeta.ForwardingRuleList) error {
		klog.V(5).Infof("GCEBetaGlobalForwardingRules.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaGlobalForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEBetaGlobalForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computebeta.ForwardingRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalForwardingRules.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.GlobalForwardingRules.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaGlobalForwardingRules.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ForwardingRule referenced by key.
func (g *GCEBetaGlobalForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalForwardingRules.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalForwardingRules.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetLabels is a method on GCEBetaGlobalForwardingRules.
func (g *GCEBetaGlobalForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalForwardingRules.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("beta"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalForwardingRules.SetLabels(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaGlobalForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetTarget is a method on GCEBetaGlobalForwardingRules.
func (g *GCEBetaGlobalForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.SetTarget(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalForwardingRules.SetTarget(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetTarget",
		Version:   meta.Version("beta"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEBetaGlobalForwardingRules.SetTarget(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalForwardingRules.SetTarget(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalForwardingRules.SetTarget(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaGlobalForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// GlobalForwardingRules is an interface that allows for mocking of GlobalForwardingRules.
type GlobalForwardingRules interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ForwardingRule, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.ForwardingRule, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetLabels(context.Context, *meta.Key, *computega.GlobalSetLabelsRequest, ...Option) error
	SetTarget(context.Context, *meta.Key, *computega.TargetReference, ...Option) error
}

// NewMockGlobalForwardingRules returns a new mock for GlobalForwardingRules.
func NewMockGlobalForwardingRules(pr ProjectRouter, objs map[meta.Key]*MockGlobalForwardingRulesObj) *MockGlobalForwardingRules {
	mock := &MockGlobalForwardingRules{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockGlobalForwardingRules is the mock for GlobalForwardingRules.
type MockGlobalForwardingRules struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalForwardingRulesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockGlobalForwardingRules, options ...Option) (bool, *computega.ForwardingRule, error)
	ListHook      func(ctx context.Context, fl *filter.F, m *MockGlobalForwardingRules, options ...Option) (bool, []*computega.ForwardingRule, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, m *MockGlobalForwardingRules, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockGlobalForwardingRules, options ...Option) (bool, error)
	SetLabelsHook func(context.Context, *meta.Key, *computega.GlobalSetLabelsRequest, *MockGlobalForwardingRules, ...Option) error
	SetTargetHook func(context.Context, *meta.Key, *computega.TargetReference, *MockGlobalForwardingRules, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockGlobalForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ForwardingRule, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockGlobalForwardingRules.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockGlobalForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockGlobalForwardingRules.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockGlobalForwardingRules %v not found", key),
	}
	klog.V(5).Infof("MockGlobalForwardingRules.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockGlobalForwardingRules) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.ForwardingRule, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockGlobalForwardingRules.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockGlobalForwardingRules.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.ForwardingRule
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockGlobalForwardingRules.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockGlobalForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockGlobalForwardingRules %v exists", key),
		}
		klog.V(5).Infof("MockGlobalForwardingRules.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "forwardingRules")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "forwardingRules", key)

	m.Objects[*key] = &MockGlobalForwardingRulesObj{obj}
	klog.V(5).Infof("MockGlobalForwardingRules.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockGlobalForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockGlobalForwardingRules %v not found", key),
		}
		klog.V(5).Infof("MockGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockGlobalForwardingRules.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockGlobalForwardingRules) Obj(o *computega.ForwardingRule) *MockGlobalForwardingRulesObj {
	return &MockGlobalForwardingRulesObj{o}
}

// SetLabels is a mock for the corresponding method.
func (m *MockGlobalForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computega.GlobalSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// SetTarget is a mock for the corresponding method.
func (m *MockGlobalForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computega.TargetReference, options ...Option) error {
	if m.SetTargetHook != nil {
		return m.SetTargetHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEGlobalForwardingRules is a simplifying adapter for the GCE GlobalForwardingRules.
type GCEGlobalForwardingRules struct {
	s *Service
}

// Get the ForwardingRule named by key.
func (g *GCEGlobalForwardingRules) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalForwardingRules.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalForwardingRules.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "GlobalForwardingRules",
	}

	klog.V(5).Infof("GCEGlobalForwardingRules.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.GlobalForwardingRules.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEGlobalForwardingRules.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ForwardingRule objects.
func (g *GCEGlobalForwardingRules) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.ForwardingRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalForwardingRules.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "GlobalForwardingRules",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEGlobalForwardingRules.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.GlobalForwardingRules.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.ForwardingRule
	f := func(l *computega.ForwardingRuleList) error {
		klog.V(5).Infof("GCEGlobalForwardingRules.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEGlobalForwardingRules.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEGlobalForwardingRules.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ForwardingRule with key of value obj.
func (g *GCEGlobalForwardingRules) Insert(ctx context.Context, key *meta.Key, obj *computega.ForwardingRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalForwardingRules.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalForwardingRules.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalForwardingRules")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEGlobalForwardingRules.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.GlobalForwardingRules.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEGlobalForwardingRules.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ForwardingRule referenced by key.
func (g *GCEGlobalForwardingRules) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalForwardingRules.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalForwardingRules.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEGlobalForwardingRules.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalForwardingRules.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEGlobalForwardingRules.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetLabels is a method on GCEGlobalForwardingRules.
func (g *GCEGlobalForwardingRules) SetLabels(ctx context.Context, key *meta.Key, arg0 *computega.GlobalSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalForwardingRules.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalForwardingRules.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("ga"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEGlobalForwardingRules.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalForwardingRules.SetLabels(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEGlobalForwardingRules.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetTarget is a method on GCEGlobalForwardingRules.
func (g *GCEGlobalForwardingRules) SetTarget(ctx context.Context, key *meta.Key, arg0 *computega.TargetReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalForwardingRules.SetTarget(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalForwardingRules.SetTarget(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalForwardingRules")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetTarget",
		Version:   meta.Version("ga"),
		Service:   "GlobalForwardingRules",
	}
	klog.V(5).Infof("GCEGlobalForwardingRules.SetTarget(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalForwardingRules.SetTarget(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalForwardingRules.SetTarget(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEGlobalForwardingRules.SetTarget(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// HealthChecks is an interface that allows for mocking of HealthChecks.
type HealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HealthCheck, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computega.HealthCheck, ...Option) error
}

// NewMockHealthChecks returns a new mock for HealthChecks.
func NewMockHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockHealthChecksObj) *MockHealthChecks {
	mock := &MockHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockHealthChecks is the mock for HealthChecks.
type MockHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockHealthChecks, options ...Option) (bool, *computega.HealthCheck, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockHealthChecks, options ...Option) (bool, []*computega.HealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, m *MockHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computega.HealthCheck, *MockHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockHealthChecks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockHealthChecks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.HealthCheck
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockHealthChecks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "healthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "healthChecks", key)

	m.Objects[*key] = &MockHealthChecksObj{obj}
	klog.V(5).Infof("MockHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockHealthChecks) Obj(o *computega.HealthCheck) *MockHealthChecksObj {
	return &MockHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEHealthChecks is a simplifying adapter for the GCE HealthChecks.
type GCEHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "HealthChecks",
	}

	klog.V(5).Infof("GCEHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.HealthChecks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HealthCheck objects.
func (g *GCEHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHealthChecks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "HealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEHealthChecks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.HealthChecks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.HealthCheck
	f := func(l *computega.HealthCheckList) error {
		klog.V(5).Infof("GCEHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.HealthChecks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HealthCheck referenced by key.
func (g *GCEHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.HealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEHealthChecks.
func (g *GCEHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.HealthChecks.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaHealthChecks is an interface that allows for mocking of HealthChecks.
type AlphaHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.HealthCheck, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.HealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computealpha.HealthCheck, ...Option) error
}

// NewMockAlphaHealthChecks returns a new mock for HealthChecks.
func NewMockAlphaHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockHealthChecksObj) *MockAlphaHealthChecks {
	mock := &MockAlphaHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaHealthChecks is the mock for HealthChecks.
type MockAlphaHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaHealthChecks, options ...Option) (bool, *computealpha.HealthCheck, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockAlphaHealthChecks, options ...Option) (bool, []*computealpha.HealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, m *MockAlphaHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computealpha.HealthCheck, *MockAlphaHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockAlphaHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaHealthChecks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaHealthChecks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.HealthCheck
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaHealthChecks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockAlphaHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "healthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "healthChecks", key)

	m.Objects[*key] = &MockHealthChecksObj{obj}
	klog.V(5).Infof("MockAlphaHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockAlphaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaHealthChecks) Obj(o *computealpha.HealthCheck) *MockHealthChecksObj {
	return &MockHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockAlphaHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.HealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaHealthChecks is a simplifying adapter for the GCE HealthChecks.
type GCEAlphaHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEAlphaHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "HealthChecks",
	}

	klog.V(5).Infof("GCEAlphaHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.HealthChecks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HealthCheck objects.
func (g *GCEAlphaHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaHealthChecks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "HealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaHealthChecks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.HealthChecks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.HealthCheck
	f := func(l *computealpha.HealthCheckList) error {
		klog.V(5).Infof("GCEAlphaHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEAlphaHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEAlphaHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.HealthChecks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HealthCheck referenced by key.
func (g *GCEAlphaHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "HealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEAlphaHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.HealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaHealthChecks.
func (g *GCEAlphaHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "HealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEAlphaHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.HealthChecks.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaHealthChecks is an interface that allows for mocking of HealthChecks.
type BetaHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.HealthCheck, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.HealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computebeta.HealthCheck, ...Option) error
}

// NewMockBetaHealthChecks returns a new mock for HealthChecks.
func NewMockBetaHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockHealthChecksObj) *MockBetaHealthChecks {
	mock := &MockBetaHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaHealthChecks is the mock for HealthChecks.
type MockBetaHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaHealthChecks, options ...Option) (bool, *computebeta.HealthCheck, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaHealthChecks, options ...Option) (bool, []*computebeta.HealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, m *MockBetaHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computebeta.HealthCheck, *MockBetaHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockBetaHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaHealthChecks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaHealthChecks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.HealthCheck
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaHealthChecks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockBetaHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "healthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "healthChecks", key)

	m.Objects[*key] = &MockHealthChecksObj{obj}
	klog.V(5).Infof("MockBetaHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockBetaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaHealthChecks) Obj(o *computebeta.HealthCheck) *MockHealthChecksObj {
	return &MockHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockBetaHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.HealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaHealthChecks is a simplifying adapter for the GCE HealthChecks.
type GCEBetaHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEBetaHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "HealthChecks",
	}

	klog.V(5).Infof("GCEBetaHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.HealthChecks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HealthCheck objects.
func (g *GCEBetaHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaHealthChecks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "HealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaHealthChecks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.HealthChecks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.HealthCheck
	f := func(l *computebeta.HealthCheckList) error {
		klog.V(5).Infof("GCEBetaHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEBetaHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "HealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEBetaHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.HealthChecks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HealthCheck referenced by key.
func (g *GCEBetaHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "HealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEBetaHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.HealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaHealthChecks.
func (g *GCEBetaHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "HealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "HealthChecks",
	}
	klog.V(5).Infof("GCEBetaHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.HealthChecks.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaRegionHealthChecks is an interface that allows for mocking of RegionHealthChecks.
type AlphaRegionHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.HealthCheck, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.HealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computealpha.HealthCheck, ...Option) error
}

// NewMockAlphaRegionHealthChecks returns a new mock for RegionHealthChecks.
func NewMockAlphaRegionHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockRegionHealthChecksObj) *MockAlphaRegionHealthChecks {
	mock := &MockAlphaRegionHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionHealthChecks is the mock for RegionHealthChecks.
type MockAlphaRegionHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaRegionHealthChecks, options ...Option) (bool, *computealpha.HealthCheck, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionHealthChecks, options ...Option) (bool, []*computealpha.HealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, m *MockAlphaRegionHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaRegionHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computealpha.HealthCheck, *MockAlphaRegionHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionHealthChecks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionHealthChecks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionHealthChecks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.HealthCheck
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionHealthChecks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "healthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "healthChecks", key)

	m.Objects[*key] = &MockRegionHealthChecksObj{obj}
	klog.V(5).Infof("MockAlphaRegionHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionHealthChecks) Obj(o *computealpha.HealthCheck) *MockRegionHealthChecksObj {
	return &MockRegionHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockAlphaRegionHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.HealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaRegionHealthChecks is a simplifying adapter for the GCE RegionHealthChecks.
type GCEAlphaRegionHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEAlphaRegionHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionHealthChecks",
	}

	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionHealthChecks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HealthCheck objects.
func (g *GCEAlphaRegionHealthChecks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionHealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionHealthChecks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.HealthCheck
	f := func(l *computealpha.HealthCheckList) error {
		klog.V(5).Infof("GCEAlphaRegionHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEAlphaRegionHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionHealthChecks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HealthCheck referenced by key.
func (g *GCEAlphaRegionHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionHealthChecks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaRegionHealthChecks.
func (g *GCEAlphaRegionHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCEAlphaRegionHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionHealthChecks.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaRegionHealthChecks is an interface that allows for mocking of RegionHealthChecks.
type BetaRegionHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.HealthCheck, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.HealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computebeta.HealthCheck, ...Option) error
}

// NewMockBetaRegionHealthChecks returns a new mock for RegionHealthChecks.
func NewMockBetaRegionHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockRegionHealthChecksObj) *MockBetaRegionHealthChecks {
	mock := &MockBetaRegionHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRegionHealthChecks is the mock for RegionHealthChecks.
type MockBetaRegionHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaRegionHealthChecks, options ...Option) (bool, *computebeta.HealthCheck, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockBetaRegionHealthChecks, options ...Option) (bool, []*computebeta.HealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, m *MockBetaRegionHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaRegionHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computebeta.HealthCheck, *MockBetaRegionHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRegionHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRegionHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRegionHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockBetaRegionHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRegionHealthChecks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionHealthChecks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRegionHealthChecks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.HealthCheck
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRegionHealthChecks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRegionHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRegionHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockBetaRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "healthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "healthChecks", key)

	m.Objects[*key] = &MockRegionHealthChecksObj{obj}
	klog.V(5).Infof("MockBetaRegionHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRegionHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRegionHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockBetaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRegionHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRegionHealthChecks) Obj(o *computebeta.HealthCheck) *MockRegionHealthChecksObj {
	return &MockRegionHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockBetaRegionHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.HealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaRegionHealthChecks is a simplifying adapter for the GCE RegionHealthChecks.
type GCEBetaRegionHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCEBetaRegionHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "RegionHealthChecks",
	}

	klog.V(5).Infof("GCEBetaRegionHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionHealthChecks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRegionHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HealthCheck objects.
func (g *GCEBetaRegionHealthChecks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionHealthChecks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "RegionHealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRegionHealthChecks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.RegionHealthChecks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.HealthCheck
	f := func(l *computebeta.HealthCheckList) error {
		klog.V(5).Infof("GCEBetaRegionHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRegionHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCEBetaRegionHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.RegionHealthChecks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HealthCheck referenced by key.
func (g *GCEBetaRegionHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionHealthChecks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaRegionHealthChecks.
func (g *GCEBetaRegionHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCEBetaRegionHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionHealthChecks.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RegionHealthChecks is an interface that allows for mocking of RegionHealthChecks.
type RegionHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HealthCheck, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.HealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computega.HealthCheck, ...Option) error
}

// NewMockRegionHealthChecks returns a new mock for RegionHealthChecks.
func NewMockRegionHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockRegionHealthChecksObj) *MockRegionHealthChecks {
	mock := &MockRegionHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionHealthChecks is the mock for RegionHealthChecks.
type MockRegionHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockRegionHealthChecks, options ...Option) (bool, *computega.HealthCheck, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockRegionHealthChecks, options ...Option) (bool, []*computega.HealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, m *MockRegionHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockRegionHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computega.HealthCheck, *MockRegionHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockRegionHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionHealthChecks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.HealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionHealthChecks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionHealthChecks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.HealthCheck
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionHealthChecks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockRegionHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "healthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "healthChecks", key)

	m.Objects[*key] = &MockRegionHealthChecksObj{obj}
	klog.V(5).Infof("MockRegionHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockRegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionHealthChecks) Obj(o *computega.HealthCheck) *MockRegionHealthChecksObj {
	return &MockRegionHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockRegionHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCERegionHealthChecks is a simplifying adapter for the GCE RegionHealthChecks.
type GCERegionHealthChecks struct {
	s *Service
}

// Get the HealthCheck named by key.
func (g *GCERegionHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionHealthChecks",
	}

	klog.V(5).Infof("GCERegionHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionHealthChecks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HealthCheck objects.
func (g *GCERegionHealthChecks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.HealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionHealthChecks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionHealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionHealthChecks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionHealthChecks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.HealthCheck
	f := func(l *computega.HealthCheckList) error {
		klog.V(5).Infof("GCERegionHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HealthCheck with key of value obj.
func (g *GCERegionHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCERegionHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionHealthChecks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HealthCheck referenced by key.
func (g *GCERegionHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCERegionHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionHealthChecks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCERegionHealthChecks.
func (g *GCERegionHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "RegionHealthChecks",
	}
	klog.V(5).Infof("GCERegionHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionHealthChecks.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// HttpHealthChecks is an interface that allows for mocking of HttpHealthChecks.
type HttpHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HttpHealthCheck, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HttpHealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.HttpHealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computega.HttpHealthCheck, ...Option) error
}

// NewMockHttpHealthChecks returns a new mock for HttpHealthChecks.
func NewMockHttpHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockHttpHealthChecksObj) *MockHttpHealthChecks {
	mock := &MockHttpHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockHttpHealthChecks is the mock for HttpHealthChecks.
type MockHttpHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockHttpHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockHttpHealthChecks, options ...Option) (bool, *computega.HttpHealthCheck, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockHttpHealthChecks, options ...Option) (bool, []*computega.HttpHealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.HttpHealthCheck, m *MockHttpHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockHttpHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computega.HttpHealthCheck, *MockHttpHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockHttpHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HttpHealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockHttpHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockHttpHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockHttpHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockHttpHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockHttpHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockHttpHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HttpHealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockHttpHealthChecks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockHttpHealthChecks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.HttpHealthCheck
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockHttpHealthChecks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockHttpHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HttpHealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockHttpHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockHttpHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockHttpHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockHttpHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "httpHealthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "httpHealthChecks", key)

	m.Objects[*key] = &MockHttpHealthChecksObj{obj}
	klog.V(5).Infof("MockHttpHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockHttpHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockHttpHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockHttpHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockHttpHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockHttpHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockHttpHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockHttpHealthChecks) Obj(o *computega.HttpHealthCheck) *MockHttpHealthChecksObj {
	return &MockHttpHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockHttpHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HttpHealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEHttpHealthChecks is a simplifying adapter for the GCE HttpHealthChecks.
type GCEHttpHealthChecks struct {
	s *Service
}

// Get the HttpHealthCheck named by key.
func (g *GCEHttpHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HttpHealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEHttpHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "HttpHealthChecks",
	}

	klog.V(5).Infof("GCEHttpHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.HttpHealthChecks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEHttpHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HttpHealthCheck objects.
func (g *GCEHttpHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HttpHealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpHealthChecks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "HttpHealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEHttpHealthChecks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.HttpHealthChecks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.HttpHealthCheck
	f := func(l *computega.HttpHealthCheckList) error {
		klog.V(5).Infof("GCEHttpHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEHttpHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEHttpHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEHttpHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HttpHealthCheck with key of value obj.
func (g *GCEHttpHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HttpHealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEHttpHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "HttpHealthChecks",
	}
	klog.V(5).Infof("GCEHttpHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.HttpHealthChecks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEHttpHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEHttpHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HttpHealthCheck referenced by key.
func (g *GCEHttpHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEHttpHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "HttpHealthChecks",
	}
	klog.V(5).Infof("GCEHttpHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.HttpHealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEHttpHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEHttpHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEHttpHealthChecks.
func (g *GCEHttpHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HttpHealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEHttpHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "HttpHealthChecks",
	}
	klog.V(5).Infof("GCEHttpHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.HttpHealthChecks.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEHttpHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEHttpHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// HttpsHealthChecks is an interface that allows for mocking of HttpsHealthChecks.
type HttpsHealthChecks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HttpsHealthCheck, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HttpsHealthCheck, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.HttpsHealthCheck, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computega.HttpsHealthCheck, ...Option) error
}

// NewMockHttpsHealthChecks returns a new mock for HttpsHealthChecks.
func NewMockHttpsHealthChecks(pr ProjectRouter, objs map[meta.Key]*MockHttpsHealthChecksObj) *MockHttpsHealthChecks {
	mock := &MockHttpsHealthChecks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockHttpsHealthChecks is the mock for HttpsHealthChecks.
type MockHttpsHealthChecks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockHttpsHealthChecksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockHttpsHealthChecks, options ...Option) (bool, *computega.HttpsHealthCheck, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockHttpsHealthChecks, options ...Option) (bool, []*computega.HttpsHealthCheck, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.HttpsHealthCheck, m *MockHttpsHealthChecks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockHttpsHealthChecks, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computega.HttpsHealthCheck, *MockHttpsHealthChecks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockHttpsHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HttpsHealthCheck, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockHttpsHealthChecks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockHttpsHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockHttpsHealthChecks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockHttpsHealthChecks %v not found", key),
	}
	klog.V(5).Infof("MockHttpsHealthChecks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockHttpsHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HttpsHealthCheck, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockHttpsHealthChecks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockHttpsHealthChecks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.HttpsHealthCheck
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockHttpsHealthChecks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockHttpsHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HttpsHealthCheck, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockHttpsHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockHttpsHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockHttpsHealthChecks %v exists", key),
		}
		klog.V(5).Infof("MockHttpsHealthChecks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "httpsHealthChecks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "httpsHealthChecks", key)

	m.Objects[*key] = &MockHttpsHealthChecksObj{obj}
	klog.V(5).Infof("MockHttpsHealthChecks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockHttpsHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockHttpsHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockHttpsHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockHttpsHealthChecks %v not found", key),
		}
		klog.V(5).Infof("MockHttpsHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockHttpsHealthChecks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockHttpsHealthChecks) Obj(o *computega.HttpsHealthCheck) *MockHttpsHealthChecksObj {
	return &MockHttpsHealthChecksObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockHttpsHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HttpsHealthCheck, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEHttpsHealthChecks is a simplifying adapter for the GCE HttpsHealthChecks.
type GCEHttpsHealthChecks struct {
	s *Service
}

// Get the HttpsHealthCheck named by key.
func (g *GCEHttpsHealthChecks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.HttpsHealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpsHealthChecks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEHttpsHealthChecks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpsHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "HttpsHealthChecks",
	}

	klog.V(5).Infof("GCEHttpsHealthChecks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpsHealthChecks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.HttpsHealthChecks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEHttpsHealthChecks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all HttpsHealthCheck objects.
func (g *GCEHttpsHealthChecks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.HttpsHealthCheck, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpsHealthChecks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpsHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "HttpsHealthChecks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEHttpsHealthChecks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.HttpsHealthChecks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.HttpsHealthCheck
	f := func(l *computega.HttpsHealthCheckList) error {
		klog.V(5).Infof("GCEHttpsHealthChecks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEHttpsHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEHttpsHealthChecks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEHttpsHealthChecks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert HttpsHealthCheck with key of value obj.
func (g *GCEHttpsHealthChecks) Insert(ctx context.Context, key *meta.Key, obj *computega.HttpsHealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpsHealthChecks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEHttpsHealthChecks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpsHealthChecks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "HttpsHealthChecks",
	}
	klog.V(5).Infof("GCEHttpsHealthChecks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpsHealthChecks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.HttpsHealthChecks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEHttpsHealthChecks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEHttpsHealthChecks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the HttpsHealthCheck referenced by key.
func (g *GCEHttpsHealthChecks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpsHealthChecks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEHttpsHealthChecks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpsHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "HttpsHealthChecks",
	}
	klog.V(5).Infof("GCEHttpsHealthChecks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpsHealthChecks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.HttpsHealthChecks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEHttpsHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEHttpsHealthChecks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEHttpsHealthChecks.
func (g *GCEHttpsHealthChecks) Update(ctx context.Context, key *meta.Key, arg0 *computega.HttpsHealthCheck, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEHttpsHealthChecks.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEHttpsHealthChecks.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "HttpsHealthChecks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "HttpsHealthChecks",
	}
	klog.V(5).Infof("GCEHttpsHealthChecks.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEHttpsHealthChecks.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.HttpsHealthChecks.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEHttpsHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEHttpsHealthChecks.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// InstanceGroups is an interface that allows for mocking of InstanceGroups.
type InstanceGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceGroup, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.InstanceGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AddInstances(context.Context, *meta.Key, *computega.InstanceGroupsAddInstancesRequest, ...Option) error
	ListInstances(context.Context, *meta.Key, *computega.InstanceGroupsListInstancesRequest, *filter.F, ...Option) ([]*computega.InstanceWithNamedPorts, error)
	RemoveInstances(context.Context, *meta.Key, *computega.InstanceGroupsRemoveInstancesRequest, ...Option) error
	SetNamedPorts(context.Context, *meta.Key, *computega.InstanceGroupsSetNamedPortsRequest, ...Option) error
}

// NewMockInstanceGroups returns a new mock for InstanceGroups.
func NewMockInstanceGroups(pr ProjectRouter, objs map[meta.Key]*MockInstanceGroupsObj) *MockInstanceGroups {
	mock := &MockInstanceGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockInstanceGroups is the mock for InstanceGroups.
type MockInstanceGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockInstanceGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook             func(ctx context.Context, key *meta.Key, m *MockInstanceGroups, options ...Option) (bool, *computega.InstanceGroup, error)
	ListHook            func(ctx context.Context, zone string, fl *filter.F, m *MockInstanceGroups, options ...Option) (bool, []*computega.InstanceGroup, error)
	InsertHook          func(ctx context.Context, key *meta.Key, obj *computega.InstanceGroup, m *MockInstanceGroups, options ...Option) (bool, error)
	DeleteHook          func(ctx context.Context, key *meta.Key, m *MockInstanceGroups, options ...Option) (bool, error)
	AddInstancesHook    func(context.Context, *meta.Key, *computega.InstanceGroupsAddInstancesRequest, *MockInstanceGroups, ...Option) error
	ListInstancesHook   func(context.Context, *meta.Key, *computega.InstanceGroupsListInstancesRequest, *filter.F, *MockInstanceGroups, ...Option) ([]*computega.InstanceWithNamedPorts, error)
	RemoveInstancesHook func(context.Context, *meta.Key, *computega.InstanceGroupsRemoveInstancesRequest, *MockInstanceGroups, ...Option) error
	SetNamedPortsHook   func(context.Context, *meta.Key, *computega.InstanceGroupsSetNamedPortsRequest, *MockInstanceGroups, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockInstanceGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockInstanceGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockInstanceGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockInstanceGroups %v not found", key),
	}
	klog.V(5).Infof("MockInstanceGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockInstanceGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.InstanceGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroups.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockInstanceGroups.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.InstanceGroup
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockInstanceGroups.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockInstanceGroups) Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockInstanceGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockInstanceGroups %v exists", key),
		}
		klog.V(5).Infof("MockInstanceGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "instanceGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "instanceGroups", key)

	m.Objects[*key] = &MockInstanceGroupsObj{obj}
	klog.V(5).Infof("MockInstanceGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockInstanceGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockInstanceGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockInstanceGroups %v not found", key),
		}
		klog.V(5).Infof("MockInstanceGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockInstanceGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockInstanceGroups) Obj(o *computega.InstanceGroup) *MockInstanceGroupsObj {
	return &MockInstanceGroupsObj{o}
}

// AddInstances is a mock for the corresponding method.
func (m *MockInstanceGroups) AddInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsAddInstancesRequest, options ...Option) error {
	if m.AddInstancesHook != nil {
		return m.AddInstancesHook(ctx, key, arg0, m)
	}
	return nil
}

// ListInstances is a mock for the corresponding method.
func (m *MockInstanceGroups) ListInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsListInstancesRequest, fl *filter.F, options ...Option) ([]*computega.InstanceWithNamedPorts, error) {
	if m.ListInstancesHook != nil {
		return m.ListInstancesHook(ctx, key, arg0, fl, m)
	}
	return nil, nil
}

// RemoveInstances is a mock for the corresponding method.
func (m *MockInstanceGroups) RemoveInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsRemoveInstancesRequest, options ...Option) error {
	if m.RemoveInstancesHook != nil {
		return m.RemoveInstancesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetNamedPorts is a mock for the corresponding method.
func (m *MockInstanceGroups) SetNamedPorts(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsSetNamedPortsRequest, options ...Option) error {
	if m.SetNamedPortsHook != nil {
		return m.SetNamedPortsHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEInstanceGroups is a simplifying adapter for the GCE InstanceGroups.
type GCEInstanceGroups struct {
	s *Service
}

// Get the InstanceGroup named by key.
func (g *GCEInstanceGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}

	klog.V(5).Infof("GCEInstanceGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.InstanceGroups.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEInstanceGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all InstanceGroup objects.
func (g *GCEInstanceGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.InstanceGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEInstanceGroups.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.GA.InstanceGroups.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.InstanceGroup
	f := func(l *computega.InstanceGroupList) error {
		klog.V(5).Infof("GCEInstanceGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEInstanceGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEInstanceGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert InstanceGroup with key of value obj.
func (g *GCEInstanceGroups) Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}
	klog.V(5).Infof("GCEInstanceGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.InstanceGroups.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstanceGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstanceGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the InstanceGroup referenced by key.
func (g *GCEInstanceGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}
	klog.V(5).Infof("GCEInstanceGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroups.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstanceGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstanceGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AddInstances is a method on GCEInstanceGroups.
func (g *GCEInstanceGroups) AddInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsAddInstancesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.AddInstances(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.AddInstances(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddInstances",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}
	klog.V(5).Infof("GCEInstanceGroups.AddInstances(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.AddInstances(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroups.AddInstances(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroups.AddInstances(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroups.AddInstances(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListInstances is a method on GCEInstanceGroups.
func (g *GCEInstanceGroups) ListInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsListInstancesRequest, fl *filter.F, options ...Option) ([]*computega.InstanceWithNamedPorts, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.ListInstances(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.ListInstances(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListInstances",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}
	klog.V(5).Infof("GCEInstanceGroups.ListInstances(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.ListInstances(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.InstanceGroups.ListInstances(projectID, key.Zone, key.Name, arg0)
	var all []*computega.InstanceWithNamedPorts
	f := func(l *computega.InstanceGroupsListInstances) error {
		klog.V(5).Infof("GCEInstanceGroups.ListInstances(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroups.ListInstances(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEInstanceGroups.ListInstances(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEInstanceGroups.ListInstances(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// RemoveInstances is a method on GCEInstanceGroups.
func (g *GCEInstanceGroups) RemoveInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsRemoveInstancesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.RemoveInstances(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.RemoveInstances(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveInstances",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}
	klog.V(5).Infof("GCEInstanceGroups.RemoveInstances(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.RemoveInstances(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroups.RemoveInstances(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroups.RemoveInstances(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroups.RemoveInstances(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetNamedPorts is a method on GCEInstanceGroups.
func (g *GCEInstanceGroups) SetNamedPorts(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupsSetNamedPortsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroups.SetNamedPorts(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroups.SetNamedPorts(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetNamedPorts",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroups",
	}
	klog.V(5).Infof("GCEInstanceGroups.SetNamedPorts(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroups.SetNamedPorts(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroups.SetNamedPorts(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroups.SetNamedPorts(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroups.SetNamedPorts(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Instances is an interface that allows for mocking of Instances.
type Instances interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Instance, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.Instance, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Instance, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AttachDisk(context.Context, *meta.Key, *computega.AttachedDisk, ...Option) error
	DetachDisk(context.Context, *meta.Key, string, ...Option) error
}

// NewMockInstances returns a new mock for Instances.
func NewMockInstances(pr ProjectRouter, objs map[meta.Key]*MockInstancesObj) *MockInstances {
	mock := &MockInstances{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockInstances is the mock for Instances.
type MockInstances struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockInstancesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook        func(ctx context.Context, key *meta.Key, m *MockInstances, options ...Option) (bool, *computega.Instance, error)
	ListHook       func(ctx context.Context, zone string, fl *filter.F, m *MockInstances, options ...Option) (bool, []*computega.Instance, error)
	InsertHook     func(ctx context.Context, key *meta.Key, obj *computega.Instance, m *MockInstances, options ...Option) (bool, error)
	DeleteHook     func(ctx context.Context, key *meta.Key, m *MockInstances, options ...Option) (bool, error)
	AttachDiskHook func(context.Context, *meta.Key, *computega.AttachedDisk, *MockInstances, ...Option) error
	DetachDiskHook func(context.Context, *meta.Key, string, *MockInstances, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockInstances) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Instance, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstances.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockInstances.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockInstances.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockInstances %v not found", key),
	}
	klog.V(5).Infof("MockInstances.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockInstances) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.Instance, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockInstances.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockInstances.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Instance
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockInstances.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockInstances) Insert(ctx context.Context, key *meta.Key, obj *computega.Instance, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockInstances %v exists", key),
		}
		klog.V(5).Infof("MockInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "instances")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "instances", key)

	m.Objects[*key] = &MockInstancesObj{obj}
	klog.V(5).Infof("MockInstances.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockInstances) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstances.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockInstances %v not found", key),
		}
		klog.V(5).Infof("MockInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockInstances.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockInstances) Obj(o *computega.Instance) *MockInstancesObj {
	return &MockInstancesObj{o}
}

// AttachDisk is a mock for the corresponding method.
func (m *MockInstances) AttachDisk(ctx context.Context, key *meta.Key, arg0 *computega.AttachedDisk, options ...Option) error {
	if m.AttachDiskHook != nil {
		return m.AttachDiskHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachDisk is a mock for the corresponding method.
func (m *MockInstances) DetachDisk(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	if m.DetachDiskHook != nil {
		return m.DetachDiskHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEInstances is a simplifying adapter for the GCE Instances.
type GCEInstances struct {
	s *Service
}

// Get the Instance named by key.
func (g *GCEInstances) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Instance, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstances.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstances.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Instances",
	}

	klog.V(5).Infof("GCEInstances.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstances.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Instances.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEInstances.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Instance objects.
func (g *GCEInstances) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.Instance, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstances.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Instances",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEInstances.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.GA.Instances.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Instance
	f := func(l *computega.InstanceList) error {
		klog.V(5).Infof("GCEInstances.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstances.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEInstances.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEInstances.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Instance with key of value obj.
func (g *GCEInstances) Insert(ctx context.Context, key *meta.Key, obj *computega.Instance, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstances.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstances.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEInstances.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstances.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Instances.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstances.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstances.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Instance referenced by key.
func (g *GCEInstances) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstances.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstances.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEInstances.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstances.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Instances.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstances.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AttachDisk is a method on GCEInstances.
func (g *GCEInstances) AttachDisk(ctx context.Context, key *meta.Key, arg0 *computega.AttachedDisk, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstances.AttachDisk(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstances.AttachDisk(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachDisk",
		Version:   meta.Version("ga"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEInstances.AttachDisk(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstances.AttachDisk(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Instances.AttachDisk(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstances.AttachDisk(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstances.AttachDisk(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachDisk is a method on GCEInstances.
func (g *GCEInstances) DetachDisk(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstances.DetachDisk(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstances.DetachDisk(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachDisk",
		Version:   meta.Version("ga"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEInstances.DetachDisk(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstances.DetachDisk(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Instances.DetachDisk(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstances.DetachDisk(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstances.DetachDisk(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaInstances is an interface that allows for mocking of Instances.
type BetaInstances interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Instance, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computebeta.Instance, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Instance, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AttachDisk(context.Context, *meta.Key, *computebeta.AttachedDisk, ...Option) error
	DetachDisk(context.Context, *meta.Key, string, ...Option) error
	UpdateNetworkInterface(context.Context, *meta.Key, string, *computebeta.NetworkInterface, ...Option) error
}

// NewMockBetaInstances returns a new mock for Instances.
func NewMockBetaInstances(pr ProjectRouter, objs map[meta.Key]*MockInstancesObj) *MockBetaInstances {
	mock := &MockBetaInstances{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaInstances is the mock for Instances.
type MockBetaInstances struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockInstancesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockBetaInstances, options ...Option) (bool, *computebeta.Instance, error)
	ListHook                   func(ctx context.Context, zone string, fl *filter.F, m *MockBetaInstances, options ...Option) (bool, []*computebeta.Instance, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computebeta.Instance, m *MockBetaInstances, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockBetaInstances, options ...Option) (bool, error)
	AttachDiskHook             func(context.Context, *meta.Key, *computebeta.AttachedDisk, *MockBetaInstances, ...Option) error
	DetachDiskHook             func(context.Context, *meta.Key, string, *MockBetaInstances, ...Option) error
	UpdateNetworkInterfaceHook func(context.Context, *meta.Key, string, *computebeta.NetworkInterface, *MockBetaInstances, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaInstances) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Instance, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaInstances.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaInstances.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaInstances.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaInstances %v not found", key),
	}
	klog.V(5).Infof("MockBetaInstances.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockBetaInstances) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computebeta.Instance, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaInstances.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaInstances.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Instance
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaInstances.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaInstances) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Instance, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaInstances %v exists", key),
		}
		klog.V(5).Infof("MockBetaInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "instances")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "instances", key)

	m.Objects[*key] = &MockInstancesObj{obj}
	klog.V(5).Infof("MockBetaInstances.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaInstances) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaInstances.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaInstances %v not found", key),
		}
		klog.V(5).Infof("MockBetaInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaInstances.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaInstances) Obj(o *computebeta.Instance) *MockInstancesObj {
	return &MockInstancesObj{o}
}

// AttachDisk is a mock for the corresponding method.
func (m *MockBetaInstances) AttachDisk(ctx context.Context, key *meta.Key, arg0 *computebeta.AttachedDisk, options ...Option) error {
	if m.AttachDiskHook != nil {
		return m.AttachDiskHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachDisk is a mock for the corresponding method.
func (m *MockBetaInstances) DetachDisk(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	if m.DetachDiskHook != nil {
		return m.DetachDiskHook(ctx, key, arg0, m)
	}
	return nil
}

// UpdateNetworkInterface is a mock for the corresponding method.
func (m *MockBetaInstances) UpdateNetworkInterface(ctx context.Context, key *meta.Key, arg0 string, arg1 *computebeta.NetworkInterface, options ...Option) error {
	if m.UpdateNetworkInterfaceHook != nil {
		return m.UpdateNetworkInterfaceHook(ctx, key, arg0, arg1, m)
	}
	return nil
}

// GCEBetaInstances is a simplifying adapter for the GCE Instances.
type GCEBetaInstances struct {
	s *Service
}

// Get the Instance named by key.
func (g *GCEBetaInstances) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Instance, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaInstances.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}

	klog.V(5).Infof("GCEBetaInstances.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaInstances.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Instances.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaInstances.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Instance objects.
func (g *GCEBetaInstances) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computebeta.Instance, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaInstances.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.Beta.Instances.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Instance
	f := func(l *computebeta.InstanceList) error {
		klog.V(5).Infof("GCEBetaInstances.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaInstances.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaInstances.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaInstances.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Instance with key of value obj.
func (g *GCEBetaInstances) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Instance, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaInstances.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEBetaInstances.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaInstances.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Instances.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaInstances.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaInstances.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Instance referenced by key.
func (g *GCEBetaInstances) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaInstances.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEBetaInstances.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaInstances.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Instances.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaInstances.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AttachDisk is a method on GCEBetaInstances.
func (g *GCEBetaInstances) AttachDisk(ctx context.Context, key *meta.Key, arg0 *computebeta.AttachedDisk, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.AttachDisk(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaInstances.AttachDisk(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachDisk",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEBetaInstances.AttachDisk(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaInstances.AttachDisk(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Instances.AttachDisk(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaInstances.AttachDisk(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaInstances.AttachDisk(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachDisk is a method on GCEBetaInstances.
func (g *GCEBetaInstances) DetachDisk(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.DetachDisk(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaInstances.DetachDisk(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachDisk",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEBetaInstances.DetachDisk(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaInstances.DetachDisk(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Instances.DetachDisk(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaInstances.DetachDisk(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaInstances.DetachDisk(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// UpdateNetworkInterface is a method on GCEBetaInstances.
func (g *GCEBetaInstances) UpdateNetworkInterface(ctx context.Context, key *meta.Key, arg0 string, arg1 *computebeta.NetworkInterface, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaInstances.UpdateNetworkInterface(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaInstances.UpdateNetworkInterface(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "UpdateNetworkInterface",
		Version:   meta.Version("beta"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEBetaInstances.UpdateNetworkInterface(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaInstances.UpdateNetworkInterface(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Instances.UpdateNetworkInterface(projectID, key.Zone, key.Name, arg0, arg1)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaInstances.UpdateNetworkInterface(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaInstances.UpdateNetworkInterface(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaInstances is an interface that allows for mocking of Instances.
type AlphaInstances interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Instance, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computealpha.Instance, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Instance, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AttachDisk(context.Context, *meta.Key, *computealpha.AttachedDisk, ...Option) error
	DetachDisk(context.Context, *meta.Key, string, ...Option) error
	UpdateNetworkInterface(context.Context, *meta.Key, string, *computealpha.NetworkInterface, ...Option) error
}

// NewMockAlphaInstances returns a new mock for Instances.
func NewMockAlphaInstances(pr ProjectRouter, objs map[meta.Key]*MockInstancesObj) *MockAlphaInstances {
	mock := &MockAlphaInstances{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaInstances is the mock for Instances.
type MockAlphaInstances struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockInstancesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockAlphaInstances, options ...Option) (bool, *computealpha.Instance, error)
	ListHook                   func(ctx context.Context, zone string, fl *filter.F, m *MockAlphaInstances, options ...Option) (bool, []*computealpha.Instance, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computealpha.Instance, m *MockAlphaInstances, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockAlphaInstances, options ...Option) (bool, error)
	AttachDiskHook             func(context.Context, *meta.Key, *computealpha.AttachedDisk, *MockAlphaInstances, ...Option) error
	DetachDiskHook             func(context.Context, *meta.Key, string, *MockAlphaInstances, ...Option) error
	UpdateNetworkInterfaceHook func(context.Context, *meta.Key, string, *computealpha.NetworkInterface, *MockAlphaInstances, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaInstances) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Instance, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaInstances.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaInstances.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaInstances.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaInstances %v not found", key),
	}
	klog.V(5).Infof("MockAlphaInstances.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockAlphaInstances) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computealpha.Instance, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaInstances.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaInstances.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Instance
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaInstances.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaInstances) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Instance, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaInstances %v exists", key),
		}
		klog.V(5).Infof("MockAlphaInstances.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "instances")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "instances", key)

	m.Objects[*key] = &MockInstancesObj{obj}
	klog.V(5).Infof("MockAlphaInstances.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaInstances) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaInstances.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaInstances %v not found", key),
		}
		klog.V(5).Infof("MockAlphaInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaInstances.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaInstances) Obj(o *computealpha.Instance) *MockInstancesObj {
	return &MockInstancesObj{o}
}

// AttachDisk is a mock for the corresponding method.
func (m *MockAlphaInstances) AttachDisk(ctx context.Context, key *meta.Key, arg0 *computealpha.AttachedDisk, options ...Option) error {
	if m.AttachDiskHook != nil {
		return m.AttachDiskHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachDisk is a mock for the corresponding method.
func (m *MockAlphaInstances) DetachDisk(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	if m.DetachDiskHook != nil {
		return m.DetachDiskHook(ctx, key, arg0, m)
	}
	return nil
}

// UpdateNetworkInterface is a mock for the corresponding method.
func (m *MockAlphaInstances) UpdateNetworkInterface(ctx context.Context, key *meta.Key, arg0 string, arg1 *computealpha.NetworkInterface, options ...Option) error {
	if m.UpdateNetworkInterfaceHook != nil {
		return m.UpdateNetworkInterfaceHook(ctx, key, arg0, arg1, m)
	}
	return nil
}

// GCEAlphaInstances is a simplifying adapter for the GCE Instances.
type GCEAlphaInstances struct {
	s *Service
}

// Get the Instance named by key.
func (g *GCEAlphaInstances) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Instance, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaInstances.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}

	klog.V(5).Infof("GCEAlphaInstances.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaInstances.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Instances.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaInstances.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Instance objects.
func (g *GCEAlphaInstances) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computealpha.Instance, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaInstances.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.Alpha.Instances.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Instance
	f := func(l *computealpha.InstanceList) error {
		klog.V(5).Infof("GCEAlphaInstances.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaInstances.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaInstances.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaInstances.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Instance with key of value obj.
func (g *GCEAlphaInstances) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Instance, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaInstances.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEAlphaInstances.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaInstances.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Instances.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaInstances.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaInstances.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Instance referenced by key.
func (g *GCEAlphaInstances) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaInstances.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEAlphaInstances.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaInstances.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Instances.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaInstances.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaInstances.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AttachDisk is a method on GCEAlphaInstances.
func (g *GCEAlphaInstances) AttachDisk(ctx context.Context, key *meta.Key, arg0 *computealpha.AttachedDisk, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.AttachDisk(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaInstances.AttachDisk(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachDisk",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEAlphaInstances.AttachDisk(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaInstances.AttachDisk(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Instances.AttachDisk(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaInstances.AttachDisk(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaInstances.AttachDisk(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachDisk is a method on GCEAlphaInstances.
func (g *GCEAlphaInstances) DetachDisk(ctx context.Context, key *meta.Key, arg0 string, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.DetachDisk(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaInstances.DetachDisk(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachDisk",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEAlphaInstances.DetachDisk(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaInstances.DetachDisk(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Instances.DetachDisk(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaInstances.DetachDisk(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaInstances.DetachDisk(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// UpdateNetworkInterface is a method on GCEAlphaInstances.
func (g *GCEAlphaInstances) UpdateNetworkInterface(ctx context.Context, key *meta.Key, arg0 string, arg1 *computealpha.NetworkInterface, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaInstances.UpdateNetworkInterface(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaInstances.UpdateNetworkInterface(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Instances")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "UpdateNetworkInterface",
		Version:   meta.Version("alpha"),
		Service:   "Instances",
	}
	klog.V(5).Infof("GCEAlphaInstances.UpdateNetworkInterface(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaInstances.UpdateNetworkInterface(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Instances.UpdateNetworkInterface(projectID, key.Zone, key.Name, arg0, arg1)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaInstances.UpdateNetworkInterface(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaInstances.UpdateNetworkInterface(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// InstanceGroupManagers is an interface that allows for mocking of InstanceGroupManagers.
type InstanceGroupManagers interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceGroupManager, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.InstanceGroupManager, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceGroupManager, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	CreateInstances(context.Context, *meta.Key, *computega.InstanceGroupManagersCreateInstancesRequest, ...Option) error
	DeleteInstances(context.Context, *meta.Key, *computega.InstanceGroupManagersDeleteInstancesRequest, ...Option) error
	Resize(context.Context, *meta.Key, int64, ...Option) error
	SetInstanceTemplate(context.Context, *meta.Key, *computega.InstanceGroupManagersSetInstanceTemplateRequest, ...Option) error
}

// NewMockInstanceGroupManagers returns a new mock for InstanceGroupManagers.
func NewMockInstanceGroupManagers(pr ProjectRouter, objs map[meta.Key]*MockInstanceGroupManagersObj) *MockInstanceGroupManagers {
	mock := &MockInstanceGroupManagers{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockInstanceGroupManagers is the mock for InstanceGroupManagers.
type MockInstanceGroupManagers struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockInstanceGroupManagersObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                 func(ctx context.Context, key *meta.Key, m *MockInstanceGroupManagers, options ...Option) (bool, *computega.InstanceGroupManager, error)
	ListHook                func(ctx context.Context, zone string, fl *filter.F, m *MockInstanceGroupManagers, options ...Option) (bool, []*computega.InstanceGroupManager, error)
	InsertHook              func(ctx context.Context, key *meta.Key, obj *computega.InstanceGroupManager, m *MockInstanceGroupManagers, options ...Option) (bool, error)
	DeleteHook              func(ctx context.Context, key *meta.Key, m *MockInstanceGroupManagers, options ...Option) (bool, error)
	CreateInstancesHook     func(context.Context, *meta.Key, *computega.InstanceGroupManagersCreateInstancesRequest, *MockInstanceGroupManagers, ...Option) error
	DeleteInstancesHook     func(context.Context, *meta.Key, *computega.InstanceGroupManagersDeleteInstancesRequest, *MockInstanceGroupManagers, ...Option) error
	ResizeHook              func(context.Context, *meta.Key, int64, *MockInstanceGroupManagers, ...Option) error
	SetInstanceTemplateHook func(context.Context, *meta.Key, *computega.InstanceGroupManagersSetInstanceTemplateRequest, *MockInstanceGroupManagers, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockInstanceGroupManagers) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceGroupManager, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroupManagers.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockInstanceGroupManagers.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockInstanceGroupManagers.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockInstanceGroupManagers %v not found", key),
	}
	klog.V(5).Infof("MockInstanceGroupManagers.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockInstanceGroupManagers) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.InstanceGroupManager, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroupManagers.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockInstanceGroupManagers.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.InstanceGroupManager
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockInstanceGroupManagers.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockInstanceGroupManagers) Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceGroupManager, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroupManagers.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockInstanceGroupManagers.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockInstanceGroupManagers %v exists", key),
		}
		klog.V(5).Infof("MockInstanceGroupManagers.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "instanceGroupManagers")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "instanceGroupManagers", key)

	m.Objects[*key] = &MockInstanceGroupManagersObj{obj}
	klog.V(5).Infof("MockInstanceGroupManagers.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockInstanceGroupManagers) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstanceGroupManagers.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockInstanceGroupManagers.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockInstanceGroupManagers %v not found", key),
		}
		klog.V(5).Infof("MockInstanceGroupManagers.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockInstanceGroupManagers.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockInstanceGroupManagers) Obj(o *computega.InstanceGroupManager) *MockInstanceGroupManagersObj {
	return &MockInstanceGroupManagersObj{o}
}

// CreateInstances is a mock for the corresponding method.
func (m *MockInstanceGroupManagers) CreateInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupManagersCreateInstancesRequest, options ...Option) error {
	if m.CreateInstancesHook != nil {
		return m.CreateInstancesHook(ctx, key, arg0, m)
	}
	return nil
}

// DeleteInstances is a mock for the corresponding method.
func (m *MockInstanceGroupManagers) DeleteInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupManagersDeleteInstancesRequest, options ...Option) error {
	if m.DeleteInstancesHook != nil {
		return m.DeleteInstancesHook(ctx, key, arg0, m)
	}
	return nil
}

// Resize is a mock for the corresponding method.
func (m *MockInstanceGroupManagers) Resize(ctx context.Context, key *meta.Key, arg0 int64, options ...Option) error {
	if m.ResizeHook != nil {
		return m.ResizeHook(ctx, key, arg0, m)
	}
	return nil
}

// SetInstanceTemplate is a mock for the corresponding method.
func (m *MockInstanceGroupManagers) SetInstanceTemplate(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupManagersSetInstanceTemplateRequest, options ...Option) error {
	if m.SetInstanceTemplateHook != nil {
		return m.SetInstanceTemplateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEInstanceGroupManagers is a simplifying adapter for the GCE InstanceGroupManagers.
type GCEInstanceGroupManagers struct {
	s *Service
}

// Get the InstanceGroupManager named by key.
func (g *GCEInstanceGroupManagers) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceGroupManager, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}

	klog.V(5).Infof("GCEInstanceGroupManagers.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.InstanceGroupManagers.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEInstanceGroupManagers.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all InstanceGroupManager objects.
func (g *GCEInstanceGroupManagers) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.InstanceGroupManager, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.GA.InstanceGroupManagers.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.InstanceGroupManager
	f := func(l *computega.InstanceGroupManagerList) error {
		klog.V(5).Infof("GCEInstanceGroupManagers.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroupManagers.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEInstanceGroupManagers.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEInstanceGroupManagers.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert InstanceGroupManager with key of value obj.
func (g *GCEInstanceGroupManagers) Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceGroupManager, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.InstanceGroupManagers.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstanceGroupManagers.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the InstanceGroupManager referenced by key.
func (g *GCEInstanceGroupManagers) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroupManagers.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstanceGroupManagers.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// CreateInstances is a method on GCEInstanceGroupManagers.
func (g *GCEInstanceGroupManagers) CreateInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupManagersCreateInstancesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.CreateInstances(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.CreateInstances(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "CreateInstances",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.CreateInstances(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.CreateInstances(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroupManagers.CreateInstances(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroupManagers.CreateInstances(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroupManagers.CreateInstances(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DeleteInstances is a method on GCEInstanceGroupManagers.
func (g *GCEInstanceGroupManagers) DeleteInstances(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupManagersDeleteInstancesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.DeleteInstances(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.DeleteInstances(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DeleteInstances",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.DeleteInstances(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.DeleteInstances(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroupManagers.DeleteInstances(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroupManagers.DeleteInstances(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroupManagers.DeleteInstances(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Resize is a method on GCEInstanceGroupManagers.
func (g *GCEInstanceGroupManagers) Resize(ctx context.Context, key *meta.Key, arg0 int64, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.Resize(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.Resize(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Resize",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.Resize(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.Resize(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroupManagers.Resize(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroupManagers.Resize(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroupManagers.Resize(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetInstanceTemplate is a method on GCEInstanceGroupManagers.
func (g *GCEInstanceGroupManagers) SetInstanceTemplate(ctx context.Context, key *meta.Key, arg0 *computega.InstanceGroupManagersSetInstanceTemplateRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceGroupManagers.SetInstanceTemplate(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceGroupManagers.SetInstanceTemplate(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceGroupManagers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetInstanceTemplate",
		Version:   meta.Version("ga"),
		Service:   "InstanceGroupManagers",
	}
	klog.V(5).Infof("GCEInstanceGroupManagers.SetInstanceTemplate(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceGroupManagers.SetInstanceTemplate(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceGroupManagers.SetInstanceTemplate(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceGroupManagers.SetInstanceTemplate(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEInstanceGroupManagers.SetInstanceTemplate(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// InstanceTemplates is an interface that allows for mocking of InstanceTemplates.
type InstanceTemplates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceTemplate, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.InstanceTemplate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceTemplate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockInstanceTemplates returns a new mock for InstanceTemplates.
func NewMockInstanceTemplates(pr ProjectRouter, objs map[meta.Key]*MockInstanceTemplatesObj) *MockInstanceTemplates {
	mock := &MockInstanceTemplates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockInstanceTemplates is the mock for InstanceTemplates.
type MockInstanceTemplates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockInstanceTemplatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockInstanceTemplates, options ...Option) (bool, *computega.InstanceTemplate, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockInstanceTemplates, options ...Option) (bool, []*computega.InstanceTemplate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.InstanceTemplate, m *MockInstanceTemplates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockInstanceTemplates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockInstanceTemplates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceTemplate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstanceTemplates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockInstanceTemplates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockInstanceTemplates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockInstanceTemplates %v not found", key),
	}
	klog.V(5).Infof("MockInstanceTemplates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockInstanceTemplates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.InstanceTemplate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockInstanceTemplates.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockInstanceTemplates.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.InstanceTemplate
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockInstanceTemplates.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockInstanceTemplates) Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceTemplate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockInstanceTemplates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockInstanceTemplates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockInstanceTemplates %v exists", key),
		}
		klog.V(5).Infof("MockInstanceTemplates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "instanceTemplates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "instanceTemplates", key)

	m.Objects[*key] = &MockInstanceTemplatesObj{obj}
	klog.V(5).Infof("MockInstanceTemplates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockInstanceTemplates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockInstanceTemplates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockInstanceTemplates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockInstanceTemplates %v not found", key),
		}
		klog.V(5).Infof("MockInstanceTemplates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockInstanceTemplates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockInstanceTemplates) Obj(o *computega.InstanceTemplate) *MockInstanceTemplatesObj {
	return &MockInstanceTemplatesObj{o}
}

// GCEInstanceTemplates is a simplifying adapter for the GCE InstanceTemplates.
type GCEInstanceTemplates struct {
	s *Service
}

// Get the InstanceTemplate named by key.
func (g *GCEInstanceTemplates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.InstanceTemplate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceTemplates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceTemplates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceTemplates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "InstanceTemplates",
	}

	klog.V(5).Infof("GCEInstanceTemplates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceTemplates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.InstanceTemplates.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEInstanceTemplates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all InstanceTemplate objects.
func (g *GCEInstanceTemplates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.InstanceTemplate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceTemplates.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceTemplates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "InstanceTemplates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEInstanceTemplates.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.InstanceTemplates.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.InstanceTemplate
	f := func(l *computega.InstanceTemplateList) error {
		klog.V(5).Infof("GCEInstanceTemplates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEInstanceTemplates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEInstanceTemplates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEInstanceTemplates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert InstanceTemplate with key of value obj.
func (g *GCEInstanceTemplates) Insert(ctx context.Context, key *meta.Key, obj *computega.InstanceTemplate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceTemplates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceTemplates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceTemplates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "InstanceTemplates",
	}
	klog.V(5).Infof("GCEInstanceTemplates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceTemplates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.InstanceTemplates.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstanceTemplates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstanceTemplates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the InstanceTemplate referenced by key.
func (g *GCEInstanceTemplates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEInstanceTemplates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEInstanceTemplates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "InstanceTemplates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "InstanceTemplates",
	}
	klog.V(5).Infof("GCEInstanceTemplates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEInstanceTemplates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.InstanceTemplates.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEInstanceTemplates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEInstanceTemplates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Images is an interface that allows for mocking of Images.
type Images interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Image, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Image, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Image, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	GetFromFamily(context.Context, *meta.Key, ...Option) (*computega.Image, error)
	GetIamPolicy(context.Context, *meta.Key, ...Option) (*computega.Policy, error)
	Patch(context.Context, *meta.Key, *computega.Image, ...Option) error
	SetIamPolicy(context.Context, *meta.Key, *computega.GlobalSetPolicyRequest, ...Option) (*computega.Policy, error)
	SetLabels(context.Context, *meta.Key, *computega.GlobalSetLabelsRequest, ...Option) error
	TestIamPermissions(context.Context, *meta.Key, *computega.TestPermissionsRequest, ...Option) (*computega.TestPermissionsResponse, error)
}

// NewMockImages returns a new mock for Images.
func NewMockImages(pr ProjectRouter, objs map[meta.Key]*MockImagesObj) *MockImages {
	mock := &MockImages{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockImages is the mock for Images.
type MockImages struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockImagesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockImages, options ...Option) (bool, *computega.Image, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockImages, options ...Option) (bool, []*computega.Image, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computega.Image, m *MockImages, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockImages, options ...Option) (bool, error)
	GetFromFamilyHook      func(context.Context, *meta.Key, *MockImages, ...Option) (*computega.Image, error)
	GetIamPolicyHook       func(context.Context, *meta.Key, *MockImages, ...Option) (*computega.Policy, error)
	PatchHook              func(context.Context, *meta.Key, *computega.Image, *MockImages, ...Option) error
	SetIamPolicyHook       func(context.Context, *meta.Key, *computega.GlobalSetPolicyRequest, *MockImages, ...Option) (*computega.Policy, error)
	SetLabelsHook          func(context.Context, *meta.Key, *computega.GlobalSetLabelsRequest, *MockImages, ...Option) error
	TestIamPermissionsHook func(context.Context, *meta.Key, *computega.TestPermissionsRequest, *MockImages, ...Option) (*computega.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockImages) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Image, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockImages.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockImages.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockImages.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockImages %v not found", key),
	}
	klog.V(5).Infof("MockImages.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockImages) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Image, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockImages.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockImages.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Image
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockImages.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockImages) Insert(ctx context.Context, key *meta.Key, obj *computega.Image, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockImages %v exists", key),
		}
		klog.V(5).Infof("MockImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "Images")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "Images", key)

	m.Objects[*key] = &MockImagesObj{obj}
	klog.V(5).Infof("MockImages.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockImages) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockImages.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockImages %v not found", key),
		}
		klog.V(5).Infof("MockImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockImages.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockImages) Obj(o *computega.Image) *MockImagesObj {
	return &MockImagesObj{o}
}

// GetFromFamily is a mock for the corresponding method.
func (m *MockImages) GetFromFamily(ctx context.Context, key *meta.Key, options ...Option) (*computega.Image, error) {
	if m.GetFromFamilyHook != nil {
		return m.GetFromFamilyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetFromFamilyHook must be set")
}

// GetIamPolicy is a mock for the corresponding method.
func (m *MockImages) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computega.Policy, error) {
	if m.GetIamPolicyHook != nil {
		return m.GetIamPolicyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetIamPolicyHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockImages) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Image, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetIamPolicy is a mock for the corresponding method.
func (m *MockImages) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computega.GlobalSetPolicyRequest, options ...Option) (*computega.Policy, error) {
	if m.SetIamPolicyHook != nil {
		return m.SetIamPolicyHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("SetIamPolicyHook must be set")
}

// SetLabels is a mock for the corresponding method.
func (m *MockImages) SetLabels(ctx context.Context, key *meta.Key, arg0 *computega.GlobalSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockImages) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computega.TestPermissionsRequest, options ...Option) (*computega.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEImages is a simplifying adapter for the GCE Images.
type GCEImages struct {
	s *Service
}

// Get the Image named by key.
func (g *GCEImages) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}

	klog.V(5).Infof("GCEImages.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Images.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEImages.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Image objects.
func (g *GCEImages) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEImages.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Images.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Image
	f := func(l *computega.ImageList) error {
		klog.V(5).Infof("GCEImages.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEImages.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEImages.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEImages.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Image with key of value obj.
func (g *GCEImages) Insert(ctx context.Context, key *meta.Key, obj *computega.Image, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEImages.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Images.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEImages.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEImages.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Image referenced by key.
func (g *GCEImages) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEImages.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Images.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEImages.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GetFromFamily is a method on GCEImages.
func (g *GCEImages) GetFromFamily(ctx context.Context, key *meta.Key, options ...Option) (*computega.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.GetFromFamily(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.GetFromFamily(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetFromFamily",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.GetFromFamily(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.GetFromFamily(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Images.GetFromFamily(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEImages.GetFromFamily(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetIamPolicy is a method on GCEImages.
func (g *GCEImages) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computega.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.GetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.GetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetIamPolicy",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.GetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.GetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Images.GetIamPolicy(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEImages.GetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEImages.
func (g *GCEImages) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Image, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Images.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEImages.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEImages.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetIamPolicy is a method on GCEImages.
func (g *GCEImages) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computega.GlobalSetPolicyRequest, options ...Option) (*computega.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.SetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.SetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetIamPolicy",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.SetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.SetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Images.SetIamPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEImages.SetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// SetLabels is a method on GCEImages.
func (g *GCEImages) SetLabels(ctx context.Context, key *meta.Key, arg0 *computega.GlobalSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Images.SetLabels(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEImages.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEImages.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TestIamPermissions is a method on GCEImages.
func (g *GCEImages) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computega.TestPermissionsRequest, options ...Option) (*computega.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEImages.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEImages.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("ga"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEImages.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEImages.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Images.TestIamPermissions(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEImages.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// BetaImages is an interface that allows for mocking of Images.
type BetaImages interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Image, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Image, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Image, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	GetFromFamily(context.Context, *meta.Key, ...Option) (*computebeta.Image, error)
	GetIamPolicy(context.Context, *meta.Key, ...Option) (*computebeta.Policy, error)
	Patch(context.Context, *meta.Key, *computebeta.Image, ...Option) error
	SetIamPolicy(context.Context, *meta.Key, *computebeta.GlobalSetPolicyRequest, ...Option) (*computebeta.Policy, error)
	SetLabels(context.Context, *meta.Key, *computebeta.GlobalSetLabelsRequest, ...Option) error
	TestIamPermissions(context.Context, *meta.Key, *computebeta.TestPermissionsRequest, ...Option) (*computebeta.TestPermissionsResponse, error)
}

// NewMockBetaImages returns a new mock for Images.
func NewMockBetaImages(pr ProjectRouter, objs map[meta.Key]*MockImagesObj) *MockBetaImages {
	mock := &MockBetaImages{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaImages is the mock for Images.
type MockBetaImages struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockImagesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockBetaImages, options ...Option) (bool, *computebeta.Image, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockBetaImages, options ...Option) (bool, []*computebeta.Image, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computebeta.Image, m *MockBetaImages, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockBetaImages, options ...Option) (bool, error)
	GetFromFamilyHook      func(context.Context, *meta.Key, *MockBetaImages, ...Option) (*computebeta.Image, error)
	GetIamPolicyHook       func(context.Context, *meta.Key, *MockBetaImages, ...Option) (*computebeta.Policy, error)
	PatchHook              func(context.Context, *meta.Key, *computebeta.Image, *MockBetaImages, ...Option) error
	SetIamPolicyHook       func(context.Context, *meta.Key, *computebeta.GlobalSetPolicyRequest, *MockBetaImages, ...Option) (*computebeta.Policy, error)
	SetLabelsHook          func(context.Context, *meta.Key, *computebeta.GlobalSetLabelsRequest, *MockBetaImages, ...Option) error
	TestIamPermissionsHook func(context.Context, *meta.Key, *computebeta.TestPermissionsRequest, *MockBetaImages, ...Option) (*computebeta.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaImages) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Image, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaImages.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaImages.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaImages.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaImages %v not found", key),
	}
	klog.V(5).Infof("MockBetaImages.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaImages) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Image, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaImages.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaImages.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Image
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaImages.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaImages) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Image, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaImages %v exists", key),
		}
		klog.V(5).Infof("MockBetaImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "Images")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "Images", key)

	m.Objects[*key] = &MockImagesObj{obj}
	klog.V(5).Infof("MockBetaImages.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaImages) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaImages.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaImages %v not found", key),
		}
		klog.V(5).Infof("MockBetaImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaImages.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaImages) Obj(o *computebeta.Image) *MockImagesObj {
	return &MockImagesObj{o}
}

// GetFromFamily is a mock for the corresponding method.
func (m *MockBetaImages) GetFromFamily(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Image, error) {
	if m.GetFromFamilyHook != nil {
		return m.GetFromFamilyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetFromFamilyHook must be set")
}

// GetIamPolicy is a mock for the corresponding method.
func (m *MockBetaImages) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Policy, error) {
	if m.GetIamPolicyHook != nil {
		return m.GetIamPolicyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetIamPolicyHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockBetaImages) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Image, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetIamPolicy is a mock for the corresponding method.
func (m *MockBetaImages) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalSetPolicyRequest, options ...Option) (*computebeta.Policy, error) {
	if m.SetIamPolicyHook != nil {
		return m.SetIamPolicyHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("SetIamPolicyHook must be set")
}

// SetLabels is a mock for the corresponding method.
func (m *MockBetaImages) SetLabels(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockBetaImages) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computebeta.TestPermissionsRequest, options ...Option) (*computebeta.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEBetaImages is a simplifying adapter for the GCE Images.
type GCEBetaImages struct {
	s *Service
}

// Get the Image named by key.
func (g *GCEBetaImages) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}

	klog.V(5).Infof("GCEBetaImages.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Images.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaImages.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Image objects.
func (g *GCEBetaImages) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaImages.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.Images.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Image
	f := func(l *computebeta.ImageList) error {
		klog.V(5).Infof("GCEBetaImages.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaImages.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaImages.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaImages.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Image with key of value obj.
func (g *GCEBetaImages) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Image, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Images.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaImages.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaImages.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Image referenced by key.
func (g *GCEBetaImages) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Images.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaImages.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GetFromFamily is a method on GCEBetaImages.
func (g *GCEBetaImages) GetFromFamily(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.GetFromFamily(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.GetFromFamily(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetFromFamily",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.GetFromFamily(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.GetFromFamily(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Images.GetFromFamily(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaImages.GetFromFamily(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetIamPolicy is a method on GCEBetaImages.
func (g *GCEBetaImages) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.GetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.GetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetIamPolicy",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.GetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.GetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Images.GetIamPolicy(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaImages.GetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEBetaImages.
func (g *GCEBetaImages) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Image, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Images.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaImages.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaImages.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetIamPolicy is a method on GCEBetaImages.
func (g *GCEBetaImages) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalSetPolicyRequest, options ...Option) (*computebeta.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.SetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.SetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetIamPolicy",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.SetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.SetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Images.SetIamPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaImages.SetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// SetLabels is a method on GCEBetaImages.
func (g *GCEBetaImages) SetLabels(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Images.SetLabels(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaImages.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaImages.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TestIamPermissions is a method on GCEBetaImages.
func (g *GCEBetaImages) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computebeta.TestPermissionsRequest, options ...Option) (*computebeta.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaImages.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaImages.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("beta"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEBetaImages.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaImages.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Images.TestIamPermissions(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaImages.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// AlphaImages is an interface that allows for mocking of Images.
type AlphaImages interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Image, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Image, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Image, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	GetFromFamily(context.Context, *meta.Key, ...Option) (*computealpha.Image, error)
	GetIamPolicy(context.Context, *meta.Key, ...Option) (*computealpha.Policy, error)
	Patch(context.Context, *meta.Key, *computealpha.Image, ...Option) error
	SetIamPolicy(context.Context, *meta.Key, *computealpha.GlobalSetPolicyRequest, ...Option) (*computealpha.Policy, error)
	SetLabels(context.Context, *meta.Key, *computealpha.GlobalSetLabelsRequest, ...Option) error
	TestIamPermissions(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, ...Option) (*computealpha.TestPermissionsResponse, error)
}

// NewMockAlphaImages returns a new mock for Images.
func NewMockAlphaImages(pr ProjectRouter, objs map[meta.Key]*MockImagesObj) *MockAlphaImages {
	mock := &MockAlphaImages{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaImages is the mock for Images.
type MockAlphaImages struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockImagesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaImages, options ...Option) (bool, *computealpha.Image, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockAlphaImages, options ...Option) (bool, []*computealpha.Image, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.Image, m *MockAlphaImages, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaImages, options ...Option) (bool, error)
	GetFromFamilyHook      func(context.Context, *meta.Key, *MockAlphaImages, ...Option) (*computealpha.Image, error)
	GetIamPolicyHook       func(context.Context, *meta.Key, *MockAlphaImages, ...Option) (*computealpha.Policy, error)
	PatchHook              func(context.Context, *meta.Key, *computealpha.Image, *MockAlphaImages, ...Option) error
	SetIamPolicyHook       func(context.Context, *meta.Key, *computealpha.GlobalSetPolicyRequest, *MockAlphaImages, ...Option) (*computealpha.Policy, error)
	SetLabelsHook          func(context.Context, *meta.Key, *computealpha.GlobalSetLabelsRequest, *MockAlphaImages, ...Option) error
	TestIamPermissionsHook func(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, *MockAlphaImages, ...Option) (*computealpha.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaImages) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Image, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaImages.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaImages.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaImages.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaImages %v not found", key),
	}
	klog.V(5).Infof("MockAlphaImages.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaImages) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Image, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaImages.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaImages.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Image
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaImages.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaImages) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Image, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaImages %v exists", key),
		}
		klog.V(5).Infof("MockAlphaImages.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "Images")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "Images", key)

	m.Objects[*key] = &MockImagesObj{obj}
	klog.V(5).Infof("MockAlphaImages.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaImages) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaImages.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaImages %v not found", key),
		}
		klog.V(5).Infof("MockAlphaImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaImages.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaImages) Obj(o *computealpha.Image) *MockImagesObj {
	return &MockImagesObj{o}
}

// GetFromFamily is a mock for the corresponding method.
func (m *MockAlphaImages) GetFromFamily(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Image, error) {
	if m.GetFromFamilyHook != nil {
		return m.GetFromFamilyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetFromFamilyHook must be set")
}

// GetIamPolicy is a mock for the corresponding method.
func (m *MockAlphaImages) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Policy, error) {
	if m.GetIamPolicyHook != nil {
		return m.GetIamPolicyHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetIamPolicyHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaImages) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Image, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetIamPolicy is a mock for the corresponding method.
func (m *MockAlphaImages) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetPolicyRequest, options ...Option) (*computealpha.Policy, error) {
	if m.SetIamPolicyHook != nil {
		return m.SetIamPolicyHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("SetIamPolicyHook must be set")
}

// SetLabels is a mock for the corresponding method.
func (m *MockAlphaImages) SetLabels(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetLabelsRequest, options ...Option) error {
	if m.SetLabelsHook != nil {
		return m.SetLabelsHook(ctx, key, arg0, m)
	}
	return nil
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockAlphaImages) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEAlphaImages is a simplifying adapter for the GCE Images.
type GCEAlphaImages struct {
	s *Service
}

// Get the Image named by key.
func (g *GCEAlphaImages) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}

	klog.V(5).Infof("GCEAlphaImages.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Images.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaImages.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Image objects.
func (g *GCEAlphaImages) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaImages.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.Images.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Image
	f := func(l *computealpha.ImageList) error {
		klog.V(5).Infof("GCEAlphaImages.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaImages.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaImages.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaImages.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Image with key of value obj.
func (g *GCEAlphaImages) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Image, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Images.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaImages.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaImages.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Image referenced by key.
func (g *GCEAlphaImages) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Images.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaImages.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaImages.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// GetFromFamily is a method on GCEAlphaImages.
func (g *GCEAlphaImages) GetFromFamily(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Image, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.GetFromFamily(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.GetFromFamily(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetFromFamily",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.GetFromFamily(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.GetFromFamily(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Images.GetFromFamily(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaImages.GetFromFamily(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// GetIamPolicy is a method on GCEAlphaImages.
func (g *GCEAlphaImages) GetIamPolicy(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.GetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.GetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetIamPolicy",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.GetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.GetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Images.GetIamPolicy(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaImages.GetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEAlphaImages.
func (g *GCEAlphaImages) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Image, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Images.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaImages.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaImages.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetIamPolicy is a method on GCEAlphaImages.
func (g *GCEAlphaImages) SetIamPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetPolicyRequest, options ...Option) (*computealpha.Policy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.SetIamPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.SetIamPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetIamPolicy",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.SetIamPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.SetIamPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Images.SetIamPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaImages.SetIamPolicy(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// SetLabels is a method on GCEAlphaImages.
func (g *GCEAlphaImages) SetLabels(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalSetLabelsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.SetLabels(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.SetLabels(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetLabels",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.SetLabels(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.SetLabels(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Images.SetLabels(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaImages.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaImages.SetLabels(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TestIamPermissions is a method on GCEAlphaImages.
func (g *GCEAlphaImages) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaImages.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaImages.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Images")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("alpha"),
		Service:   "Images",
	}
	klog.V(5).Infof("GCEAlphaImages.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaImages.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Images.TestIamPermissions(projectID, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaImages.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// AlphaNetworks is an interface that allows for mocking of Networks.
type AlphaNetworks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Network, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Network, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Network, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockAlphaNetworks returns a new mock for Networks.
func NewMockAlphaNetworks(pr ProjectRouter, objs map[meta.Key]*MockNetworksObj) *MockAlphaNetworks {
	mock := &MockAlphaNetworks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaNetworks is the mock for Networks.
type MockAlphaNetworks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaNetworks, options ...Option) (bool, *computealpha.Network, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockAlphaNetworks, options ...Option) (bool, []*computealpha.Network, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.Network, m *MockAlphaNetworks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaNetworks, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaNetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Network, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaNetworks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaNetworks %v not found", key),
	}
	klog.V(5).Infof("MockAlphaNetworks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaNetworks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Network, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaNetworks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Network
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaNetworks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaNetworks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Network, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaNetworks %v exists", key),
		}
		klog.V(5).Infof("MockAlphaNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "networks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "networks", key)

	m.Objects[*key] = &MockNetworksObj{obj}
	klog.V(5).Infof("MockAlphaNetworks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaNetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaNetworks %v not found", key),
		}
		klog.V(5).Infof("MockAlphaNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaNetworks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaNetworks) Obj(o *computealpha.Network) *MockNetworksObj {
	return &MockNetworksObj{o}
}

// GCEAlphaNetworks is a simplifying adapter for the GCE Networks.
type GCEAlphaNetworks struct {
	s *Service
}

// Get the Network named by key.
func (g *GCEAlphaNetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Network, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Networks",
	}

	klog.V(5).Infof("GCEAlphaNetworks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Networks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaNetworks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Network objects.
func (g *GCEAlphaNetworks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.Network, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Networks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaNetworks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.Networks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Network
	f := func(l *computealpha.NetworkList) error {
		klog.V(5).Infof("GCEAlphaNetworks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaNetworks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaNetworks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Network with key of value obj.
func (g *GCEAlphaNetworks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Network, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Networks",
	}
	klog.V(5).Infof("GCEAlphaNetworks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Networks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaNetworks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaNetworks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Network referenced by key.
func (g *GCEAlphaNetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Networks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Networks",
	}
	klog.V(5).Infof("GCEAlphaNetworks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Networks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaNetworks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// BetaNetworks is an interface that allows for mocking of Networks.
type BetaNetworks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Network, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Network, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Network, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockBetaNetworks returns a new mock for Networks.
func NewMockBetaNetworks(pr ProjectRouter, objs map[meta.Key]*MockNetworksObj) *MockBetaNetworks {
	mock := &MockBetaNetworks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaNetworks is the mock for Networks.
type MockBetaNetworks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaNetworks, options ...Option) (bool, *computebeta.Network, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaNetworks, options ...Option) (bool, []*computebeta.Network, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.Network, m *MockBetaNetworks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaNetworks, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaNetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Network, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaNetworks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaNetworks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaNetworks %v not found", key),
	}
	klog.V(5).Infof("MockBetaNetworks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaNetworks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Network, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaNetworks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Network
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaNetworks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaNetworks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Network, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaNetworks %v exists", key),
		}
		klog.V(5).Infof("MockBetaNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "networks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "networks", key)

	m.Objects[*key] = &MockNetworksObj{obj}
	klog.V(5).Infof("MockBetaNetworks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaNetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaNetworks %v not found", key),
		}
		klog.V(5).Infof("MockBetaNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaNetworks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaNetworks) Obj(o *computebeta.Network) *MockNetworksObj {
	return &MockNetworksObj{o}
}

// GCEBetaNetworks is a simplifying adapter for the GCE Networks.
type GCEBetaNetworks struct {
	s *Service
}

// Get the Network named by key.
func (g *GCEBetaNetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Network, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Networks",
	}

	klog.V(5).Infof("GCEBetaNetworks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Networks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaNetworks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Network objects.
func (g *GCEBetaNetworks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.Network, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Networks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaNetworks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.Networks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Network
	f := func(l *computebeta.NetworkList) error {
		klog.V(5).Infof("GCEBetaNetworks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaNetworks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaNetworks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaNetworks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Network with key of value obj.
func (g *GCEBetaNetworks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Network, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Networks",
	}
	klog.V(5).Infof("GCEBetaNetworks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Networks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaNetworks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaNetworks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Network referenced by key.
func (g *GCEBetaNetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Networks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Networks",
	}
	klog.V(5).Infof("GCEBetaNetworks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Networks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaNetworks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Networks is an interface that allows for mocking of Networks.
type Networks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Network, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Network, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Network, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockNetworks returns a new mock for Networks.
func NewMockNetworks(pr ProjectRouter, objs map[meta.Key]*MockNetworksObj) *MockNetworks {
	mock := &MockNetworks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockNetworks is the mock for Networks.
type MockNetworks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockNetworks, options ...Option) (bool, *computega.Network, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockNetworks, options ...Option) (bool, []*computega.Network, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.Network, m *MockNetworks, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockNetworks, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockNetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Network, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockNetworks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockNetworks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockNetworks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockNetworks %v not found", key),
	}
	klog.V(5).Infof("MockNetworks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockNetworks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Network, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockNetworks.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockNetworks.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Network
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockNetworks.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockNetworks) Insert(ctx context.Context, key *meta.Key, obj *computega.Network, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockNetworks %v exists", key),
		}
		klog.V(5).Infof("MockNetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "networks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "networks", key)

	m.Objects[*key] = &MockNetworksObj{obj}
	klog.V(5).Infof("MockNetworks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockNetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockNetworks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockNetworks %v not found", key),
		}
		klog.V(5).Infof("MockNetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockNetworks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockNetworks) Obj(o *computega.Network) *MockNetworksObj {
	return &MockNetworksObj{o}
}

// GCENetworks is a simplifying adapter for the GCE Networks.
type GCENetworks struct {
	s *Service
}

// Get the Network named by key.
func (g *GCENetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Network, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCENetworks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Networks",
	}

	klog.V(5).Infof("GCENetworks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Networks.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCENetworks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Network objects.
func (g *GCENetworks) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Network, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworks.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Networks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCENetworks.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Networks.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Network
	f := func(l *computega.NetworkList) error {
		klog.V(5).Infof("GCENetworks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCENetworks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCENetworks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCENetworks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Network with key of value obj.
func (g *GCENetworks) Insert(ctx context.Context, key *meta.Key, obj *computega.Network, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCENetworks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Networks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Networks",
	}
	klog.V(5).Infof("GCENetworks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Networks.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCENetworks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCENetworks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Network referenced by key.
func (g *GCENetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCENetworks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Networks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Networks",
	}
	klog.V(5).Infof("GCENetworks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Networks.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCENetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCENetworks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AlphaNetworkEndpointGroups is an interface that allows for mocking of NetworkEndpointGroups.
type AlphaNetworkEndpointGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.NetworkEndpointGroup, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.NetworkEndpointGroup, error)
	AttachNetworkEndpoints(context.Context, *meta.Key, *computealpha.NetworkEndpointGroupsAttachEndpointsRequest, ...Option) error
	DetachNetworkEndpoints(context.Context, *meta.Key, *computealpha.NetworkEndpointGroupsDetachEndpointsRequest, ...Option) error
	ListNetworkEndpoints(context.Context, *meta.Key, *computealpha.NetworkEndpointGroupsListEndpointsRequest, *filter.F, ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error)
}

// NewMockAlphaNetworkEndpointGroups returns a new mock for NetworkEndpointGroups.
func NewMockAlphaNetworkEndpointGroups(pr ProjectRouter, objs map[meta.Key]*MockNetworkEndpointGroupsObj) *MockAlphaNetworkEndpointGroups {
	mock := &MockAlphaNetworkEndpointGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaNetworkEndpointGroups is the mock for NetworkEndpointGroups.
type MockAlphaNetworkEndpointGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworkEndpointGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockAlphaNetworkEndpointGroups, options ...Option) (bool, *computealpha.NetworkEndpointGroup, error)
	ListHook                   func(ctx context.Context, zone string, fl *filter.F, m *MockAlphaNetworkEndpointGroups, options ...Option) (bool, []*computealpha.NetworkEndpointGroup, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, m *MockAlphaNetworkEndpointGroups, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockAlphaNetworkEndpointGroups, options ...Option) (bool, error)
	AggregatedListHook         func(ctx context.Context, fl *filter.F, m *MockAlphaNetworkEndpointGroups, options ...Option) (bool, map[string][]*computealpha.NetworkEndpointGroup, error)
	AttachNetworkEndpointsHook func(context.Context, *meta.Key, *computealpha.NetworkEndpointGroupsAttachEndpointsRequest, *MockAlphaNetworkEndpointGroups, ...Option) error
	DetachNetworkEndpointsHook func(context.Context, *meta.Key, *computealpha.NetworkEndpointGroupsDetachEndpointsRequest, *MockAlphaNetworkEndpointGroups, ...Option) error
	ListNetworkEndpointsHook   func(context.Context, *meta.Key, *computealpha.NetworkEndpointGroupsListEndpointsRequest, *filter.F, *MockAlphaNetworkEndpointGroups, ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaNetworkEndpointGroups %v not found", key),
	}
	klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockAlphaNetworkEndpointGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkEndpointGroups.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.NetworkEndpointGroup
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaNetworkEndpointGroups.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaNetworkEndpointGroups %v exists", key),
		}
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "networkEndpointGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "networkEndpointGroups", key)

	m.Objects[*key] = &MockNetworkEndpointGroupsObj{obj}
	klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaNetworkEndpointGroups %v not found", key),
		}
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaNetworkEndpointGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockAlphaNetworkEndpointGroups) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.NetworkEndpointGroup, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computealpha.NetworkEndpointGroup{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToAlpha().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToAlpha())
	}
	klog.V(5).Infof("MockAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaNetworkEndpointGroups) Obj(o *computealpha.NetworkEndpointGroup) *MockNetworkEndpointGroupsObj {
	return &MockNetworkEndpointGroupsObj{o}
}

// AttachNetworkEndpoints is a mock for the corresponding method.
func (m *MockAlphaNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.NetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachNetworkEndpoints is a mock for the corresponding method.
func (m *MockAlphaNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.NetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// ListNetworkEndpoints is a mock for the corresponding method.
func (m *MockAlphaNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.NetworkEndpointGroupsListEndpointsRequest, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error) {
	if m.ListNetworkEndpointsHook != nil {
		return m.ListNetworkEndpointsHook(ctx, key, arg0, fl, m)
	}
	return nil, nil
}

// GCEAlphaNetworkEndpointGroups is a simplifying adapter for the GCE NetworkEndpointGroups.
type GCEAlphaNetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCEAlphaNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkEndpointGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkEndpointGroups.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all NetworkEndpointGroup objects.
func (g *GCEAlphaNetworkEndpointGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.Alpha.NetworkEndpointGroups.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.NetworkEndpointGroup
	f := func(l *computealpha.NetworkEndpointGroupList) error {
		klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCEAlphaNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkEndpointGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.NetworkEndpointGroups.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCEAlphaNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkEndpointGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkEndpointGroups.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEAlphaNetworkEndpointGroups) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Alpha.NetworkEndpointGroups.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computealpha.NetworkEndpointGroup{}
	f := func(l *computealpha.NetworkEndpointGroupAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.NetworkEndpointGroups...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AttachNetworkEndpoints is a method on GCEAlphaNetworkEndpointGroups.
func (g *GCEAlphaNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.NetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachNetworkEndpoints is a method on GCEAlphaNetworkEndpointGroups.
func (g *GCEAlphaNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.NetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.NetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListNetworkEndpoints is a method on GCEAlphaNetworkEndpointGroups.
func (g *GCEAlphaNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.NetworkEndpointGroupsListEndpointsRequest, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.NetworkEndpointGroups.ListNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	var all []*computealpha.NetworkEndpointWithHealthStatus
	f := func(l *computealpha.NetworkEndpointGroupsListNetworkEndpoints) error {
		klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// BetaNetworkEndpointGroups is an interface that allows for mocking of NetworkEndpointGroups.
type BetaNetworkEndpointGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.NetworkEndpointGroup, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.NetworkEndpointGroup, error)
	AttachNetworkEndpoints(context.Context, *meta.Key, *computebeta.NetworkEndpointGroupsAttachEndpointsRequest, ...Option) error
	DetachNetworkEndpoints(context.Context, *meta.Key, *computebeta.NetworkEndpointGroupsDetachEndpointsRequest, ...Option) error
	ListNetworkEndpoints(context.Context, *meta.Key, *computebeta.NetworkEndpointGroupsListEndpointsRequest, *filter.F, ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error)
}

// NewMockBetaNetworkEndpointGroups returns a new mock for NetworkEndpointGroups.
func NewMockBetaNetworkEndpointGroups(pr ProjectRouter, objs map[meta.Key]*MockNetworkEndpointGroupsObj) *MockBetaNetworkEndpointGroups {
	mock := &MockBetaNetworkEndpointGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaNetworkEndpointGroups is the mock for NetworkEndpointGroups.
type MockBetaNetworkEndpointGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworkEndpointGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockBetaNetworkEndpointGroups, options ...Option) (bool, *computebeta.NetworkEndpointGroup, error)
	ListHook                   func(ctx context.Context, zone string, fl *filter.F, m *MockBetaNetworkEndpointGroups, options ...Option) (bool, []*computebeta.NetworkEndpointGroup, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, m *MockBetaNetworkEndpointGroups, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockBetaNetworkEndpointGroups, options ...Option) (bool, error)
	AggregatedListHook         func(ctx context.Context, fl *filter.F, m *MockBetaNetworkEndpointGroups, options ...Option) (bool, map[string][]*computebeta.NetworkEndpointGroup, error)
	AttachNetworkEndpointsHook func(context.Context, *meta.Key, *computebeta.NetworkEndpointGroupsAttachEndpointsRequest, *MockBetaNetworkEndpointGroups, ...Option) error
	DetachNetworkEndpointsHook func(context.Context, *meta.Key, *computebeta.NetworkEndpointGroupsDetachEndpointsRequest, *MockBetaNetworkEndpointGroups, ...Option) error
	ListNetworkEndpointsHook   func(context.Context, *meta.Key, *computebeta.NetworkEndpointGroupsListEndpointsRequest, *filter.F, *MockBetaNetworkEndpointGroups, ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworkEndpointGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaNetworkEndpointGroups %v not found", key),
	}
	klog.V(5).Infof("MockBetaNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockBetaNetworkEndpointGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworkEndpointGroups.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.NetworkEndpointGroup
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaNetworkEndpointGroups.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaNetworkEndpointGroups %v exists", key),
		}
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "networkEndpointGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "networkEndpointGroups", key)

	m.Objects[*key] = &MockNetworkEndpointGroupsObj{obj}
	klog.V(5).Infof("MockBetaNetworkEndpointGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaNetworkEndpointGroups %v not found", key),
		}
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaNetworkEndpointGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockBetaNetworkEndpointGroups) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.NetworkEndpointGroup, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockBetaNetworkEndpointGroups.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computebeta.NetworkEndpointGroup{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToBeta().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockBetaNetworkEndpointGroups.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToBeta())
	}
	klog.V(5).Infof("MockBetaNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaNetworkEndpointGroups) Obj(o *computebeta.NetworkEndpointGroup) *MockNetworkEndpointGroupsObj {
	return &MockNetworkEndpointGroupsObj{o}
}

// AttachNetworkEndpoints is a mock for the corresponding method.
func (m *MockBetaNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.NetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachNetworkEndpoints is a mock for the corresponding method.
func (m *MockBetaNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.NetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// ListNetworkEndpoints is a mock for the corresponding method.
func (m *MockBetaNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.NetworkEndpointGroupsListEndpointsRequest, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error) {
	if m.ListNetworkEndpointsHook != nil {
		return m.ListNetworkEndpointsHook(ctx, key, arg0, fl, m)
	}
	return nil, nil
}

// GCEBetaNetworkEndpointGroups is a simplifying adapter for the GCE NetworkEndpointGroups.
type GCEBetaNetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCEBetaNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworkEndpointGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.NetworkEndpointGroups.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all NetworkEndpointGroup objects.
func (g *GCEBetaNetworkEndpointGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.Beta.NetworkEndpointGroups.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.NetworkEndpointGroup
	f := func(l *computebeta.NetworkEndpointGroupList) error {
		klog.V(5).Infof("GCEBetaNetworkEndpointGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCEBetaNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworkEndpointGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.NetworkEndpointGroups.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCEBetaNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworkEndpointGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.NetworkEndpointGroups.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEBetaNetworkEndpointGroups) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Beta.NetworkEndpointGroups.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computebeta.NetworkEndpointGroup{}
	f := func(l *computebeta.NetworkEndpointGroupAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.NetworkEndpointGroups...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AttachNetworkEndpoints is a method on GCEBetaNetworkEndpointGroups.
func (g *GCEBetaNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.NetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.NetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachNetworkEndpoints is a method on GCEBetaNetworkEndpointGroups.
func (g *GCEBetaNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.NetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.NetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListNetworkEndpoints is a method on GCEBetaNetworkEndpointGroups.
func (g *GCEBetaNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.NetworkEndpointGroupsListEndpointsRequest, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListNetworkEndpoints",
		Version:   meta.Version("beta"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.NetworkEndpointGroups.ListNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	var all []*computebeta.NetworkEndpointWithHealthStatus
	f := func(l *computebeta.NetworkEndpointGroupsListNetworkEndpoints) error {
		klog.V(5).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// NetworkEndpointGroups is an interface that allows for mocking of NetworkEndpointGroups.
type NetworkEndpointGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.NetworkEndpointGroup, error)
	List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.NetworkEndpointGroup, error)
	AttachNetworkEndpoints(context.Context, *meta.Key, *computega.NetworkEndpointGroupsAttachEndpointsRequest, ...Option) error
	DetachNetworkEndpoints(context.Context, *meta.Key, *computega.NetworkEndpointGroupsDetachEndpointsRequest, ...Option) error
	ListNetworkEndpoints(context.Context, *meta.Key, *computega.NetworkEndpointGroupsListEndpointsRequest, *filter.F, ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error)
}

// NewMockNetworkEndpointGroups returns a new mock for NetworkEndpointGroups.
func NewMockNetworkEndpointGroups(pr ProjectRouter, objs map[meta.Key]*MockNetworkEndpointGroupsObj) *MockNetworkEndpointGroups {
	mock := &MockNetworkEndpointGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockNetworkEndpointGroups is the mock for NetworkEndpointGroups.
type MockNetworkEndpointGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockNetworkEndpointGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockNetworkEndpointGroups, options ...Option) (bool, *computega.NetworkEndpointGroup, error)
	ListHook                   func(ctx context.Context, zone string, fl *filter.F, m *MockNetworkEndpointGroups, options ...Option) (bool, []*computega.NetworkEndpointGroup, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, m *MockNetworkEndpointGroups, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockNetworkEndpointGroups, options ...Option) (bool, error)
	AggregatedListHook         func(ctx context.Context, fl *filter.F, m *MockNetworkEndpointGroups, options ...Option) (bool, map[string][]*computega.NetworkEndpointGroup, error)
	AttachNetworkEndpointsHook func(context.Context, *meta.Key, *computega.NetworkEndpointGroupsAttachEndpointsRequest, *MockNetworkEndpointGroups, ...Option) error
	DetachNetworkEndpointsHook func(context.Context, *meta.Key, *computega.NetworkEndpointGroupsDetachEndpointsRequest, *MockNetworkEndpointGroups, ...Option) error
	ListNetworkEndpointsHook   func(context.Context, *meta.Key, *computega.NetworkEndpointGroupsListEndpointsRequest, *filter.F, *MockNetworkEndpointGroups, ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockNetworkEndpointGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockNetworkEndpointGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockNetworkEndpointGroups %v not found", key),
	}
	klog.V(5).Infof("MockNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given zone.
func (m *MockNetworkEndpointGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, zone, fl, m, options...); intercept {
			klog.V(5).Infof("MockNetworkEndpointGroups.List(%v, %q, %v) = [%v items], %v", ctx, zone, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockNetworkEndpointGroups.List(%v, %q, %v) = nil, %v", ctx, zone, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.NetworkEndpointGroup
	for key, obj := range m.Objects {
		if key.Zone != zone {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockNetworkEndpointGroups.List(%v, %q, %v) = [%v items], nil", ctx, zone, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockNetworkEndpointGroups %v exists", key),
		}
		klog.V(5).Infof("MockNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "networkEndpointGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "networkEndpointGroups", key)

	m.Objects[*key] = &MockNetworkEndpointGroupsObj{obj}
	klog.V(5).Infof("MockNetworkEndpointGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockNetworkEndpointGroups %v not found", key),
		}
		klog.V(5).Infof("MockNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockNetworkEndpointGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockNetworkEndpointGroups) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.NetworkEndpointGroup, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockNetworkEndpointGroups.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computega.NetworkEndpointGroup{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToGA().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockNetworkEndpointGroups.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToGA())
	}
	klog.V(5).Infof("MockNetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockNetworkEndpointGroups) Obj(o *computega.NetworkEndpointGroup) *MockNetworkEndpointGroupsObj {
	return &MockNetworkEndpointGroupsObj{o}
}

// AttachNetworkEndpoints is a mock for the corresponding method.
func (m *MockNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.NetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachNetworkEndpoints is a mock for the corresponding method.
func (m *MockNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.NetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// ListNetworkEndpoints is a mock for the corresponding method.
func (m *MockNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.NetworkEndpointGroupsListEndpointsRequest, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error) {
	if m.ListNetworkEndpointsHook != nil {
		return m.ListNetworkEndpointsHook(ctx, key, arg0, fl, m)
	}
	return nil, nil
}

// GCENetworkEndpointGroups is a simplifying adapter for the GCE NetworkEndpointGroups.
type GCENetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCENetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCENetworkEndpointGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}

	klog.V(5).Infof("GCENetworkEndpointGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.NetworkEndpointGroups.Get(projectID, key.Zone, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCENetworkEndpointGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all NetworkEndpointGroup objects.
func (g *GCENetworkEndpointGroups) List(ctx context.Context, zone string, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.List(%v, %v, %v, %v) called", ctx, zone, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCENetworkEndpointGroups.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, zone, fl, projectID, ck)
	call := g.s.GA.NetworkEndpointGroups.List(projectID, zone)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.NetworkEndpointGroup
	f := func(l *computega.NetworkEndpointGroupList) error {
		klog.V(5).Infof("GCENetworkEndpointGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCENetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCENetworkEndpointGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCENetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCENetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCENetworkEndpointGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCENetworkEndpointGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.NetworkEndpointGroups.Insert(projectID, key.Zone, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCENetworkEndpointGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCENetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCENetworkEndpointGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCENetworkEndpointGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.NetworkEndpointGroups.Delete(projectID, key.Zone, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCENetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCENetworkEndpointGroups) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}

	klog.V(5).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.GA.NetworkEndpointGroups.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computega.NetworkEndpointGroup{}
	f := func(l *computega.NetworkEndpointGroupAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.NetworkEndpointGroups...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCENetworkEndpointGroups.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// AttachNetworkEndpoints is a method on GCENetworkEndpointGroups.
func (g *GCENetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.NetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCENetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCENetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.NetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCENetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCENetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachNetworkEndpoints is a method on GCENetworkEndpointGroups.
func (g *GCENetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.NetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCENetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCENetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.NetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCENetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCENetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListNetworkEndpoints is a method on GCENetworkEndpointGroups.
func (g *GCENetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.NetworkEndpointGroupsListEndpointsRequest, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "NetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListNetworkEndpoints",
		Version:   meta.Version("ga"),
		Service:   "NetworkEndpointGroups",
	}
	klog.V(5).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.NetworkEndpointGroups.ListNetworkEndpoints(projectID, key.Zone, key.Name, arg0)
	var all []*computega.NetworkEndpointWithHealthStatus
	f := func(l *computega.NetworkEndpointGroupsListNetworkEndpoints) error {
		klog.V(5).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCENetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// AlphaGlobalNetworkEndpointGroups is an interface that allows for mocking of GlobalNetworkEndpointGroups.
type AlphaGlobalNetworkEndpointGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.NetworkEndpointGroup, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AttachNetworkEndpoints(context.Context, *meta.Key, *computealpha.GlobalNetworkEndpointGroupsAttachEndpointsRequest, ...Option) error
	DetachNetworkEndpoints(context.Context, *meta.Key, *computealpha.GlobalNetworkEndpointGroupsDetachEndpointsRequest, ...Option) error
	ListNetworkEndpoints(context.Context, *meta.Key, *filter.F, ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error)
}

// NewMockAlphaGlobalNetworkEndpointGroups returns a new mock for GlobalNetworkEndpointGroups.
func NewMockAlphaGlobalNetworkEndpointGroups(pr ProjectRouter, objs map[meta.Key]*MockGlobalNetworkEndpointGroupsObj) *MockAlphaGlobalNetworkEndpointGroups {
	mock := &MockAlphaGlobalNetworkEndpointGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaGlobalNetworkEndpointGroups is the mock for GlobalNetworkEndpointGroups.
type MockAlphaGlobalNetworkEndpointGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalNetworkEndpointGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockAlphaGlobalNetworkEndpointGroups, options ...Option) (bool, *computealpha.NetworkEndpointGroup, error)
	ListHook                   func(ctx context.Context, fl *filter.F, m *MockAlphaGlobalNetworkEndpointGroups, options ...Option) (bool, []*computealpha.NetworkEndpointGroup, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, m *MockAlphaGlobalNetworkEndpointGroups, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockAlphaGlobalNetworkEndpointGroups, options ...Option) (bool, error)
	AttachNetworkEndpointsHook func(context.Context, *meta.Key, *computealpha.GlobalNetworkEndpointGroupsAttachEndpointsRequest, *MockAlphaGlobalNetworkEndpointGroups, ...Option) error
	DetachNetworkEndpointsHook func(context.Context, *meta.Key, *computealpha.GlobalNetworkEndpointGroupsDetachEndpointsRequest, *MockAlphaGlobalNetworkEndpointGroups, ...Option) error
	ListNetworkEndpointsHook   func(context.Context, *meta.Key, *filter.F, *MockAlphaGlobalNetworkEndpointGroups, ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaGlobalNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaGlobalNetworkEndpointGroups %v not found", key),
	}
	klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaGlobalNetworkEndpointGroups) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.NetworkEndpointGroup
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaGlobalNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaGlobalNetworkEndpointGroups %v exists", key),
		}
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "networkEndpointGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "networkEndpointGroups", key)

	m.Objects[*key] = &MockGlobalNetworkEndpointGroupsObj{obj}
	klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaGlobalNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaGlobalNetworkEndpointGroups %v not found", key),
		}
		klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaGlobalNetworkEndpointGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaGlobalNetworkEndpointGroups) Obj(o *computealpha.NetworkEndpointGroup) *MockGlobalNetworkEndpointGroupsObj {
	return &MockGlobalNetworkEndpointGroupsObj{o}
}

// AttachNetworkEndpoints is a mock for the corresponding method.
func (m *MockAlphaGlobalNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalNetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachNetworkEndpoints is a mock for the corresponding method.
func (m *MockAlphaGlobalNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalNetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// ListNetworkEndpoints is a mock for the corresponding method.
func (m *MockAlphaGlobalNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error) {
	if m.ListNetworkEndpointsHook != nil {
		return m.ListNetworkEndpointsHook(ctx, key, fl, m)
	}
	return nil, nil
}

// GCEAlphaGlobalNetworkEndpointGroups is a simplifying adapter for the GCE GlobalNetworkEndpointGroups.
type GCEAlphaGlobalNetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCEAlphaGlobalNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalNetworkEndpointGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.GlobalNetworkEndpointGroups.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all NetworkEndpointGroup objects.
func (g *GCEAlphaGlobalNetworkEndpointGroups) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.GlobalNetworkEndpointGroups.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.NetworkEndpointGroup
	f := func(l *computealpha.NetworkEndpointGroupList) error {
		klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCEAlphaGlobalNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computealpha.NetworkEndpointGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.GlobalNetworkEndpointGroups.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCEAlphaGlobalNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalNetworkEndpointGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalNetworkEndpointGroups.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AttachNetworkEndpoints is a method on GCEAlphaGlobalNetworkEndpointGroups.
func (g *GCEAlphaGlobalNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalNetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalNetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachNetworkEndpoints is a method on GCEAlphaGlobalNetworkEndpointGroups.
func (g *GCEAlphaGlobalNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computealpha.GlobalNetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.GlobalNetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListNetworkEndpoints is a method on GCEAlphaGlobalNetworkEndpointGroups.
func (g *GCEAlphaGlobalNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, fl *filter.F, options ...Option) ([]*computealpha.NetworkEndpointWithHealthStatus, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListNetworkEndpoints",
		Version:   meta.Version("alpha"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.GlobalNetworkEndpointGroups.ListNetworkEndpoints(projectID, key.Name)
	var all []*computealpha.NetworkEndpointWithHealthStatus
	f := func(l *computealpha.NetworkEndpointGroupsListNetworkEndpoints) error {
		klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// BetaGlobalNetworkEndpointGroups is an interface that allows for mocking of GlobalNetworkEndpointGroups.
type BetaGlobalNetworkEndpointGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.NetworkEndpointGroup, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AttachNetworkEndpoints(context.Context, *meta.Key, *computebeta.GlobalNetworkEndpointGroupsAttachEndpointsRequest, ...Option) error
	DetachNetworkEndpoints(context.Context, *meta.Key, *computebeta.GlobalNetworkEndpointGroupsDetachEndpointsRequest, ...Option) error
	ListNetworkEndpoints(context.Context, *meta.Key, *filter.F, ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error)
}

// NewMockBetaGlobalNetworkEndpointGroups returns a new mock for GlobalNetworkEndpointGroups.
func NewMockBetaGlobalNetworkEndpointGroups(pr ProjectRouter, objs map[meta.Key]*MockGlobalNetworkEndpointGroupsObj) *MockBetaGlobalNetworkEndpointGroups {
	mock := &MockBetaGlobalNetworkEndpointGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaGlobalNetworkEndpointGroups is the mock for GlobalNetworkEndpointGroups.
type MockBetaGlobalNetworkEndpointGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalNetworkEndpointGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockBetaGlobalNetworkEndpointGroups, options ...Option) (bool, *computebeta.NetworkEndpointGroup, error)
	ListHook                   func(ctx context.Context, fl *filter.F, m *MockBetaGlobalNetworkEndpointGroups, options ...Option) (bool, []*computebeta.NetworkEndpointGroup, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, m *MockBetaGlobalNetworkEndpointGroups, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockBetaGlobalNetworkEndpointGroups, options ...Option) (bool, error)
	AttachNetworkEndpointsHook func(context.Context, *meta.Key, *computebeta.GlobalNetworkEndpointGroupsAttachEndpointsRequest, *MockBetaGlobalNetworkEndpointGroups, ...Option) error
	DetachNetworkEndpointsHook func(context.Context, *meta.Key, *computebeta.GlobalNetworkEndpointGroupsDetachEndpointsRequest, *MockBetaGlobalNetworkEndpointGroups, ...Option) error
	ListNetworkEndpointsHook   func(context.Context, *meta.Key, *filter.F, *MockBetaGlobalNetworkEndpointGroups, ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaGlobalNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaGlobalNetworkEndpointGroups %v not found", key),
	}
	klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaGlobalNetworkEndpointGroups) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.NetworkEndpointGroup
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaGlobalNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaGlobalNetworkEndpointGroups %v exists", key),
		}
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "networkEndpointGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "networkEndpointGroups", key)

	m.Objects[*key] = &MockGlobalNetworkEndpointGroupsObj{obj}
	klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaGlobalNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaGlobalNetworkEndpointGroups %v not found", key),
		}
		klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaGlobalNetworkEndpointGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaGlobalNetworkEndpointGroups) Obj(o *computebeta.NetworkEndpointGroup) *MockGlobalNetworkEndpointGroupsObj {
	return &MockGlobalNetworkEndpointGroupsObj{o}
}

// AttachNetworkEndpoints is a mock for the corresponding method.
func (m *MockBetaGlobalNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalNetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachNetworkEndpoints is a mock for the corresponding method.
func (m *MockBetaGlobalNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalNetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// ListNetworkEndpoints is a mock for the corresponding method.
func (m *MockBetaGlobalNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error) {
	if m.ListNetworkEndpointsHook != nil {
		return m.ListNetworkEndpointsHook(ctx, key, fl, m)
	}
	return nil, nil
}

// GCEBetaGlobalNetworkEndpointGroups is a simplifying adapter for the GCE GlobalNetworkEndpointGroups.
type GCEBetaGlobalNetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCEBetaGlobalNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalNetworkEndpointGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.GlobalNetworkEndpointGroups.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all NetworkEndpointGroup objects.
func (g *GCEBetaGlobalNetworkEndpointGroups) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.GlobalNetworkEndpointGroups.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.NetworkEndpointGroup
	f := func(l *computebeta.NetworkEndpointGroupList) error {
		klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCEBetaGlobalNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computebeta.NetworkEndpointGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalNetworkEndpointGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.GlobalNetworkEndpointGroups.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCEBetaGlobalNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalNetworkEndpointGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalNetworkEndpointGroups.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AttachNetworkEndpoints is a method on GCEBetaGlobalNetworkEndpointGroups.
func (g *GCEBetaGlobalNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalNetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalNetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachNetworkEndpoints is a method on GCEBetaGlobalNetworkEndpointGroups.
func (g *GCEBetaGlobalNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computebeta.GlobalNetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.GlobalNetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListNetworkEndpoints is a method on GCEBetaGlobalNetworkEndpointGroups.
func (g *GCEBetaGlobalNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, fl *filter.F, options ...Option) ([]*computebeta.NetworkEndpointWithHealthStatus, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListNetworkEndpoints",
		Version:   meta.Version("beta"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.GlobalNetworkEndpointGroups.ListNetworkEndpoints(projectID, key.Name)
	var all []*computebeta.NetworkEndpointWithHealthStatus
	f := func(l *computebeta.NetworkEndpointGroupsListNetworkEndpoints) error {
		klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// GlobalNetworkEndpointGroups is an interface that allows for mocking of GlobalNetworkEndpointGroups.
type GlobalNetworkEndpointGroups interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.NetworkEndpointGroup, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointGroup, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AttachNetworkEndpoints(context.Context, *meta.Key, *computega.GlobalNetworkEndpointGroupsAttachEndpointsRequest, ...Option) error
	DetachNetworkEndpoints(context.Context, *meta.Key, *computega.GlobalNetworkEndpointGroupsDetachEndpointsRequest, ...Option) error
	ListNetworkEndpoints(context.Context, *meta.Key, *filter.F, ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error)
}

// NewMockGlobalNetworkEndpointGroups returns a new mock for GlobalNetworkEndpointGroups.
func NewMockGlobalNetworkEndpointGroups(pr ProjectRouter, objs map[meta.Key]*MockGlobalNetworkEndpointGroupsObj) *MockGlobalNetworkEndpointGroups {
	mock := &MockGlobalNetworkEndpointGroups{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockGlobalNetworkEndpointGroups is the mock for GlobalNetworkEndpointGroups.
type MockGlobalNetworkEndpointGroups struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockGlobalNetworkEndpointGroupsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                    func(ctx context.Context, key *meta.Key, m *MockGlobalNetworkEndpointGroups, options ...Option) (bool, *computega.NetworkEndpointGroup, error)
	ListHook                   func(ctx context.Context, fl *filter.F, m *MockGlobalNetworkEndpointGroups, options ...Option) (bool, []*computega.NetworkEndpointGroup, error)
	InsertHook                 func(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, m *MockGlobalNetworkEndpointGroups, options ...Option) (bool, error)
	DeleteHook                 func(ctx context.Context, key *meta.Key, m *MockGlobalNetworkEndpointGroups, options ...Option) (bool, error)
	AttachNetworkEndpointsHook func(context.Context, *meta.Key, *computega.GlobalNetworkEndpointGroupsAttachEndpointsRequest, *MockGlobalNetworkEndpointGroups, ...Option) error
	DetachNetworkEndpointsHook func(context.Context, *meta.Key, *computega.GlobalNetworkEndpointGroupsDetachEndpointsRequest, *MockGlobalNetworkEndpointGroups, ...Option) error
	ListNetworkEndpointsHook   func(context.Context, *meta.Key, *filter.F, *MockGlobalNetworkEndpointGroups, ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockGlobalNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.NetworkEndpointGroup, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockGlobalNetworkEndpointGroups %v not found", key),
	}
	klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockGlobalNetworkEndpointGroups) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointGroup, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockGlobalNetworkEndpointGroups.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.NetworkEndpointGroup
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockGlobalNetworkEndpointGroups.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockGlobalNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockGlobalNetworkEndpointGroups %v exists", key),
		}
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "networkEndpointGroups")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "networkEndpointGroups", key)

	m.Objects[*key] = &MockGlobalNetworkEndpointGroupsObj{obj}
	klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockGlobalNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockGlobalNetworkEndpointGroups %v not found", key),
		}
		klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockGlobalNetworkEndpointGroups.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockGlobalNetworkEndpointGroups) Obj(o *computega.NetworkEndpointGroup) *MockGlobalNetworkEndpointGroupsObj {
	return &MockGlobalNetworkEndpointGroupsObj{o}
}

// AttachNetworkEndpoints is a mock for the corresponding method.
func (m *MockGlobalNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.GlobalNetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	if m.AttachNetworkEndpointsHook != nil {
		return m.AttachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// DetachNetworkEndpoints is a mock for the corresponding method.
func (m *MockGlobalNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.GlobalNetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	if m.DetachNetworkEndpointsHook != nil {
		return m.DetachNetworkEndpointsHook(ctx, key, arg0, m)
	}
	return nil
}

// ListNetworkEndpoints is a mock for the corresponding method.
func (m *MockGlobalNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error) {
	if m.ListNetworkEndpointsHook != nil {
		return m.ListNetworkEndpointsHook(ctx, key, fl, m)
	}
	return nil, nil
}

// GCEGlobalNetworkEndpointGroups is a simplifying adapter for the GCE GlobalNetworkEndpointGroups.
type GCEGlobalNetworkEndpointGroups struct {
	s *Service
}

// Get the NetworkEndpointGroup named by key.
func (g *GCEGlobalNetworkEndpointGroups) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalNetworkEndpointGroups.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}

	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.GlobalNetworkEndpointGroups.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all NetworkEndpointGroup objects.
func (g *GCEGlobalNetworkEndpointGroups) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointGroup, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.GlobalNetworkEndpointGroups.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.NetworkEndpointGroup
	f := func(l *computega.NetworkEndpointGroupList) error {
		klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert NetworkEndpointGroup with key of value obj.
func (g *GCEGlobalNetworkEndpointGroups) Insert(ctx context.Context, key *meta.Key, obj *computega.NetworkEndpointGroup, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalNetworkEndpointGroups.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.GlobalNetworkEndpointGroups.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the NetworkEndpointGroup referenced by key.
func (g *GCEGlobalNetworkEndpointGroups) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalNetworkEndpointGroups.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalNetworkEndpointGroups.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AttachNetworkEndpoints is a method on GCEGlobalNetworkEndpointGroups.
func (g *GCEGlobalNetworkEndpointGroups) AttachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.GlobalNetworkEndpointGroupsAttachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AttachNetworkEndpoints",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalNetworkEndpointGroups.AttachNetworkEndpoints(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.AttachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// DetachNetworkEndpoints is a method on GCEGlobalNetworkEndpointGroups.
func (g *GCEGlobalNetworkEndpointGroups) DetachNetworkEndpoints(ctx context.Context, key *meta.Key, arg0 *computega.GlobalNetworkEndpointGroupsDetachEndpointsRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "DetachNetworkEndpoints",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.GlobalNetworkEndpointGroups.DetachNetworkEndpoints(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.DetachNetworkEndpoints(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ListNetworkEndpoints is a method on GCEGlobalNetworkEndpointGroups.
func (g *GCEGlobalNetworkEndpointGroups) ListNetworkEndpoints(ctx context.Context, key *meta.Key, fl *filter.F, options ...Option) ([]*computega.NetworkEndpointWithHealthStatus, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "GlobalNetworkEndpointGroups")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListNetworkEndpoints",
		Version:   meta.Version("ga"),
		Service:   "GlobalNetworkEndpointGroups",
	}
	klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.GlobalNetworkEndpointGroups.ListNetworkEndpoints(projectID, key.Name)
	var all []*computega.NetworkEndpointWithHealthStatus
	f := func(l *computega.NetworkEndpointGroupsListNetworkEndpoints) error {
		klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...): page %+v", ctx, key, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = [%v items], %v", ctx, key, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEGlobalNetworkEndpointGroups.ListNetworkEndpoints(%v, %v, ...) = %v, %v", ctx, key, asStr, nil)
	}
	return all, nil
}

// Projects is an interface that allows for mocking of Projects.
type Projects interface {
	// ProjectsOps is an interface with additional non-CRUD type methods.
	// This interface is expected to be implemented by hand (non-autogenerated).
	ProjectsOps
}

// NewMockProjects returns a new mock for Projects.
func NewMockProjects(pr ProjectRouter, objs map[meta.Key]*MockProjectsObj) *MockProjects {
	mock := &MockProjects{
		ProjectRouter: pr,

		Objects: objs,
	}
	return mock
}

// MockProjects is the mock for Projects.
type MockProjects struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockProjectsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Obj wraps the object for use in the mock.
func (m *MockProjects) Obj(o *computega.Project) *MockProjectsObj {
	return &MockProjectsObj{o}
}

// GCEProjects is a simplifying adapter for the GCE Projects.
type GCEProjects struct {
	s *Service
}

// Regions is an interface that allows for mocking of Regions.
type Regions interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Region, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Region, error)
}

// NewMockRegions returns a new mock for Regions.
func NewMockRegions(pr ProjectRouter, objs map[meta.Key]*MockRegionsObj) *MockRegions {
	mock := &MockRegions{
		ProjectRouter: pr,

		Objects:  objs,
		GetError: map[meta.Key]error{},
	}
	return mock
}

// MockRegions is the mock for Regions.
type MockRegions struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError  map[meta.Key]error
	ListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook  func(ctx context.Context, key *meta.Key, m *MockRegions, options ...Option) (bool, *computega.Region, error)
	ListHook func(ctx context.Context, fl *filter.F, m *MockRegions, options ...Option) (bool, []*computega.Region, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegions) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Region, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegions.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegions.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegions.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegions %v not found", key),
	}
	klog.V(5).Infof("MockRegions.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockRegions) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Region, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegions.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegions.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Region
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegions.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegions) Obj(o *computega.Region) *MockRegionsObj {
	return &MockRegionsObj{o}
}

// GCERegions is a simplifying adapter for the GCE Regions.
type GCERegions struct {
	s *Service
}

// Get the Region named by key.
func (g *GCERegions) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Region, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegions.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegions.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Regions")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Regions",
	}

	klog.V(5).Infof("GCERegions.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegions.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Regions.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegions.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Region objects.
func (g *GCERegions) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Region, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegions.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Regions")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Regions",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegions.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Regions.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Region
	f := func(l *computega.RegionList) error {
		klog.V(5).Infof("GCERegions.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegions.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegions.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegions.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// AlphaRouters is an interface that allows for mocking of Routers.
type AlphaRouters interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Router, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Router, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Router, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.Router, error)
	GetRouterStatus(context.Context, *meta.Key, ...Option) (*computealpha.RouterStatusResponse, error)
	Patch(context.Context, *meta.Key, *computealpha.Router, ...Option) error
	Preview(context.Context, *meta.Key, *computealpha.Router, ...Option) (*computealpha.RoutersPreviewResponse, error)
	TestIamPermissions(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, ...Option) (*computealpha.TestPermissionsResponse, error)
}

// NewMockAlphaRouters returns a new mock for Routers.
func NewMockAlphaRouters(pr ProjectRouter, objs map[meta.Key]*MockRoutersObj) *MockAlphaRouters {
	mock := &MockAlphaRouters{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRouters is the mock for Routers.
type MockAlphaRouters struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRoutersObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaRouters, options ...Option) (bool, *computealpha.Router, error)
	ListHook               func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRouters, options ...Option) (bool, []*computealpha.Router, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.Router, m *MockAlphaRouters, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaRouters, options ...Option) (bool, error)
	AggregatedListHook     func(ctx context.Context, fl *filter.F, m *MockAlphaRouters, options ...Option) (bool, map[string][]*computealpha.Router, error)
	GetRouterStatusHook    func(context.Context, *meta.Key, *MockAlphaRouters, ...Option) (*computealpha.RouterStatusResponse, error)
	PatchHook              func(context.Context, *meta.Key, *computealpha.Router, *MockAlphaRouters, ...Option) error
	PreviewHook            func(context.Context, *meta.Key, *computealpha.Router, *MockAlphaRouters, ...Option) (*computealpha.RoutersPreviewResponse, error)
	TestIamPermissionsHook func(context.Context, *meta.Key, *computealpha.TestPermissionsRequest, *MockAlphaRouters, ...Option) (*computealpha.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRouters) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Router, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRouters.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRouters.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRouters.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRouters %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRouters.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRouters) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Router, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRouters.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRouters.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Router
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRouters.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRouters) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Router, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRouters %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "routers")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "routers", key)

	m.Objects[*key] = &MockRoutersObj{obj}
	klog.V(5).Infof("MockAlphaRouters.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRouters) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRouters.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRouters %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRouters.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockAlphaRouters) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.Router, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRouters.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockAlphaRouters.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computealpha.Router{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToAlpha().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockAlphaRouters.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToAlpha())
	}
	klog.V(5).Infof("MockAlphaRouters.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRouters) Obj(o *computealpha.Router) *MockRoutersObj {
	return &MockRoutersObj{o}
}

// GetRouterStatus is a mock for the corresponding method.
func (m *MockAlphaRouters) GetRouterStatus(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.RouterStatusResponse, error) {
	if m.GetRouterStatusHook != nil {
		return m.GetRouterStatusHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetRouterStatusHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaRouters) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Router, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Preview is a mock for the corresponding method.
func (m *MockAlphaRouters) Preview(ctx context.Context, key *meta.Key, arg0 *computealpha.Router, options ...Option) (*computealpha.RoutersPreviewResponse, error) {
	if m.PreviewHook != nil {
		return m.PreviewHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("PreviewHook must be set")
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockAlphaRouters) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEAlphaRouters is a simplifying adapter for the GCE Routers.
type GCEAlphaRouters struct {
	s *Service
}

// Get the Router named by key.
func (g *GCEAlphaRouters) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}

	klog.V(5).Infof("GCEAlphaRouters.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Routers.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRouters.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Router objects.
func (g *GCEAlphaRouters) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRouters.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.Routers.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Router
	f := func(l *computealpha.RouterList) error {
		klog.V(5).Infof("GCEAlphaRouters.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRouters.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRouters.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRouters.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Router with key of value obj.
func (g *GCEAlphaRouters) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Router, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEAlphaRouters.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Routers.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRouters.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Router referenced by key.
func (g *GCEAlphaRouters) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEAlphaRouters.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Routers.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRouters.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEAlphaRouters) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computealpha.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}

	klog.V(5).Infof("GCEAlphaRouters.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEAlphaRouters.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Alpha.Routers.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computealpha.Router{}
	f := func(l *computealpha.RouterAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEAlphaRouters.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.Routers...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRouters.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRouters.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRouters.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// GetRouterStatus is a method on GCEAlphaRouters.
func (g *GCEAlphaRouters) GetRouterStatus(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.RouterStatusResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.GetRouterStatus(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.GetRouterStatus(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetRouterStatus",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEAlphaRouters.GetRouterStatus(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.GetRouterStatus(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Routers.GetRouterStatus(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRouters.GetRouterStatus(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEAlphaRouters.
func (g *GCEAlphaRouters) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Router, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEAlphaRouters.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Routers.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRouters.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRouters.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Preview is a method on GCEAlphaRouters.
func (g *GCEAlphaRouters) Preview(ctx context.Context, key *meta.Key, arg0 *computealpha.Router, options ...Option) (*computealpha.RoutersPreviewResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.Preview(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.Preview(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Preview",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEAlphaRouters.Preview(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.Preview(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Routers.Preview(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRouters.Preview(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// TestIamPermissions is a method on GCEAlphaRouters.
func (g *GCEAlphaRouters) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computealpha.TestPermissionsRequest, options ...Option) (*computealpha.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRouters.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRouters.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("alpha"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEAlphaRouters.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRouters.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Routers.TestIamPermissions(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEAlphaRouters.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// BetaRouters is an interface that allows for mocking of Routers.
type BetaRouters interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Router, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Router, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Router, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.Router, error)
	GetRouterStatus(context.Context, *meta.Key, ...Option) (*computebeta.RouterStatusResponse, error)
	Patch(context.Context, *meta.Key, *computebeta.Router, ...Option) error
	Preview(context.Context, *meta.Key, *computebeta.Router, ...Option) (*computebeta.RoutersPreviewResponse, error)
	TestIamPermissions(context.Context, *meta.Key, *computebeta.TestPermissionsRequest, ...Option) (*computebeta.TestPermissionsResponse, error)
}

// NewMockBetaRouters returns a new mock for Routers.
func NewMockBetaRouters(pr ProjectRouter, objs map[meta.Key]*MockRoutersObj) *MockBetaRouters {
	mock := &MockBetaRouters{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRouters is the mock for Routers.
type MockBetaRouters struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRoutersObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockBetaRouters, options ...Option) (bool, *computebeta.Router, error)
	ListHook               func(ctx context.Context, region string, fl *filter.F, m *MockBetaRouters, options ...Option) (bool, []*computebeta.Router, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computebeta.Router, m *MockBetaRouters, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockBetaRouters, options ...Option) (bool, error)
	AggregatedListHook     func(ctx context.Context, fl *filter.F, m *MockBetaRouters, options ...Option) (bool, map[string][]*computebeta.Router, error)
	GetRouterStatusHook    func(context.Context, *meta.Key, *MockBetaRouters, ...Option) (*computebeta.RouterStatusResponse, error)
	PatchHook              func(context.Context, *meta.Key, *computebeta.Router, *MockBetaRouters, ...Option) error
	PreviewHook            func(context.Context, *meta.Key, *computebeta.Router, *MockBetaRouters, ...Option) (*computebeta.RoutersPreviewResponse, error)
	TestIamPermissionsHook func(context.Context, *meta.Key, *computebeta.TestPermissionsRequest, *MockBetaRouters, ...Option) (*computebeta.TestPermissionsResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRouters) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Router, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRouters.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRouters.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRouters.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRouters %v not found", key),
	}
	klog.V(5).Infof("MockBetaRouters.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRouters) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Router, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRouters.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRouters.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Router
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRouters.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRouters) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Router, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRouters %v exists", key),
		}
		klog.V(5).Infof("MockBetaRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "routers")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "routers", key)

	m.Objects[*key] = &MockRoutersObj{obj}
	klog.V(5).Infof("MockBetaRouters.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRouters) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRouters.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRouters %v not found", key),
		}
		klog.V(5).Infof("MockBetaRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRouters.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockBetaRouters) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.Router, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRouters.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockBetaRouters.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computebeta.Router{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToBeta().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockBetaRouters.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToBeta())
	}
	klog.V(5).Infof("MockBetaRouters.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRouters) Obj(o *computebeta.Router) *MockRoutersObj {
	return &MockRoutersObj{o}
}

// GetRouterStatus is a mock for the corresponding method.
func (m *MockBetaRouters) GetRouterStatus(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.RouterStatusResponse, error) {
	if m.GetRouterStatusHook != nil {
		return m.GetRouterStatusHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetRouterStatusHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockBetaRouters) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Router, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Preview is a mock for the corresponding method.
func (m *MockBetaRouters) Preview(ctx context.Context, key *meta.Key, arg0 *computebeta.Router, options ...Option) (*computebeta.RoutersPreviewResponse, error) {
	if m.PreviewHook != nil {
		return m.PreviewHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("PreviewHook must be set")
}

// TestIamPermissions is a mock for the corresponding method.
func (m *MockBetaRouters) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computebeta.TestPermissionsRequest, options ...Option) (*computebeta.TestPermissionsResponse, error) {
	if m.TestIamPermissionsHook != nil {
		return m.TestIamPermissionsHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("TestIamPermissionsHook must be set")
}

// GCEBetaRouters is a simplifying adapter for the GCE Routers.
type GCEBetaRouters struct {
	s *Service
}

// Get the Router named by key.
func (g *GCEBetaRouters) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}

	klog.V(5).Infof("GCEBetaRouters.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Routers.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRouters.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Router objects.
func (g *GCEBetaRouters) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRouters.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.Routers.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Router
	f := func(l *computebeta.RouterList) error {
		klog.V(5).Infof("GCEBetaRouters.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRouters.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRouters.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRouters.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Router with key of value obj.
func (g *GCEBetaRouters) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Router, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEBetaRouters.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Routers.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRouters.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRouters.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Router referenced by key.
func (g *GCEBetaRouters) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEBetaRouters.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Routers.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRouters.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCEBetaRouters) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computebeta.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}

	klog.V(5).Infof("GCEBetaRouters.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCEBetaRouters.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.Beta.Routers.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computebeta.Router{}
	f := func(l *computebeta.RouterAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCEBetaRouters.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.Routers...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRouters.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRouters.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRouters.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// GetRouterStatus is a method on GCEBetaRouters.
func (g *GCEBetaRouters) GetRouterStatus(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.RouterStatusResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.GetRouterStatus(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.GetRouterStatus(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetRouterStatus",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEBetaRouters.GetRouterStatus(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.GetRouterStatus(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Routers.GetRouterStatus(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaRouters.GetRouterStatus(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEBetaRouters.
func (g *GCEBetaRouters) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Router, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEBetaRouters.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Routers.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRouters.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRouters.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Preview is a method on GCEBetaRouters.
func (g *GCEBetaRouters) Preview(ctx context.Context, key *meta.Key, arg0 *computebeta.Router, options ...Option) (*computebeta.RoutersPreviewResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.Preview(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.Preview(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Preview",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEBetaRouters.Preview(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.Preview(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Routers.Preview(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaRouters.Preview(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// TestIamPermissions is a method on GCEBetaRouters.
func (g *GCEBetaRouters) TestIamPermissions(ctx context.Context, key *meta.Key, arg0 *computebeta.TestPermissionsRequest, options ...Option) (*computebeta.TestPermissionsResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRouters.TestIamPermissions(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRouters.TestIamPermissions(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "TestIamPermissions",
		Version:   meta.Version("beta"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCEBetaRouters.TestIamPermissions(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRouters.TestIamPermissions(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Routers.TestIamPermissions(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaRouters.TestIamPermissions(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Routers is an interface that allows for mocking of Routers.
type Routers interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Router, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Router, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Router, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.Router, error)
	GetRouterStatus(context.Context, *meta.Key, ...Option) (*computega.RouterStatusResponse, error)
	Patch(context.Context, *meta.Key, *computega.Router, ...Option) error
	Preview(context.Context, *meta.Key, *computega.Router, ...Option) (*computega.RoutersPreviewResponse, error)
}

// NewMockRouters returns a new mock for Routers.
func NewMockRouters(pr ProjectRouter, objs map[meta.Key]*MockRoutersObj) *MockRouters {
	mock := &MockRouters{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRouters is the mock for Routers.
type MockRouters struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRoutersObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError            map[meta.Key]error
	ListError           *error
	InsertError         map[meta.Key]error
	DeleteError         map[meta.Key]error
	AggregatedListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook             func(ctx context.Context, key *meta.Key, m *MockRouters, options ...Option) (bool, *computega.Router, error)
	ListHook            func(ctx context.Context, region string, fl *filter.F, m *MockRouters, options ...Option) (bool, []*computega.Router, error)
	InsertHook          func(ctx context.Context, key *meta.Key, obj *computega.Router, m *MockRouters, options ...Option) (bool, error)
	DeleteHook          func(ctx context.Context, key *meta.Key, m *MockRouters, options ...Option) (bool, error)
	AggregatedListHook  func(ctx context.Context, fl *filter.F, m *MockRouters, options ...Option) (bool, map[string][]*computega.Router, error)
	GetRouterStatusHook func(context.Context, *meta.Key, *MockRouters, ...Option) (*computega.RouterStatusResponse, error)
	PatchHook           func(context.Context, *meta.Key, *computega.Router, *MockRouters, ...Option) error
	PreviewHook         func(context.Context, *meta.Key, *computega.Router, *MockRouters, ...Option) (*computega.RoutersPreviewResponse, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRouters) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Router, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRouters.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRouters.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRouters.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRouters %v not found", key),
	}
	klog.V(5).Infof("MockRouters.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRouters) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Router, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRouters.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRouters.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Router
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRouters.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRouters) Insert(ctx context.Context, key *meta.Key, obj *computega.Router, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRouters %v exists", key),
		}
		klog.V(5).Infof("MockRouters.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "routers")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "routers", key)

	m.Objects[*key] = &MockRoutersObj{obj}
	klog.V(5).Infof("MockRouters.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRouters) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRouters.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRouters %v not found", key),
		}
		klog.V(5).Infof("MockRouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRouters.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// AggregatedList is a mock for AggregatedList.
func (m *MockRouters) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.Router, error) {
	if m.AggregatedListHook != nil {
		if intercept, objs, err := m.AggregatedListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockRouters.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.AggregatedListError != nil {
		err := *m.AggregatedListError
		klog.V(5).Infof("MockRouters.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
		return nil, err
	}

	objs := map[string][]*computega.Router{}
	for _, obj := range m.Objects {
		res, err := ParseResourceURL(obj.ToGA().SelfLink)
		if err != nil {
			klog.V(5).Infof("MockRouters.AggregatedList(%v, %v) = nil, %v", ctx, fl, err)
			return nil, err
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		location := aggregatedListKey(res.Key)
		objs[location] = append(objs[location], obj.ToGA())
	}
	klog.V(5).Infof("MockRouters.AggregatedList(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockRouters) Obj(o *computega.Router) *MockRoutersObj {
	return &MockRoutersObj{o}
}

// GetRouterStatus is a mock for the corresponding method.
func (m *MockRouters) GetRouterStatus(ctx context.Context, key *meta.Key, options ...Option) (*computega.RouterStatusResponse, error) {
	if m.GetRouterStatusHook != nil {
		return m.GetRouterStatusHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetRouterStatusHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockRouters) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Router, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// Preview is a mock for the corresponding method.
func (m *MockRouters) Preview(ctx context.Context, key *meta.Key, arg0 *computega.Router, options ...Option) (*computega.RoutersPreviewResponse, error) {
	if m.PreviewHook != nil {
		return m.PreviewHook(ctx, key, arg0, m)
	}
	return nil, fmt.Errorf("PreviewHook must be set")
}

// GCERouters is a simplifying adapter for the GCE Routers.
type GCERouters struct {
	s *Service
}

// Get the Router named by key.
func (g *GCERouters) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERouters.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}

	klog.V(5).Infof("GCERouters.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERouters.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Routers.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERouters.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Router objects.
func (g *GCERouters) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERouters.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.Routers.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Router
	f := func(l *computega.RouterList) error {
		klog.V(5).Infof("GCERouters.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERouters.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERouters.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERouters.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Router with key of value obj.
func (g *GCERouters) Insert(ctx context.Context, key *meta.Key, obj *computega.Router, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERouters.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCERouters.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERouters.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Routers.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERouters.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERouters.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Router referenced by key.
func (g *GCERouters) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERouters.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCERouters.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERouters.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Routers.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERouters.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERouters.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AggregatedList lists all resources of the given type across all locations.
func (g *GCERouters) AggregatedList(ctx context.Context, fl *filter.F, options ...Option) (map[string][]*computega.Router, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.AggregatedList(%v, %v) called", ctx, fl)

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AggregatedList",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}

	klog.V(5).Infof("GCERouters.AggregatedList(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(5).Infof("GCERouters.AggregatedList(%v, %v): RateLimiter error: %v", ctx, fl, err)
		return nil, err
	}

	call := g.s.GA.Routers.AggregatedList(projectID)
	call.Context(ctx)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	all := map[string][]*computega.Router{}
	f := func(l *computega.RouterAggregatedList) error {
		for k, v := range l.Items {
			klog.V(5).Infof("GCERouters.AggregatedList(%v, %v): page[%v]%+v", ctx, fl, k, v)
			all[k] = append(all[k], v.Routers...)
		}
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERouters.AggregatedList(%v, %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERouters.AggregatedList(%v, %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERouters.AggregatedList(%v, %v) = %v, %v", ctx, fl, asStr, nil)
	}
	return all, nil
}

// GetRouterStatus is a method on GCERouters.
func (g *GCERouters) GetRouterStatus(ctx context.Context, key *meta.Key, options ...Option) (*computega.RouterStatusResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.GetRouterStatus(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERouters.GetRouterStatus(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetRouterStatus",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCERouters.GetRouterStatus(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERouters.GetRouterStatus(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Routers.GetRouterStatus(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCERouters.GetRouterStatus(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCERouters.
func (g *GCERouters) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Router, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERouters.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCERouters.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERouters.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Routers.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERouters.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERouters.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Preview is a method on GCERouters.
func (g *GCERouters) Preview(ctx context.Context, key *meta.Key, arg0 *computega.Router, options ...Option) (*computega.RoutersPreviewResponse, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERouters.Preview(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERouters.Preview(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routers")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Preview",
		Version:   meta.Version("ga"),
		Service:   "Routers",
	}
	klog.V(5).Infof("GCERouters.Preview(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERouters.Preview(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Routers.Preview(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCERouters.Preview(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Routes is an interface that allows for mocking of Routes.
type Routes interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Route, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Route, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Route, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockRoutes returns a new mock for Routes.
func NewMockRoutes(pr ProjectRouter, objs map[meta.Key]*MockRoutesObj) *MockRoutes {
	mock := &MockRoutes{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRoutes is the mock for Routes.
type MockRoutes struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRoutesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockRoutes, options ...Option) (bool, *computega.Route, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockRoutes, options ...Option) (bool, []*computega.Route, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.Route, m *MockRoutes, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockRoutes, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRoutes) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Route, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRoutes.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRoutes.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRoutes.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRoutes %v not found", key),
	}
	klog.V(5).Infof("MockRoutes.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockRoutes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Route, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockRoutes.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRoutes.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Route
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRoutes.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRoutes) Insert(ctx context.Context, key *meta.Key, obj *computega.Route, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRoutes %v exists", key),
		}
		klog.V(5).Infof("MockRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "routes")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "routes", key)

	m.Objects[*key] = &MockRoutesObj{obj}
	klog.V(5).Infof("MockRoutes.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRoutes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRoutes.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRoutes %v not found", key),
		}
		klog.V(5).Infof("MockRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRoutes.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRoutes) Obj(o *computega.Route) *MockRoutesObj {
	return &MockRoutesObj{o}
}

// GCERoutes is a simplifying adapter for the GCE Routes.
type GCERoutes struct {
	s *Service
}

// Get the Route named by key.
func (g *GCERoutes) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Route, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERoutes.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERoutes.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Routes",
	}

	klog.V(5).Infof("GCERoutes.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERoutes.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Routes.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERoutes.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Route objects.
func (g *GCERoutes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Route, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERoutes.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Routes",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERoutes.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Routes.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Route
	f := func(l *computega.RouteList) error {
		klog.V(5).Infof("GCERoutes.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERoutes.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERoutes.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERoutes.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Route with key of value obj.
func (g *GCERoutes) Insert(ctx context.Context, key *meta.Key, obj *computega.Route, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERoutes.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERoutes.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Routes",
	}
	klog.V(5).Infof("GCERoutes.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERoutes.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Routes.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERoutes.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERoutes.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Route referenced by key.
func (g *GCERoutes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERoutes.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERoutes.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Routes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Routes",
	}
	klog.V(5).Infof("GCERoutes.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERoutes.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Routes.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERoutes.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// BetaSecurityPolicies is an interface that allows for mocking of SecurityPolicies.
type BetaSecurityPolicies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SecurityPolicy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.SecurityPolicy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.SecurityPolicy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AddRule(context.Context, *meta.Key, *computebeta.SecurityPolicyRule, ...Option) error
	GetRule(context.Context, *meta.Key, ...Option) (*computebeta.SecurityPolicyRule, error)
	Patch(context.Context, *meta.Key, *computebeta.SecurityPolicy, ...Option) error
	PatchRule(context.Context, *meta.Key, *computebeta.SecurityPolicyRule, ...Option) error
	RemoveRule(context.Context, *meta.Key, ...Option) error
}

// NewMockBetaSecurityPolicies returns a new mock for SecurityPolicies.
func NewMockBetaSecurityPolicies(pr ProjectRouter, objs map[meta.Key]*MockSecurityPoliciesObj) *MockBetaSecurityPolicies {
	mock := &MockBetaSecurityPolicies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaSecurityPolicies is the mock for SecurityPolicies.
type MockBetaSecurityPolicies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSecurityPoliciesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook        func(ctx context.Context, key *meta.Key, m *MockBetaSecurityPolicies, options ...Option) (bool, *computebeta.SecurityPolicy, error)
	ListHook       func(ctx context.Context, fl *filter.F, m *MockBetaSecurityPolicies, options ...Option) (bool, []*computebeta.SecurityPolicy, error)
	InsertHook     func(ctx context.Context, key *meta.Key, obj *computebeta.SecurityPolicy, m *MockBetaSecurityPolicies, options ...Option) (bool, error)
	DeleteHook     func(ctx context.Context, key *meta.Key, m *MockBetaSecurityPolicies, options ...Option) (bool, error)
	AddRuleHook    func(context.Context, *meta.Key, *computebeta.SecurityPolicyRule, *MockBetaSecurityPolicies, ...Option) error
	GetRuleHook    func(context.Context, *meta.Key, *MockBetaSecurityPolicies, ...Option) (*computebeta.SecurityPolicyRule, error)
	PatchHook      func(context.Context, *meta.Key, *computebeta.SecurityPolicy, *MockBetaSecurityPolicies, ...Option) error
	PatchRuleHook  func(context.Context, *meta.Key, *computebeta.SecurityPolicyRule, *MockBetaSecurityPolicies, ...Option) error
	RemoveRuleHook func(context.Context, *meta.Key, *MockBetaSecurityPolicies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaSecurityPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SecurityPolicy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaSecurityPolicies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaSecurityPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaSecurityPolicies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaSecurityPolicies %v not found", key),
	}
	klog.V(5).Infof("MockBetaSecurityPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaSecurityPolicies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.SecurityPolicy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaSecurityPolicies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaSecurityPolicies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.SecurityPolicy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaSecurityPolicies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaSecurityPolicies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.SecurityPolicy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaSecurityPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaSecurityPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaSecurityPolicies %v exists", key),
		}
		klog.V(5).Infof("MockBetaSecurityPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "securityPolicies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "securityPolicies", key)

	m.Objects[*key] = &MockSecurityPoliciesObj{obj}
	klog.V(5).Infof("MockBetaSecurityPolicies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaSecurityPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaSecurityPolicies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaSecurityPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaSecurityPolicies %v not found", key),
		}
		klog.V(5).Infof("MockBetaSecurityPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaSecurityPolicies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaSecurityPolicies) Obj(o *computebeta.SecurityPolicy) *MockSecurityPoliciesObj {
	return &MockSecurityPoliciesObj{o}
}

// AddRule is a mock for the corresponding method.
func (m *MockBetaSecurityPolicies) AddRule(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicyRule, options ...Option) error {
	if m.AddRuleHook != nil {
		return m.AddRuleHook(ctx, key, arg0, m)
	}
	return nil
}

// GetRule is a mock for the corresponding method.
func (m *MockBetaSecurityPolicies) GetRule(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SecurityPolicyRule, error) {
	if m.GetRuleHook != nil {
		return m.GetRuleHook(ctx, key, m)
	}
	return nil, fmt.Errorf("GetRuleHook must be set")
}

// Patch is a mock for the corresponding method.
func (m *MockBetaSecurityPolicies) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicy, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// PatchRule is a mock for the corresponding method.
func (m *MockBetaSecurityPolicies) PatchRule(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicyRule, options ...Option) error {
	if m.PatchRuleHook != nil {
		return m.PatchRuleHook(ctx, key, arg0, m)
	}
	return nil
}

// RemoveRule is a mock for the corresponding method.
func (m *MockBetaSecurityPolicies) RemoveRule(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.RemoveRuleHook != nil {
		return m.RemoveRuleHook(ctx, key, m)
	}
	return nil
}

// GCEBetaSecurityPolicies is a simplifying adapter for the GCE SecurityPolicies.
type GCEBetaSecurityPolicies struct {
	s *Service
}

// Get the SecurityPolicy named by key.
func (g *GCEBetaSecurityPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SecurityPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}

	klog.V(5).Infof("GCEBetaSecurityPolicies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.SecurityPolicies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaSecurityPolicies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SecurityPolicy objects.
func (g *GCEBetaSecurityPolicies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.SecurityPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.SecurityPolicies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.SecurityPolicy
	f := func(l *computebeta.SecurityPolicyList) error {
		klog.V(5).Infof("GCEBetaSecurityPolicies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSecurityPolicies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaSecurityPolicies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaSecurityPolicies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SecurityPolicy with key of value obj.
func (g *GCEBetaSecurityPolicies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.SecurityPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.SecurityPolicies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaSecurityPolicies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SecurityPolicy referenced by key.
func (g *GCEBetaSecurityPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.SecurityPolicies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaSecurityPolicies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AddRule is a method on GCEBetaSecurityPolicies.
func (g *GCEBetaSecurityPolicies) AddRule(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicyRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.AddRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.AddRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddRule",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.AddRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.AddRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.SecurityPolicies.AddRule(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSecurityPolicies.AddRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaSecurityPolicies.AddRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// GetRule is a method on GCEBetaSecurityPolicies.
func (g *GCEBetaSecurityPolicies) GetRule(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SecurityPolicyRule, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.GetRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.GetRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "GetRule",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.GetRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.GetRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.SecurityPolicies.GetRule(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	klog.V(4).Infof("GCEBetaSecurityPolicies.GetRule(%v, %v, ...) = %+v, %v", ctx, key, v, err)
	return v, err
}

// Patch is a method on GCEBetaSecurityPolicies.
func (g *GCEBetaSecurityPolicies) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.SecurityPolicies.Patch(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSecurityPolicies.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaSecurityPolicies.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// PatchRule is a method on GCEBetaSecurityPolicies.
func (g *GCEBetaSecurityPolicies) PatchRule(ctx context.Context, key *meta.Key, arg0 *computebeta.SecurityPolicyRule, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.PatchRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.PatchRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "PatchRule",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.PatchRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.PatchRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.SecurityPolicies.PatchRule(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSecurityPolicies.PatchRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaSecurityPolicies.PatchRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RemoveRule is a method on GCEBetaSecurityPolicies.
func (g *GCEBetaSecurityPolicies) RemoveRule(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSecurityPolicies.RemoveRule(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSecurityPolicies.RemoveRule(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SecurityPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveRule",
		Version:   meta.Version("beta"),
		Service:   "SecurityPolicies",
	}
	klog.V(5).Infof("GCEBetaSecurityPolicies.RemoveRule(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSecurityPolicies.RemoveRule(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.SecurityPolicies.RemoveRule(projectID, key.Name)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSecurityPolicies.RemoveRule(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaSecurityPolicies.RemoveRule(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// ServiceAttachments is an interface that allows for mocking of ServiceAttachments.
type ServiceAttachments interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ServiceAttachment, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.ServiceAttachment, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.ServiceAttachment, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computega.ServiceAttachment, ...Option) error
}

// NewMockServiceAttachments returns a new mock for ServiceAttachments.
func NewMockServiceAttachments(pr ProjectRouter, objs map[meta.Key]*MockServiceAttachmentsObj) *MockServiceAttachments {
	mock := &MockServiceAttachments{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockServiceAttachments is the mock for ServiceAttachments.
type MockServiceAttachments struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockServiceAttachmentsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockServiceAttachments, options ...Option) (bool, *computega.ServiceAttachment, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockServiceAttachments, options ...Option) (bool, []*computega.ServiceAttachment, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.ServiceAttachment, m *MockServiceAttachments, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockServiceAttachments, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *computega.ServiceAttachment, *MockServiceAttachments, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockServiceAttachments) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ServiceAttachment, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockServiceAttachments.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockServiceAttachments.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockServiceAttachments.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockServiceAttachments %v not found", key),
	}
	klog.V(5).Infof("MockServiceAttachments.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockServiceAttachments) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.ServiceAttachment, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockServiceAttachments.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockServiceAttachments.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.ServiceAttachment
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockServiceAttachments.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockServiceAttachments) Insert(ctx context.Context, key *meta.Key, obj *computega.ServiceAttachment, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockServiceAttachments %v exists", key),
		}
		klog.V(5).Infof("MockServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "serviceAttachments")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "serviceAttachments", key)

	m.Objects[*key] = &MockServiceAttachmentsObj{obj}
	klog.V(5).Infof("MockServiceAttachments.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockServiceAttachments) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockServiceAttachments %v not found", key),
		}
		klog.V(5).Infof("MockServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockServiceAttachments.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockServiceAttachments) Obj(o *computega.ServiceAttachment) *MockServiceAttachmentsObj {
	return &MockServiceAttachmentsObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockServiceAttachments) Patch(ctx context.Context, key *meta.Key, arg0 *computega.ServiceAttachment, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEServiceAttachments is a simplifying adapter for the GCE ServiceAttachments.
type GCEServiceAttachments struct {
	s *Service
}

// Get the ServiceAttachment named by key.
func (g *GCEServiceAttachments) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.ServiceAttachment, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEServiceAttachments.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEServiceAttachments.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "ServiceAttachments",
	}

	klog.V(5).Infof("GCEServiceAttachments.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEServiceAttachments.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.ServiceAttachments.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEServiceAttachments.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ServiceAttachment objects.
func (g *GCEServiceAttachments) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.ServiceAttachment, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEServiceAttachments.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "ServiceAttachments",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEServiceAttachments.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.ServiceAttachments.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.ServiceAttachment
	f := func(l *computega.ServiceAttachmentList) error {
		klog.V(5).Infof("GCEServiceAttachments.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEServiceAttachments.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEServiceAttachments.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEServiceAttachments.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ServiceAttachment with key of value obj.
func (g *GCEServiceAttachments) Insert(ctx context.Context, key *meta.Key, obj *computega.ServiceAttachment, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEServiceAttachments.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEServiceAttachments.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEServiceAttachments.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEServiceAttachments.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.ServiceAttachments.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEServiceAttachments.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEServiceAttachments.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ServiceAttachment referenced by key.
func (g *GCEServiceAttachments) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEServiceAttachments.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEServiceAttachments.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ServiceAttachments")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEServiceAttachments.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEServiceAttachments.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.ServiceAttachments.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEServiceAttachments.
func (g *GCEServiceAttachments) Patch(ctx context.Context, key *meta.Key, arg0 *computega.ServiceAttachment, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEServiceAttachments.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEServiceAttachments.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "ServiceAttachments")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEServiceAttachments.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEServiceAttachments.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.ServiceAttachments.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEServiceAttachments.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEServiceAttachments.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaServiceAttachments is an interface that allows for mocking of ServiceAttachments.
type BetaServiceAttachments interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ServiceAttachment, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.ServiceAttachment, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.ServiceAttachment, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computebeta.ServiceAttachment, ...Option) error
}

// NewMockBetaServiceAttachments returns a new mock for ServiceAttachments.
func NewMockBetaServiceAttachments(pr ProjectRouter, objs map[meta.Key]*MockServiceAttachmentsObj) *MockBetaServiceAttachments {
	mock := &MockBetaServiceAttachments{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaServiceAttachments is the mock for ServiceAttachments.
type MockBetaServiceAttachments struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockServiceAttachmentsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaServiceAttachments, options ...Option) (bool, *computebeta.ServiceAttachment, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockBetaServiceAttachments, options ...Option) (bool, []*computebeta.ServiceAttachment, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.ServiceAttachment, m *MockBetaServiceAttachments, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaServiceAttachments, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *computebeta.ServiceAttachment, *MockBetaServiceAttachments, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaServiceAttachments) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ServiceAttachment, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaServiceAttachments.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaServiceAttachments.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaServiceAttachments.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaServiceAttachments %v not found", key),
	}
	klog.V(5).Infof("MockBetaServiceAttachments.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaServiceAttachments) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.ServiceAttachment, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaServiceAttachments.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaServiceAttachments.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.ServiceAttachment
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaServiceAttachments.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaServiceAttachments) Insert(ctx context.Context, key *meta.Key, obj *computebeta.ServiceAttachment, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaServiceAttachments %v exists", key),
		}
		klog.V(5).Infof("MockBetaServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "serviceAttachments")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "serviceAttachments", key)

	m.Objects[*key] = &MockServiceAttachmentsObj{obj}
	klog.V(5).Infof("MockBetaServiceAttachments.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaServiceAttachments) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaServiceAttachments %v not found", key),
		}
		klog.V(5).Infof("MockBetaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaServiceAttachments.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaServiceAttachments) Obj(o *computebeta.ServiceAttachment) *MockServiceAttachmentsObj {
	return &MockServiceAttachmentsObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockBetaServiceAttachments) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.ServiceAttachment, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaServiceAttachments is a simplifying adapter for the GCE ServiceAttachments.
type GCEBetaServiceAttachments struct {
	s *Service
}

// Get the ServiceAttachment named by key.
func (g *GCEBetaServiceAttachments) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.ServiceAttachment, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaServiceAttachments.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaServiceAttachments.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "ServiceAttachments",
	}

	klog.V(5).Infof("GCEBetaServiceAttachments.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaServiceAttachments.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.ServiceAttachments.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaServiceAttachments.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ServiceAttachment objects.
func (g *GCEBetaServiceAttachments) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.ServiceAttachment, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaServiceAttachments.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "ServiceAttachments",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaServiceAttachments.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.ServiceAttachments.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.ServiceAttachment
	f := func(l *computebeta.ServiceAttachmentList) error {
		klog.V(5).Infof("GCEBetaServiceAttachments.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaServiceAttachments.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaServiceAttachments.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaServiceAttachments.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ServiceAttachment with key of value obj.
func (g *GCEBetaServiceAttachments) Insert(ctx context.Context, key *meta.Key, obj *computebeta.ServiceAttachment, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaServiceAttachments.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaServiceAttachments.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEBetaServiceAttachments.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaServiceAttachments.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.ServiceAttachments.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaServiceAttachments.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaServiceAttachments.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ServiceAttachment referenced by key.
func (g *GCEBetaServiceAttachments) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaServiceAttachments.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaServiceAttachments.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ServiceAttachments")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEBetaServiceAttachments.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaServiceAttachments.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.ServiceAttachments.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEBetaServiceAttachments.
func (g *GCEBetaServiceAttachments) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.ServiceAttachment, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaServiceAttachments.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaServiceAttachments.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "ServiceAttachments")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEBetaServiceAttachments.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaServiceAttachments.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.ServiceAttachments.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaServiceAttachments.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaServiceAttachments.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaServiceAttachments is an interface that allows for mocking of ServiceAttachments.
type AlphaServiceAttachments interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ServiceAttachment, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.ServiceAttachment, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.ServiceAttachment, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computealpha.ServiceAttachment, ...Option) error
}

// NewMockAlphaServiceAttachments returns a new mock for ServiceAttachments.
func NewMockAlphaServiceAttachments(pr ProjectRouter, objs map[meta.Key]*MockServiceAttachmentsObj) *MockAlphaServiceAttachments {
	mock := &MockAlphaServiceAttachments{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaServiceAttachments is the mock for ServiceAttachments.
type MockAlphaServiceAttachments struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockServiceAttachmentsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaServiceAttachments, options ...Option) (bool, *computealpha.ServiceAttachment, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockAlphaServiceAttachments, options ...Option) (bool, []*computealpha.ServiceAttachment, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.ServiceAttachment, m *MockAlphaServiceAttachments, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaServiceAttachments, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *computealpha.ServiceAttachment, *MockAlphaServiceAttachments, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaServiceAttachments) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ServiceAttachment, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaServiceAttachments.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaServiceAttachments.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaServiceAttachments.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaServiceAttachments %v not found", key),
	}
	klog.V(5).Infof("MockAlphaServiceAttachments.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaServiceAttachments) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.ServiceAttachment, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaServiceAttachments.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaServiceAttachments.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.ServiceAttachment
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaServiceAttachments.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaServiceAttachments) Insert(ctx context.Context, key *meta.Key, obj *computealpha.ServiceAttachment, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaServiceAttachments %v exists", key),
		}
		klog.V(5).Infof("MockAlphaServiceAttachments.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "serviceAttachments")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "serviceAttachments", key)

	m.Objects[*key] = &MockServiceAttachmentsObj{obj}
	klog.V(5).Infof("MockAlphaServiceAttachments.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaServiceAttachments) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaServiceAttachments %v not found", key),
		}
		klog.V(5).Infof("MockAlphaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaServiceAttachments.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaServiceAttachments) Obj(o *computealpha.ServiceAttachment) *MockServiceAttachmentsObj {
	return &MockServiceAttachmentsObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaServiceAttachments) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.ServiceAttachment, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaServiceAttachments is a simplifying adapter for the GCE ServiceAttachments.
type GCEAlphaServiceAttachments struct {
	s *Service
}

// Get the ServiceAttachment named by key.
func (g *GCEAlphaServiceAttachments) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.ServiceAttachment, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaServiceAttachments.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaServiceAttachments.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "ServiceAttachments",
	}

	klog.V(5).Infof("GCEAlphaServiceAttachments.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaServiceAttachments.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.ServiceAttachments.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaServiceAttachments.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all ServiceAttachment objects.
func (g *GCEAlphaServiceAttachments) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.ServiceAttachment, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaServiceAttachments.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "ServiceAttachments",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaServiceAttachments.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.ServiceAttachments.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.ServiceAttachment
	f := func(l *computealpha.ServiceAttachmentList) error {
		klog.V(5).Infof("GCEAlphaServiceAttachments.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaServiceAttachments.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaServiceAttachments.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaServiceAttachments.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert ServiceAttachment with key of value obj.
func (g *GCEAlphaServiceAttachments) Insert(ctx context.Context, key *meta.Key, obj *computealpha.ServiceAttachment, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaServiceAttachments.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaServiceAttachments.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ServiceAttachments")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEAlphaServiceAttachments.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaServiceAttachments.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.ServiceAttachments.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaServiceAttachments.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaServiceAttachments.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the ServiceAttachment referenced by key.
func (g *GCEAlphaServiceAttachments) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaServiceAttachments.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaServiceAttachments.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ServiceAttachments")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEAlphaServiceAttachments.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaServiceAttachments.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.ServiceAttachments.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaServiceAttachments.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEAlphaServiceAttachments.
func (g *GCEAlphaServiceAttachments) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.ServiceAttachment, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaServiceAttachments.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaServiceAttachments.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "ServiceAttachments")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "ServiceAttachments",
	}
	klog.V(5).Infof("GCEAlphaServiceAttachments.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaServiceAttachments.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.ServiceAttachments.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaServiceAttachments.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaServiceAttachments.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SslCertificates is an interface that allows for mocking of SslCertificates.
type SslCertificates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslCertificate, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.SslCertificate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockSslCertificates returns a new mock for SslCertificates.
func NewMockSslCertificates(pr ProjectRouter, objs map[meta.Key]*MockSslCertificatesObj) *MockSslCertificates {
	mock := &MockSslCertificates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockSslCertificates is the mock for SslCertificates.
type MockSslCertificates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSslCertificatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockSslCertificates, options ...Option) (bool, *computega.SslCertificate, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockSslCertificates, options ...Option) (bool, []*computega.SslCertificate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, m *MockSslCertificates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockSslCertificates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockSslCertificates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockSslCertificates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockSslCertificates %v not found", key),
	}
	klog.V(5).Infof("MockSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockSslCertificates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockSslCertificates.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockSslCertificates.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.SslCertificate
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockSslCertificates.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockSslCertificates %v exists", key),
		}
		klog.V(5).Infof("MockSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "sslCertificates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "sslCertificates", key)

	m.Objects[*key] = &MockSslCertificatesObj{obj}
	klog.V(5).Infof("MockSslCertificates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockSslCertificates %v not found", key),
		}
		klog.V(5).Infof("MockSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockSslCertificates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockSslCertificates) Obj(o *computega.SslCertificate) *MockSslCertificatesObj {
	return &MockSslCertificatesObj{o}
}

// GCESslCertificates is a simplifying adapter for the GCE SslCertificates.
type GCESslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCESslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslCertificates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCESslCertificates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "SslCertificates",
	}

	klog.V(5).Infof("GCESslCertificates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESslCertificates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.SslCertificates.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCESslCertificates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SslCertificate objects.
func (g *GCESslCertificates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslCertificates.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "SslCertificates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCESslCertificates.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.SslCertificates.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.SslCertificate
	f := func(l *computega.SslCertificateList) error {
		klog.V(5).Infof("GCESslCertificates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCESslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCESslCertificates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCESslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCESslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslCertificates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCESslCertificates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "SslCertificates",
	}
	klog.V(5).Infof("GCESslCertificates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESslCertificates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.SslCertificates.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCESslCertificates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCESslCertificates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslCertificate referenced by key.
func (g *GCESslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslCertificates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCESslCertificates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslCertificates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "SslCertificates",
	}
	klog.V(5).Infof("GCESslCertificates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESslCertificates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.SslCertificates.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCESslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCESslCertificates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// BetaSslCertificates is an interface that allows for mocking of SslCertificates.
type BetaSslCertificates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SslCertificate, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.SslCertificate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockBetaSslCertificates returns a new mock for SslCertificates.
func NewMockBetaSslCertificates(pr ProjectRouter, objs map[meta.Key]*MockSslCertificatesObj) *MockBetaSslCertificates {
	mock := &MockBetaSslCertificates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaSslCertificates is the mock for SslCertificates.
type MockBetaSslCertificates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSslCertificatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaSslCertificates, options ...Option) (bool, *computebeta.SslCertificate, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaSslCertificates, options ...Option) (bool, []*computebeta.SslCertificate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, m *MockBetaSslCertificates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaSslCertificates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaSslCertificates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaSslCertificates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaSslCertificates %v not found", key),
	}
	klog.V(5).Infof("MockBetaSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaSslCertificates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaSslCertificates.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaSslCertificates.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.SslCertificate
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaSslCertificates.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaSslCertificates %v exists", key),
		}
		klog.V(5).Infof("MockBetaSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "sslCertificates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "sslCertificates", key)

	m.Objects[*key] = &MockSslCertificatesObj{obj}
	klog.V(5).Infof("MockBetaSslCertificates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaSslCertificates %v not found", key),
		}
		klog.V(5).Infof("MockBetaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaSslCertificates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaSslCertificates) Obj(o *computebeta.SslCertificate) *MockSslCertificatesObj {
	return &MockSslCertificatesObj{o}
}

// GCEBetaSslCertificates is a simplifying adapter for the GCE SslCertificates.
type GCEBetaSslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCEBetaSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSslCertificates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSslCertificates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "SslCertificates",
	}

	klog.V(5).Infof("GCEBetaSslCertificates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSslCertificates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.SslCertificates.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaSslCertificates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SslCertificate objects.
func (g *GCEBetaSslCertificates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSslCertificates.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "SslCertificates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaSslCertificates.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.SslCertificates.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.SslCertificate
	f := func(l *computebeta.SslCertificateList) error {
		klog.V(5).Infof("GCEBetaSslCertificates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaSslCertificates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCEBetaSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSslCertificates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSslCertificates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "SslCertificates",
	}
	klog.V(5).Infof("GCEBetaSslCertificates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSslCertificates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.SslCertificates.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaSslCertificates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaSslCertificates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslCertificate referenced by key.
func (g *GCEBetaSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSslCertificates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSslCertificates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "SslCertificates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "SslCertificates",
	}
	klog.V(5).Infof("GCEBetaSslCertificates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSslCertificates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.SslCertificates.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AlphaSslCertificates is an interface that allows for mocking of SslCertificates.
type AlphaSslCertificates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.SslCertificate, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.SslCertificate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockAlphaSslCertificates returns a new mock for SslCertificates.
func NewMockAlphaSslCertificates(pr ProjectRouter, objs map[meta.Key]*MockSslCertificatesObj) *MockAlphaSslCertificates {
	mock := &MockAlphaSslCertificates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaSslCertificates is the mock for SslCertificates.
type MockAlphaSslCertificates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSslCertificatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaSslCertificates, options ...Option) (bool, *computealpha.SslCertificate, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockAlphaSslCertificates, options ...Option) (bool, []*computealpha.SslCertificate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, m *MockAlphaSslCertificates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaSslCertificates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSslCertificates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaSslCertificates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaSslCertificates %v not found", key),
	}
	klog.V(5).Infof("MockAlphaSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaSslCertificates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSslCertificates.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaSslCertificates.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.SslCertificate
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaSslCertificates.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaSslCertificates %v exists", key),
		}
		klog.V(5).Infof("MockAlphaSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "sslCertificates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "sslCertificates", key)

	m.Objects[*key] = &MockSslCertificatesObj{obj}
	klog.V(5).Infof("MockAlphaSslCertificates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaSslCertificates %v not found", key),
		}
		klog.V(5).Infof("MockAlphaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaSslCertificates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaSslCertificates) Obj(o *computealpha.SslCertificate) *MockSslCertificatesObj {
	return &MockSslCertificatesObj{o}
}

// GCEAlphaSslCertificates is a simplifying adapter for the GCE SslCertificates.
type GCEAlphaSslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCEAlphaSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSslCertificates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSslCertificates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "SslCertificates",
	}

	klog.V(5).Infof("GCEAlphaSslCertificates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSslCertificates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.SslCertificates.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaSslCertificates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SslCertificate objects.
func (g *GCEAlphaSslCertificates) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSslCertificates.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "SslCertificates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaSslCertificates.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.SslCertificates.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.SslCertificate
	f := func(l *computealpha.SslCertificateList) error {
		klog.V(5).Infof("GCEAlphaSslCertificates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaSslCertificates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCEAlphaSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSslCertificates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSslCertificates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "SslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "SslCertificates",
	}
	klog.V(5).Infof("GCEAlphaSslCertificates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSslCertificates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.SslCertificates.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaSslCertificates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaSslCertificates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslCertificate referenced by key.
func (g *GCEAlphaSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSslCertificates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSslCertificates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "SslCertificates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "SslCertificates",
	}
	klog.V(5).Infof("GCEAlphaSslCertificates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSslCertificates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.SslCertificates.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AlphaRegionSslCertificates is an interface that allows for mocking of RegionSslCertificates.
type AlphaRegionSslCertificates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.SslCertificate, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.SslCertificate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockAlphaRegionSslCertificates returns a new mock for RegionSslCertificates.
func NewMockAlphaRegionSslCertificates(pr ProjectRouter, objs map[meta.Key]*MockRegionSslCertificatesObj) *MockAlphaRegionSslCertificates {
	mock := &MockAlphaRegionSslCertificates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionSslCertificates is the mock for RegionSslCertificates.
type MockAlphaRegionSslCertificates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionSslCertificatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaRegionSslCertificates, options ...Option) (bool, *computealpha.SslCertificate, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionSslCertificates, options ...Option) (bool, []*computealpha.SslCertificate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, m *MockAlphaRegionSslCertificates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaRegionSslCertificates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionSslCertificates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionSslCertificates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionSslCertificates %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionSslCertificates) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionSslCertificates.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionSslCertificates.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.SslCertificate
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionSslCertificates.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionSslCertificates %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "sslCertificates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "sslCertificates", key)

	m.Objects[*key] = &MockRegionSslCertificatesObj{obj}
	klog.V(5).Infof("MockAlphaRegionSslCertificates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionSslCertificates %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionSslCertificates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionSslCertificates) Obj(o *computealpha.SslCertificate) *MockRegionSslCertificatesObj {
	return &MockRegionSslCertificatesObj{o}
}

// GCEAlphaRegionSslCertificates is a simplifying adapter for the GCE RegionSslCertificates.
type GCEAlphaRegionSslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCEAlphaRegionSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionSslCertificates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionSslCertificates",
	}

	klog.V(5).Infof("GCEAlphaRegionSslCertificates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionSslCertificates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionSslCertificates.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionSslCertificates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SslCertificate objects.
func (g *GCEAlphaRegionSslCertificates) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionSslCertificates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionSslCertificates.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.SslCertificate
	f := func(l *computealpha.SslCertificateList) error {
		klog.V(5).Infof("GCEAlphaRegionSslCertificates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionSslCertificates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCEAlphaRegionSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computealpha.SslCertificate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionSslCertificates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionSslCertificates",
	}
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionSslCertificates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionSslCertificates.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionSslCertificates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionSslCertificates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslCertificate referenced by key.
func (g *GCEAlphaRegionSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionSslCertificates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionSslCertificates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionSslCertificates",
	}
	klog.V(5).Infof("GCEAlphaRegionSslCertificates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionSslCertificates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionSslCertificates.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// BetaRegionSslCertificates is an interface that allows for mocking of RegionSslCertificates.
type BetaRegionSslCertificates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SslCertificate, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.SslCertificate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockBetaRegionSslCertificates returns a new mock for RegionSslCertificates.
func NewMockBetaRegionSslCertificates(pr ProjectRouter, objs map[meta.Key]*MockRegionSslCertificatesObj) *MockBetaRegionSslCertificates {
	mock := &MockBetaRegionSslCertificates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRegionSslCertificates is the mock for RegionSslCertificates.
type MockBetaRegionSslCertificates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionSslCertificatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaRegionSslCertificates, options ...Option) (bool, *computebeta.SslCertificate, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockBetaRegionSslCertificates, options ...Option) (bool, []*computebeta.SslCertificate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, m *MockBetaRegionSslCertificates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaRegionSslCertificates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRegionSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionSslCertificates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRegionSslCertificates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRegionSslCertificates %v not found", key),
	}
	klog.V(5).Infof("MockBetaRegionSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRegionSslCertificates) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionSslCertificates.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRegionSslCertificates.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.SslCertificate
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRegionSslCertificates.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRegionSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRegionSslCertificates %v exists", key),
		}
		klog.V(5).Infof("MockBetaRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "sslCertificates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "sslCertificates", key)

	m.Objects[*key] = &MockRegionSslCertificatesObj{obj}
	klog.V(5).Infof("MockBetaRegionSslCertificates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRegionSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRegionSslCertificates %v not found", key),
		}
		klog.V(5).Infof("MockBetaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRegionSslCertificates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRegionSslCertificates) Obj(o *computebeta.SslCertificate) *MockRegionSslCertificatesObj {
	return &MockRegionSslCertificatesObj{o}
}

// GCEBetaRegionSslCertificates is a simplifying adapter for the GCE RegionSslCertificates.
type GCEBetaRegionSslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCEBetaRegionSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionSslCertificates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionSslCertificates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "RegionSslCertificates",
	}

	klog.V(5).Infof("GCEBetaRegionSslCertificates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionSslCertificates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionSslCertificates.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRegionSslCertificates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SslCertificate objects.
func (g *GCEBetaRegionSslCertificates) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionSslCertificates.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "RegionSslCertificates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRegionSslCertificates.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.RegionSslCertificates.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.SslCertificate
	f := func(l *computebeta.SslCertificateList) error {
		klog.V(5).Infof("GCEBetaRegionSslCertificates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRegionSslCertificates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRegionSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCEBetaRegionSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computebeta.SslCertificate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionSslCertificates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionSslCertificates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "RegionSslCertificates",
	}
	klog.V(5).Infof("GCEBetaRegionSslCertificates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionSslCertificates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.RegionSslCertificates.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionSslCertificates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionSslCertificates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslCertificate referenced by key.
func (g *GCEBetaRegionSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionSslCertificates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionSslCertificates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionSslCertificates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "RegionSslCertificates",
	}
	klog.V(5).Infof("GCEBetaRegionSslCertificates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionSslCertificates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionSslCertificates.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// RegionSslCertificates is an interface that allows for mocking of RegionSslCertificates.
type RegionSslCertificates interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslCertificate, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.SslCertificate, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockRegionSslCertificates returns a new mock for RegionSslCertificates.
func NewMockRegionSslCertificates(pr ProjectRouter, objs map[meta.Key]*MockRegionSslCertificatesObj) *MockRegionSslCertificates {
	mock := &MockRegionSslCertificates{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionSslCertificates is the mock for RegionSslCertificates.
type MockRegionSslCertificates struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionSslCertificatesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockRegionSslCertificates, options ...Option) (bool, *computega.SslCertificate, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockRegionSslCertificates, options ...Option) (bool, []*computega.SslCertificate, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, m *MockRegionSslCertificates, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockRegionSslCertificates, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslCertificate, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslCertificates.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionSslCertificates.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionSslCertificates %v not found", key),
	}
	klog.V(5).Infof("MockRegionSslCertificates.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionSslCertificates) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.SslCertificate, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslCertificates.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionSslCertificates.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.SslCertificate
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionSslCertificates.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionSslCertificates %v exists", key),
		}
		klog.V(5).Infof("MockRegionSslCertificates.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "sslCertificates")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "sslCertificates", key)

	m.Objects[*key] = &MockRegionSslCertificatesObj{obj}
	klog.V(5).Infof("MockRegionSslCertificates.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionSslCertificates %v not found", key),
		}
		klog.V(5).Infof("MockRegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionSslCertificates.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionSslCertificates) Obj(o *computega.SslCertificate) *MockRegionSslCertificatesObj {
	return &MockRegionSslCertificatesObj{o}
}

// GCERegionSslCertificates is a simplifying adapter for the GCE RegionSslCertificates.
type GCERegionSslCertificates struct {
	s *Service
}

// Get the SslCertificate named by key.
func (g *GCERegionSslCertificates) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslCertificates.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionSslCertificates.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionSslCertificates",
	}

	klog.V(5).Infof("GCERegionSslCertificates.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionSslCertificates.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionSslCertificates.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionSslCertificates.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all SslCertificate objects.
func (g *GCERegionSslCertificates) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.SslCertificate, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslCertificates.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionSslCertificates",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionSslCertificates.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionSslCertificates.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.SslCertificate
	f := func(l *computega.SslCertificateList) error {
		klog.V(5).Infof("GCERegionSslCertificates.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionSslCertificates.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionSslCertificates.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert SslCertificate with key of value obj.
func (g *GCERegionSslCertificates) Insert(ctx context.Context, key *meta.Key, obj *computega.SslCertificate, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslCertificates.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionSslCertificates.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslCertificates")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionSslCertificates",
	}
	klog.V(5).Infof("GCERegionSslCertificates.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionSslCertificates.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionSslCertificates.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionSslCertificates.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionSslCertificates.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslCertificate referenced by key.
func (g *GCERegionSslCertificates) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslCertificates.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionSslCertificates.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslCertificates")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionSslCertificates",
	}
	klog.V(5).Infof("GCERegionSslCertificates.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionSslCertificates.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionSslCertificates.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionSslCertificates.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SslPolicies is an interface that allows for mocking of SslPolicies.
type SslPolicies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslPolicy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockSslPolicies returns a new mock for SslPolicies.
func NewMockSslPolicies(pr ProjectRouter, objs map[meta.Key]*MockSslPoliciesObj) *MockSslPolicies {
	mock := &MockSslPolicies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockSslPolicies is the mock for SslPolicies.
type MockSslPolicies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSslPoliciesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockSslPolicies, options ...Option) (bool, *computega.SslPolicy, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, m *MockSslPolicies, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockSslPolicies, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockSslPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslPolicy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockSslPolicies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockSslPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockSslPolicies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockSslPolicies %v not found", key),
	}
	klog.V(5).Infof("MockSslPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// Insert is a mock for inserting/creating a new object.
func (m *MockSslPolicies) Insert(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockSslPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockSslPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockSslPolicies %v exists", key),
		}
		klog.V(5).Infof("MockSslPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "sslPolicies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "sslPolicies", key)

	m.Objects[*key] = &MockSslPoliciesObj{obj}
	klog.V(5).Infof("MockSslPolicies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockSslPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockSslPolicies %v not found", key),
		}
		klog.V(5).Infof("MockSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockSslPolicies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockSslPolicies) Obj(o *computega.SslPolicy) *MockSslPoliciesObj {
	return &MockSslPoliciesObj{o}
}

// GCESslPolicies is a simplifying adapter for the GCE SslPolicies.
type GCESslPolicies struct {
	s *Service
}

// Get the SslPolicy named by key.
func (g *GCESslPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslPolicies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCESslPolicies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "SslPolicies",
	}

	klog.V(5).Infof("GCESslPolicies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESslPolicies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.SslPolicies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCESslPolicies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// Insert SslPolicy with key of value obj.
func (g *GCESslPolicies) Insert(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslPolicies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCESslPolicies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "SslPolicies",
	}
	klog.V(5).Infof("GCESslPolicies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESslPolicies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.SslPolicies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCESslPolicies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCESslPolicies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslPolicy referenced by key.
func (g *GCESslPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESslPolicies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCESslPolicies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "SslPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "SslPolicies",
	}
	klog.V(5).Infof("GCESslPolicies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESslPolicies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.SslPolicies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCESslPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCESslPolicies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// RegionSslPolicies is an interface that allows for mocking of RegionSslPolicies.
type RegionSslPolicies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslPolicy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
}

// NewMockRegionSslPolicies returns a new mock for RegionSslPolicies.
func NewMockRegionSslPolicies(pr ProjectRouter, objs map[meta.Key]*MockRegionSslPoliciesObj) *MockRegionSslPolicies {
	mock := &MockRegionSslPolicies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionSslPolicies is the mock for RegionSslPolicies.
type MockRegionSslPolicies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionSslPoliciesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockRegionSslPolicies, options ...Option) (bool, *computega.SslPolicy, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, m *MockRegionSslPolicies, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockRegionSslPolicies, options ...Option) (bool, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionSslPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslPolicy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslPolicies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionSslPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionSslPolicies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionSslPolicies %v not found", key),
	}
	klog.V(5).Infof("MockRegionSslPolicies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionSslPolicies) Insert(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionSslPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionSslPolicies %v exists", key),
		}
		klog.V(5).Infof("MockRegionSslPolicies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "sslPolicies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "sslPolicies", key)

	m.Objects[*key] = &MockRegionSslPoliciesObj{obj}
	klog.V(5).Infof("MockRegionSslPolicies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionSslPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionSslPolicies %v not found", key),
		}
		klog.V(5).Infof("MockRegionSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionSslPolicies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionSslPolicies) Obj(o *computega.SslPolicy) *MockRegionSslPoliciesObj {
	return &MockRegionSslPoliciesObj{o}
}

// GCERegionSslPolicies is a simplifying adapter for the GCE RegionSslPolicies.
type GCERegionSslPolicies struct {
	s *Service
}

// Get the SslPolicy named by key.
func (g *GCERegionSslPolicies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.SslPolicy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslPolicies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionSslPolicies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionSslPolicies",
	}

	klog.V(5).Infof("GCERegionSslPolicies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionSslPolicies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionSslPolicies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionSslPolicies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// Insert SslPolicy with key of value obj.
func (g *GCERegionSslPolicies) Insert(ctx context.Context, key *meta.Key, obj *computega.SslPolicy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslPolicies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionSslPolicies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslPolicies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionSslPolicies",
	}
	klog.V(5).Infof("GCERegionSslPolicies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionSslPolicies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionSslPolicies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionSslPolicies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionSslPolicies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the SslPolicy referenced by key.
func (g *GCERegionSslPolicies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionSslPolicies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionSslPolicies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionSslPolicies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionSslPolicies",
	}
	klog.V(5).Infof("GCERegionSslPolicies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionSslPolicies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionSslPolicies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionSslPolicies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AlphaSubnetworks is an interface that allows for mocking of Subnetworks.
type AlphaSubnetworks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Subnetwork, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Subnetwork, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.Subnetwork, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.UsableSubnetwork, error)
	Patch(context.Context, *meta.Key, *computealpha.Subnetwork, ...Option) error
}

// NewMockAlphaSubnetworks returns a new mock for Subnetworks.
func NewMockAlphaSubnetworks(pr ProjectRouter, objs map[meta.Key]*MockSubnetworksObj) *MockAlphaSubnetworks {
	mock := &MockAlphaSubnetworks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaSubnetworks is the mock for Subnetworks.
type MockAlphaSubnetworks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSubnetworksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError        map[meta.Key]error
	ListError       *error
	InsertError     map[meta.Key]error
	DeleteError     map[meta.Key]error
	ListUsableError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook        func(ctx context.Context, key *meta.Key, m *MockAlphaSubnetworks, options ...Option) (bool, *computealpha.Subnetwork, error)
	ListHook       func(ctx context.Context, region string, fl *filter.F, m *MockAlphaSubnetworks, options ...Option) (bool, []*computealpha.Subnetwork, error)
	InsertHook     func(ctx context.Context, key *meta.Key, obj *computealpha.Subnetwork, m *MockAlphaSubnetworks, options ...Option) (bool, error)
	DeleteHook     func(ctx context.Context, key *meta.Key, m *MockAlphaSubnetworks, options ...Option) (bool, error)
	ListUsableHook func(ctx context.Context, fl *filter.F, m *MockAlphaSubnetworks, options ...Option) (bool, []*computealpha.UsableSubnetwork, error)
	PatchHook      func(context.Context, *meta.Key, *computealpha.Subnetwork, *MockAlphaSubnetworks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaSubnetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Subnetwork, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSubnetworks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaSubnetworks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaSubnetworks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaSubnetworks %v not found", key),
	}
	klog.V(5).Infof("MockAlphaSubnetworks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaSubnetworks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Subnetwork, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSubnetworks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaSubnetworks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.Subnetwork
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaSubnetworks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaSubnetworks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Subnetwork, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaSubnetworks %v exists", key),
		}
		klog.V(5).Infof("MockAlphaSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "subnetworks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "subnetworks", key)

	m.Objects[*key] = &MockSubnetworksObj{obj}
	klog.V(5).Infof("MockAlphaSubnetworks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaSubnetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaSubnetworks %v not found", key),
		}
		klog.V(5).Infof("MockAlphaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaSubnetworks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// List all of the objects in the mock.
func (m *MockAlphaSubnetworks) ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.UsableSubnetwork, error) {
	if m.ListUsableHook != nil {
		if intercept, objs, err := m.ListUsableHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaSubnetworks.ListUsable(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaSubnetworks.ListUsable(%v, %v) = nil, %v", ctx, fl, err)
		return nil, *m.ListError
	}

	var objs []*computealpha.UsableSubnetwork

	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		alphaObj := obj.ToAlpha()
		dest := &computealpha.UsableSubnetwork{}
		// Convert to Usable type to avoid separate Usable struct
		if err := copyViaJSON(dest, alphaObj); err != nil {
			klog.Errorf("Could not convert %T to *computealpha.UsableSubnetwork via JSON: %v", alphaObj, err)
		}
		objs = append(objs, dest)
	}
	klog.V(5).Infof("MockAlphaSubnetworks.ListUsable(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaSubnetworks) Obj(o *computealpha.Subnetwork) *MockSubnetworksObj {
	return &MockSubnetworksObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaSubnetworks) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Subnetwork, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaSubnetworks is a simplifying adapter for the GCE Subnetworks.
type GCEAlphaSubnetworks struct {
	s *Service
}

// Get the Subnetwork named by key.
func (g *GCEAlphaSubnetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.Subnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSubnetworks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSubnetworks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "Subnetworks",
	}

	klog.V(5).Infof("GCEAlphaSubnetworks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSubnetworks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.Subnetworks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaSubnetworks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Subnetwork objects.
func (g *GCEAlphaSubnetworks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.Subnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSubnetworks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "Subnetworks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaSubnetworks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.Subnetworks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.Subnetwork
	f := func(l *computealpha.SubnetworkList) error {
		klog.V(5).Infof("GCEAlphaSubnetworks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaSubnetworks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaSubnetworks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaSubnetworks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Subnetwork with key of value obj.
func (g *GCEAlphaSubnetworks) Insert(ctx context.Context, key *meta.Key, obj *computealpha.Subnetwork, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSubnetworks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSubnetworks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCEAlphaSubnetworks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSubnetworks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.Subnetworks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaSubnetworks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaSubnetworks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Subnetwork referenced by key.
func (g *GCEAlphaSubnetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSubnetworks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSubnetworks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCEAlphaSubnetworks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSubnetworks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Subnetworks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// List all Usable Subnetwork objects.
func (g *GCEAlphaSubnetworks) ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.UsableSubnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSubnetworks.ListUsable(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListUsable",
		Version:   meta.Version("alpha"),
		Service:   "Subnetworks",
	}
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}

	klog.V(5).Infof("GCEAlphaSubnetworks.ListUsable(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.Subnetworks.ListUsable(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}
	var all []*computealpha.UsableSubnetwork
	f := func(l *computealpha.UsableSubnetworksAggregatedList) error {
		klog.V(5).Infof("GCEAlphaSubnetworks.ListUsable(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaSubnetworks.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaSubnetworks.ListUsable(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaSubnetworks.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Patch is a method on GCEAlphaSubnetworks.
func (g *GCEAlphaSubnetworks) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.Subnetwork, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaSubnetworks.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaSubnetworks.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCEAlphaSubnetworks.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaSubnetworks.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.Subnetworks.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaSubnetworks.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaSubnetworks.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaSubnetworks is an interface that allows for mocking of Subnetworks.
type BetaSubnetworks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Subnetwork, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Subnetwork, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.Subnetwork, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.UsableSubnetwork, error)
	Patch(context.Context, *meta.Key, *computebeta.Subnetwork, ...Option) error
}

// NewMockBetaSubnetworks returns a new mock for Subnetworks.
func NewMockBetaSubnetworks(pr ProjectRouter, objs map[meta.Key]*MockSubnetworksObj) *MockBetaSubnetworks {
	mock := &MockBetaSubnetworks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaSubnetworks is the mock for Subnetworks.
type MockBetaSubnetworks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSubnetworksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError        map[meta.Key]error
	ListError       *error
	InsertError     map[meta.Key]error
	DeleteError     map[meta.Key]error
	ListUsableError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook        func(ctx context.Context, key *meta.Key, m *MockBetaSubnetworks, options ...Option) (bool, *computebeta.Subnetwork, error)
	ListHook       func(ctx context.Context, region string, fl *filter.F, m *MockBetaSubnetworks, options ...Option) (bool, []*computebeta.Subnetwork, error)
	InsertHook     func(ctx context.Context, key *meta.Key, obj *computebeta.Subnetwork, m *MockBetaSubnetworks, options ...Option) (bool, error)
	DeleteHook     func(ctx context.Context, key *meta.Key, m *MockBetaSubnetworks, options ...Option) (bool, error)
	ListUsableHook func(ctx context.Context, fl *filter.F, m *MockBetaSubnetworks, options ...Option) (bool, []*computebeta.UsableSubnetwork, error)
	PatchHook      func(context.Context, *meta.Key, *computebeta.Subnetwork, *MockBetaSubnetworks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaSubnetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Subnetwork, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaSubnetworks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaSubnetworks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaSubnetworks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaSubnetworks %v not found", key),
	}
	klog.V(5).Infof("MockBetaSubnetworks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaSubnetworks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Subnetwork, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaSubnetworks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaSubnetworks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.Subnetwork
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaSubnetworks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaSubnetworks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Subnetwork, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaSubnetworks %v exists", key),
		}
		klog.V(5).Infof("MockBetaSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "subnetworks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "subnetworks", key)

	m.Objects[*key] = &MockSubnetworksObj{obj}
	klog.V(5).Infof("MockBetaSubnetworks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaSubnetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaSubnetworks %v not found", key),
		}
		klog.V(5).Infof("MockBetaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaSubnetworks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// List all of the objects in the mock.
func (m *MockBetaSubnetworks) ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.UsableSubnetwork, error) {
	if m.ListUsableHook != nil {
		if intercept, objs, err := m.ListUsableHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaSubnetworks.ListUsable(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaSubnetworks.ListUsable(%v, %v) = nil, %v", ctx, fl, err)
		return nil, *m.ListError
	}

	var objs []*computebeta.UsableSubnetwork

	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		betaObj := obj.ToBeta()
		dest := &computebeta.UsableSubnetwork{}
		// Convert to Usable type to avoid separate Usable struct
		if err := copyViaJSON(dest, betaObj); err != nil {
			klog.Errorf("Could not convert %T to *computebeta.UsableSubnetwork via JSON: %v", betaObj, err)
		}
		objs = append(objs, dest)
	}
	klog.V(5).Infof("MockBetaSubnetworks.ListUsable(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaSubnetworks) Obj(o *computebeta.Subnetwork) *MockSubnetworksObj {
	return &MockSubnetworksObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockBetaSubnetworks) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Subnetwork, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaSubnetworks is a simplifying adapter for the GCE Subnetworks.
type GCEBetaSubnetworks struct {
	s *Service
}

// Get the Subnetwork named by key.
func (g *GCEBetaSubnetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.Subnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSubnetworks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSubnetworks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Subnetworks",
	}

	klog.V(5).Infof("GCEBetaSubnetworks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSubnetworks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.Subnetworks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaSubnetworks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Subnetwork objects.
func (g *GCEBetaSubnetworks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.Subnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSubnetworks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Subnetworks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaSubnetworks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.Subnetworks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.Subnetwork
	f := func(l *computebeta.SubnetworkList) error {
		klog.V(5).Infof("GCEBetaSubnetworks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSubnetworks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaSubnetworks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaSubnetworks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Subnetwork with key of value obj.
func (g *GCEBetaSubnetworks) Insert(ctx context.Context, key *meta.Key, obj *computebeta.Subnetwork, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSubnetworks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSubnetworks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCEBetaSubnetworks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSubnetworks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.Subnetworks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaSubnetworks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaSubnetworks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Subnetwork referenced by key.
func (g *GCEBetaSubnetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSubnetworks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSubnetworks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCEBetaSubnetworks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSubnetworks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Subnetworks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// List all Usable Subnetwork objects.
func (g *GCEBetaSubnetworks) ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.UsableSubnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSubnetworks.ListUsable(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListUsable",
		Version:   meta.Version("beta"),
		Service:   "Subnetworks",
	}
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}

	klog.V(5).Infof("GCEBetaSubnetworks.ListUsable(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.Subnetworks.ListUsable(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}
	var all []*computebeta.UsableSubnetwork
	f := func(l *computebeta.UsableSubnetworksAggregatedList) error {
		klog.V(5).Infof("GCEBetaSubnetworks.ListUsable(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSubnetworks.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaSubnetworks.ListUsable(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaSubnetworks.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Patch is a method on GCEBetaSubnetworks.
func (g *GCEBetaSubnetworks) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.Subnetwork, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaSubnetworks.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaSubnetworks.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCEBetaSubnetworks.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaSubnetworks.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.Subnetworks.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaSubnetworks.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaSubnetworks.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Subnetworks is an interface that allows for mocking of Subnetworks.
type Subnetworks interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Subnetwork, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Subnetwork, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.Subnetwork, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.UsableSubnetwork, error)
	Patch(context.Context, *meta.Key, *computega.Subnetwork, ...Option) error
}

// NewMockSubnetworks returns a new mock for Subnetworks.
func NewMockSubnetworks(pr ProjectRouter, objs map[meta.Key]*MockSubnetworksObj) *MockSubnetworks {
	mock := &MockSubnetworks{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockSubnetworks is the mock for Subnetworks.
type MockSubnetworks struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockSubnetworksObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError        map[meta.Key]error
	ListError       *error
	InsertError     map[meta.Key]error
	DeleteError     map[meta.Key]error
	ListUsableError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook        func(ctx context.Context, key *meta.Key, m *MockSubnetworks, options ...Option) (bool, *computega.Subnetwork, error)
	ListHook       func(ctx context.Context, region string, fl *filter.F, m *MockSubnetworks, options ...Option) (bool, []*computega.Subnetwork, error)
	InsertHook     func(ctx context.Context, key *meta.Key, obj *computega.Subnetwork, m *MockSubnetworks, options ...Option) (bool, error)
	DeleteHook     func(ctx context.Context, key *meta.Key, m *MockSubnetworks, options ...Option) (bool, error)
	ListUsableHook func(ctx context.Context, fl *filter.F, m *MockSubnetworks, options ...Option) (bool, []*computega.UsableSubnetwork, error)
	PatchHook      func(context.Context, *meta.Key, *computega.Subnetwork, *MockSubnetworks, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockSubnetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Subnetwork, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockSubnetworks.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockSubnetworks.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockSubnetworks.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockSubnetworks %v not found", key),
	}
	klog.V(5).Infof("MockSubnetworks.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockSubnetworks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Subnetwork, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockSubnetworks.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockSubnetworks.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Subnetwork
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockSubnetworks.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockSubnetworks) Insert(ctx context.Context, key *meta.Key, obj *computega.Subnetwork, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockSubnetworks %v exists", key),
		}
		klog.V(5).Infof("MockSubnetworks.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "subnetworks")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "subnetworks", key)

	m.Objects[*key] = &MockSubnetworksObj{obj}
	klog.V(5).Infof("MockSubnetworks.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockSubnetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockSubnetworks %v not found", key),
		}
		klog.V(5).Infof("MockSubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockSubnetworks.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// List all of the objects in the mock.
func (m *MockSubnetworks) ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.UsableSubnetwork, error) {
	if m.ListUsableHook != nil {
		if intercept, objs, err := m.ListUsableHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockSubnetworks.ListUsable(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockSubnetworks.ListUsable(%v, %v) = nil, %v", ctx, fl, err)
		return nil, *m.ListError
	}

	var objs []*computega.UsableSubnetwork

	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		gaObj := obj.ToGA()
		dest := &computega.UsableSubnetwork{}
		// Convert to Usable type to avoid separate Usable struct
		if err := copyViaJSON(dest, gaObj); err != nil {
			klog.Errorf("Could not convert %T to *computega.UsableSubnetwork via JSON: %v", gaObj, err)
		}
		objs = append(objs, dest)
	}
	klog.V(5).Infof("MockSubnetworks.ListUsable(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockSubnetworks) Obj(o *computega.Subnetwork) *MockSubnetworksObj {
	return &MockSubnetworksObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockSubnetworks) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Subnetwork, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// GCESubnetworks is a simplifying adapter for the GCE Subnetworks.
type GCESubnetworks struct {
	s *Service
}

// Get the Subnetwork named by key.
func (g *GCESubnetworks) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Subnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESubnetworks.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCESubnetworks.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Subnetworks",
	}

	klog.V(5).Infof("GCESubnetworks.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESubnetworks.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Subnetworks.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCESubnetworks.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Subnetwork objects.
func (g *GCESubnetworks) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.Subnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESubnetworks.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Subnetworks",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCESubnetworks.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.Subnetworks.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Subnetwork
	f := func(l *computega.SubnetworkList) error {
		klog.V(5).Infof("GCESubnetworks.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCESubnetworks.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCESubnetworks.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCESubnetworks.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Subnetwork with key of value obj.
func (g *GCESubnetworks) Insert(ctx context.Context, key *meta.Key, obj *computega.Subnetwork, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESubnetworks.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCESubnetworks.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Subnetworks")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCESubnetworks.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESubnetworks.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.Subnetworks.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCESubnetworks.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCESubnetworks.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Subnetwork referenced by key.
func (g *GCESubnetworks) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESubnetworks.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCESubnetworks.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCESubnetworks.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESubnetworks.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Subnetworks.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCESubnetworks.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCESubnetworks.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// List all Usable Subnetwork objects.
func (g *GCESubnetworks) ListUsable(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.UsableSubnetwork, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESubnetworks.ListUsable(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "ListUsable",
		Version:   meta.Version("ga"),
		Service:   "Subnetworks",
	}
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}

	klog.V(5).Infof("GCESubnetworks.ListUsable(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Subnetworks.ListUsable(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}
	var all []*computega.UsableSubnetwork
	f := func(l *computega.UsableSubnetworksAggregatedList) error {
		klog.V(5).Infof("GCESubnetworks.ListUsable(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCESubnetworks.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}
	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCESubnetworks.ListUsable(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCESubnetworks.ListUsable(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Patch is a method on GCESubnetworks.
func (g *GCESubnetworks) Patch(ctx context.Context, key *meta.Key, arg0 *computega.Subnetwork, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCESubnetworks.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCESubnetworks.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Subnetworks")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "Subnetworks",
	}
	klog.V(5).Infof("GCESubnetworks.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCESubnetworks.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.Subnetworks.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCESubnetworks.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCESubnetworks.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaTargetHttpProxies is an interface that allows for mocking of TargetHttpProxies.
type AlphaTargetHttpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computealpha.UrlMapReference, ...Option) error
}

// NewMockAlphaTargetHttpProxies returns a new mock for TargetHttpProxies.
func NewMockAlphaTargetHttpProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetHttpProxiesObj) *MockAlphaTargetHttpProxies {
	mock := &MockAlphaTargetHttpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaTargetHttpProxies is the mock for TargetHttpProxies.
type MockAlphaTargetHttpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetHttpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockAlphaTargetHttpProxies, options ...Option) (bool, *computealpha.TargetHttpProxy, error)
	ListHook      func(ctx context.Context, fl *filter.F, m *MockAlphaTargetHttpProxies, options ...Option) (bool, []*computealpha.TargetHttpProxy, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, m *MockAlphaTargetHttpProxies, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockAlphaTargetHttpProxies, options ...Option) (bool, error)
	SetUrlMapHook func(context.Context, *meta.Key, *computealpha.UrlMapReference, *MockAlphaTargetHttpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaTargetHttpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaTargetHttpProxies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaTargetHttpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaTargetHttpProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.TargetHttpProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaTargetHttpProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaTargetHttpProxies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "targetHttpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "targetHttpProxies", key)

	m.Objects[*key] = &MockTargetHttpProxiesObj{obj}
	klog.V(5).Infof("MockAlphaTargetHttpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaTargetHttpProxies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaTargetHttpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaTargetHttpProxies) Obj(o *computealpha.TargetHttpProxy) *MockTargetHttpProxiesObj {
	return &MockTargetHttpProxiesObj{o}
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockAlphaTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaTargetHttpProxies is a simplifying adapter for the GCE TargetHttpProxies.
type GCEAlphaTargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCEAlphaTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpProxies",
	}

	klog.V(5).Infof("GCEAlphaTargetHttpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.TargetHttpProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaTargetHttpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpProxy objects.
func (g *GCEAlphaTargetHttpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.TargetHttpProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.TargetHttpProxy
	f := func(l *computealpha.TargetHttpProxyList) error {
		klog.V(5).Infof("GCEAlphaTargetHttpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCEAlphaTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.TargetHttpProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaTargetHttpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCEAlphaTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEAlphaTargetHttpProxies.
func (g *GCEAlphaTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpProxies.SetUrlMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaTargetHttpProxies is an interface that allows for mocking of TargetHttpProxies.
type BetaTargetHttpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computebeta.UrlMapReference, ...Option) error
}

// NewMockBetaTargetHttpProxies returns a new mock for TargetHttpProxies.
func NewMockBetaTargetHttpProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetHttpProxiesObj) *MockBetaTargetHttpProxies {
	mock := &MockBetaTargetHttpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaTargetHttpProxies is the mock for TargetHttpProxies.
type MockBetaTargetHttpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetHttpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockBetaTargetHttpProxies, options ...Option) (bool, *computebeta.TargetHttpProxy, error)
	ListHook      func(ctx context.Context, fl *filter.F, m *MockBetaTargetHttpProxies, options ...Option) (bool, []*computebeta.TargetHttpProxy, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, m *MockBetaTargetHttpProxies, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockBetaTargetHttpProxies, options ...Option) (bool, error)
	SetUrlMapHook func(context.Context, *meta.Key, *computebeta.UrlMapReference, *MockBetaTargetHttpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaTargetHttpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaTargetHttpProxies %v not found", key),
	}
	klog.V(5).Infof("MockBetaTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaTargetHttpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaTargetHttpProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.TargetHttpProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaTargetHttpProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaTargetHttpProxies %v exists", key),
		}
		klog.V(5).Infof("MockBetaTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "targetHttpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "targetHttpProxies", key)

	m.Objects[*key] = &MockTargetHttpProxiesObj{obj}
	klog.V(5).Infof("MockBetaTargetHttpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaTargetHttpProxies %v not found", key),
		}
		klog.V(5).Infof("MockBetaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaTargetHttpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaTargetHttpProxies) Obj(o *computebeta.TargetHttpProxy) *MockTargetHttpProxiesObj {
	return &MockTargetHttpProxiesObj{o}
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockBetaTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaTargetHttpProxies is a simplifying adapter for the GCE TargetHttpProxies.
type GCEBetaTargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCEBetaTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpProxies",
	}

	klog.V(5).Infof("GCEBetaTargetHttpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.TargetHttpProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaTargetHttpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpProxy objects.
func (g *GCEBetaTargetHttpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaTargetHttpProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.TargetHttpProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.TargetHttpProxy
	f := func(l *computebeta.TargetHttpProxyList) error {
		klog.V(5).Infof("GCEBetaTargetHttpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCEBetaTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.TargetHttpProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaTargetHttpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCEBetaTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEBetaTargetHttpProxies.
func (g *GCEBetaTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpProxies.SetUrlMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TargetHttpProxies is an interface that allows for mocking of TargetHttpProxies.
type TargetHttpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetHttpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computega.UrlMapReference, ...Option) error
}

// NewMockTargetHttpProxies returns a new mock for TargetHttpProxies.
func NewMockTargetHttpProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetHttpProxiesObj) *MockTargetHttpProxies {
	mock := &MockTargetHttpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetHttpProxies is the mock for TargetHttpProxies.
type MockTargetHttpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetHttpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockTargetHttpProxies, options ...Option) (bool, *computega.TargetHttpProxy, error)
	ListHook      func(ctx context.Context, fl *filter.F, m *MockTargetHttpProxies, options ...Option) (bool, []*computega.TargetHttpProxy, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, m *MockTargetHttpProxies, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockTargetHttpProxies, options ...Option) (bool, error)
	SetUrlMapHook func(context.Context, *meta.Key, *computega.UrlMapReference, *MockTargetHttpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockTargetHttpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetHttpProxies %v not found", key),
	}
	klog.V(5).Infof("MockTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockTargetHttpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockTargetHttpProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.TargetHttpProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockTargetHttpProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetHttpProxies %v exists", key),
		}
		klog.V(5).Infof("MockTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "targetHttpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "targetHttpProxies", key)

	m.Objects[*key] = &MockTargetHttpProxiesObj{obj}
	klog.V(5).Infof("MockTargetHttpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetHttpProxies %v not found", key),
		}
		klog.V(5).Infof("MockTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockTargetHttpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockTargetHttpProxies) Obj(o *computega.TargetHttpProxy) *MockTargetHttpProxiesObj {
	return &MockTargetHttpProxiesObj{o}
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCETargetHttpProxies is a simplifying adapter for the GCE TargetHttpProxies.
type GCETargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCETargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpProxies",
	}

	klog.V(5).Infof("GCETargetHttpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.TargetHttpProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCETargetHttpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpProxy objects.
func (g *GCETargetHttpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCETargetHttpProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.TargetHttpProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.TargetHttpProxy
	f := func(l *computega.TargetHttpProxyList) error {
		klog.V(5).Infof("GCETargetHttpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCETargetHttpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCETargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCETargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCETargetHttpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.TargetHttpProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetHttpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetHttpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCETargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCETargetHttpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCETargetHttpProxies.
func (g *GCETargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpProxies",
	}
	klog.V(5).Infof("GCETargetHttpProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpProxies.SetUrlMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaRegionTargetHttpProxies is an interface that allows for mocking of RegionTargetHttpProxies.
type AlphaRegionTargetHttpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpProxy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computealpha.UrlMapReference, ...Option) error
}

// NewMockAlphaRegionTargetHttpProxies returns a new mock for RegionTargetHttpProxies.
func NewMockAlphaRegionTargetHttpProxies(pr ProjectRouter, objs map[meta.Key]*MockRegionTargetHttpProxiesObj) *MockAlphaRegionTargetHttpProxies {
	mock := &MockAlphaRegionTargetHttpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionTargetHttpProxies is the mock for RegionTargetHttpProxies.
type MockAlphaRegionTargetHttpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionTargetHttpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockAlphaRegionTargetHttpProxies, options ...Option) (bool, *computealpha.TargetHttpProxy, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionTargetHttpProxies, options ...Option) (bool, []*computealpha.TargetHttpProxy, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, m *MockAlphaRegionTargetHttpProxies, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockAlphaRegionTargetHttpProxies, options ...Option) (bool, error)
	SetUrlMapHook func(context.Context, *meta.Key, *computealpha.UrlMapReference, *MockAlphaRegionTargetHttpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionTargetHttpProxies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionTargetHttpProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.TargetHttpProxy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionTargetHttpProxies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "targetHttpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "targetHttpProxies", key)

	m.Objects[*key] = &MockRegionTargetHttpProxiesObj{obj}
	klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionTargetHttpProxies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionTargetHttpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionTargetHttpProxies) Obj(o *computealpha.TargetHttpProxy) *MockRegionTargetHttpProxiesObj {
	return &MockRegionTargetHttpProxiesObj{o}
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockAlphaRegionTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaRegionTargetHttpProxies is a simplifying adapter for the GCE RegionTargetHttpProxies.
type GCEAlphaRegionTargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCEAlphaRegionTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpProxies",
	}

	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionTargetHttpProxies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpProxy objects.
func (g *GCEAlphaRegionTargetHttpProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionTargetHttpProxies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.TargetHttpProxy
	f := func(l *computealpha.TargetHttpProxyList) error {
		klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCEAlphaRegionTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionTargetHttpProxies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCEAlphaRegionTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionTargetHttpProxies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEAlphaRegionTargetHttpProxies.
func (g *GCEAlphaRegionTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionTargetHttpProxies.SetUrlMap(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaRegionTargetHttpProxies is an interface that allows for mocking of RegionTargetHttpProxies.
type BetaRegionTargetHttpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpProxy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computebeta.UrlMapReference, ...Option) error
}

// NewMockBetaRegionTargetHttpProxies returns a new mock for RegionTargetHttpProxies.
func NewMockBetaRegionTargetHttpProxies(pr ProjectRouter, objs map[meta.Key]*MockRegionTargetHttpProxiesObj) *MockBetaRegionTargetHttpProxies {
	mock := &MockBetaRegionTargetHttpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRegionTargetHttpProxies is the mock for RegionTargetHttpProxies.
type MockBetaRegionTargetHttpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionTargetHttpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockBetaRegionTargetHttpProxies, options ...Option) (bool, *computebeta.TargetHttpProxy, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockBetaRegionTargetHttpProxies, options ...Option) (bool, []*computebeta.TargetHttpProxy, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, m *MockBetaRegionTargetHttpProxies, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockBetaRegionTargetHttpProxies, options ...Option) (bool, error)
	SetUrlMapHook func(context.Context, *meta.Key, *computebeta.UrlMapReference, *MockBetaRegionTargetHttpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRegionTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRegionTargetHttpProxies %v not found", key),
	}
	klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRegionTargetHttpProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpProxies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.TargetHttpProxy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRegionTargetHttpProxies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRegionTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRegionTargetHttpProxies %v exists", key),
		}
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "targetHttpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "targetHttpProxies", key)

	m.Objects[*key] = &MockRegionTargetHttpProxiesObj{obj}
	klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRegionTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRegionTargetHttpProxies %v not found", key),
		}
		klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRegionTargetHttpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRegionTargetHttpProxies) Obj(o *computebeta.TargetHttpProxy) *MockRegionTargetHttpProxiesObj {
	return &MockRegionTargetHttpProxiesObj{o}
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockBetaRegionTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaRegionTargetHttpProxies is a simplifying adapter for the GCE RegionTargetHttpProxies.
type GCEBetaRegionTargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCEBetaRegionTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpProxies",
	}

	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionTargetHttpProxies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpProxy objects.
func (g *GCEBetaRegionTargetHttpProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.RegionTargetHttpProxies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.TargetHttpProxy
	f := func(l *computebeta.TargetHttpProxyList) error {
		klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCEBetaRegionTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.RegionTargetHttpProxies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCEBetaRegionTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionTargetHttpProxies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEBetaRegionTargetHttpProxies.
func (g *GCEBetaRegionTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionTargetHttpProxies.SetUrlMap(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RegionTargetHttpProxies is an interface that allows for mocking of RegionTargetHttpProxies.
type RegionTargetHttpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpProxy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetHttpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computega.UrlMapReference, ...Option) error
}

// NewMockRegionTargetHttpProxies returns a new mock for RegionTargetHttpProxies.
func NewMockRegionTargetHttpProxies(pr ProjectRouter, objs map[meta.Key]*MockRegionTargetHttpProxiesObj) *MockRegionTargetHttpProxies {
	mock := &MockRegionTargetHttpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionTargetHttpProxies is the mock for RegionTargetHttpProxies.
type MockRegionTargetHttpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionTargetHttpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook       func(ctx context.Context, key *meta.Key, m *MockRegionTargetHttpProxies, options ...Option) (bool, *computega.TargetHttpProxy, error)
	ListHook      func(ctx context.Context, region string, fl *filter.F, m *MockRegionTargetHttpProxies, options ...Option) (bool, []*computega.TargetHttpProxy, error)
	InsertHook    func(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, m *MockRegionTargetHttpProxies, options ...Option) (bool, error)
	DeleteHook    func(ctx context.Context, key *meta.Key, m *MockRegionTargetHttpProxies, options ...Option) (bool, error)
	SetUrlMapHook func(context.Context, *meta.Key, *computega.UrlMapReference, *MockRegionTargetHttpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionTargetHttpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionTargetHttpProxies %v not found", key),
	}
	klog.V(5).Infof("MockRegionTargetHttpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionTargetHttpProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetHttpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpProxies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionTargetHttpProxies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.TargetHttpProxy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionTargetHttpProxies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionTargetHttpProxies %v exists", key),
		}
		klog.V(5).Infof("MockRegionTargetHttpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "targetHttpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "targetHttpProxies", key)

	m.Objects[*key] = &MockRegionTargetHttpProxiesObj{obj}
	klog.V(5).Infof("MockRegionTargetHttpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionTargetHttpProxies %v not found", key),
		}
		klog.V(5).Infof("MockRegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionTargetHttpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionTargetHttpProxies) Obj(o *computega.TargetHttpProxy) *MockRegionTargetHttpProxiesObj {
	return &MockRegionTargetHttpProxiesObj{o}
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockRegionTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCERegionTargetHttpProxies is a simplifying adapter for the GCE RegionTargetHttpProxies.
type GCERegionTargetHttpProxies struct {
	s *Service
}

// Get the TargetHttpProxy named by key.
func (g *GCERegionTargetHttpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpProxies",
	}

	klog.V(5).Infof("GCERegionTargetHttpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionTargetHttpProxies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionTargetHttpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpProxy objects.
func (g *GCERegionTargetHttpProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetHttpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpProxies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionTargetHttpProxies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionTargetHttpProxies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.TargetHttpProxy
	f := func(l *computega.TargetHttpProxyList) error {
		klog.V(5).Infof("GCERegionTargetHttpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionTargetHttpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionTargetHttpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpProxy with key of value obj.
func (g *GCERegionTargetHttpProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionTargetHttpProxies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionTargetHttpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionTargetHttpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpProxy referenced by key.
func (g *GCERegionTargetHttpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionTargetHttpProxies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionTargetHttpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCERegionTargetHttpProxies.
func (g *GCERegionTargetHttpProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionTargetHttpProxies.SetUrlMap(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionTargetHttpProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TargetHttpsProxies is an interface that allows for mocking of TargetHttpsProxies.
type TargetHttpsProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpsProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetHttpsProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetCertificateMap(context.Context, *meta.Key, *computega.TargetHttpsProxiesSetCertificateMapRequest, ...Option) error
	SetSslCertificates(context.Context, *meta.Key, *computega.TargetHttpsProxiesSetSslCertificatesRequest, ...Option) error
	SetSslPolicy(context.Context, *meta.Key, *computega.SslPolicyReference, ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computega.UrlMapReference, ...Option) error
}

// NewMockTargetHttpsProxies returns a new mock for TargetHttpsProxies.
func NewMockTargetHttpsProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetHttpsProxiesObj) *MockTargetHttpsProxies {
	mock := &MockTargetHttpsProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetHttpsProxies is the mock for TargetHttpsProxies.
type MockTargetHttpsProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetHttpsProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockTargetHttpsProxies, options ...Option) (bool, *computega.TargetHttpsProxy, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockTargetHttpsProxies, options ...Option) (bool, []*computega.TargetHttpsProxy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, m *MockTargetHttpsProxies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockTargetHttpsProxies, options ...Option) (bool, error)
	SetCertificateMapHook  func(context.Context, *meta.Key, *computega.TargetHttpsProxiesSetCertificateMapRequest, *MockTargetHttpsProxies, ...Option) error
	SetSslCertificatesHook func(context.Context, *meta.Key, *computega.TargetHttpsProxiesSetSslCertificatesRequest, *MockTargetHttpsProxies, ...Option) error
	SetSslPolicyHook       func(context.Context, *meta.Key, *computega.SslPolicyReference, *MockTargetHttpsProxies, ...Option) error
	SetUrlMapHook          func(context.Context, *meta.Key, *computega.UrlMapReference, *MockTargetHttpsProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpsProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockTargetHttpsProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetHttpsProxies %v not found", key),
	}
	klog.V(5).Infof("MockTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockTargetHttpsProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpsProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockTargetHttpsProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.TargetHttpsProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockTargetHttpsProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetHttpsProxies %v exists", key),
		}
		klog.V(5).Infof("MockTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "targetHttpsProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "targetHttpsProxies", key)

	m.Objects[*key] = &MockTargetHttpsProxiesObj{obj}
	klog.V(5).Infof("MockTargetHttpsProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetHttpsProxies %v not found", key),
		}
		klog.V(5).Infof("MockTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockTargetHttpsProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockTargetHttpsProxies) Obj(o *computega.TargetHttpsProxy) *MockTargetHttpsProxiesObj {
	return &MockTargetHttpsProxiesObj{o}
}

// SetCertificateMap is a mock for the corresponding method.
func (m *MockTargetHttpsProxies) SetCertificateMap(ctx context.Context, key *meta.Key, arg0 *computega.TargetHttpsProxiesSetCertificateMapRequest, options ...Option) error {
	if m.SetCertificateMapHook != nil {
		return m.SetCertificateMapHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslCertificates is a mock for the corresponding method.
func (m *MockTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computega.TargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslPolicy is a mock for the corresponding method.
func (m *MockTargetHttpsProxies) SetSslPolicy(ctx context.Context, key *meta.Key, arg0 *computega.SslPolicyReference, options ...Option) error {
	if m.SetSslPolicyHook != nil {
		return m.SetSslPolicyHook(ctx, key, arg0, m)
	}
	return nil
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCETargetHttpsProxies is a simplifying adapter for the GCE TargetHttpsProxies.
type GCETargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCETargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}

	klog.V(5).Infof("GCETargetHttpsProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.TargetHttpsProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCETargetHttpsProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpsProxy objects.
func (g *GCETargetHttpsProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCETargetHttpsProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.TargetHttpsProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.TargetHttpsProxy
	f := func(l *computega.TargetHttpsProxyList) error {
		klog.V(5).Infof("GCETargetHttpsProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCETargetHttpsProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCETargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCETargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCETargetHttpsProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.TargetHttpsProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetHttpsProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCETargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCETargetHttpsProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpsProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetCertificateMap is a method on GCETargetHttpsProxies.
func (g *GCETargetHttpsProxies) SetCertificateMap(ctx context.Context, key *meta.Key, arg0 *computega.TargetHttpsProxiesSetCertificateMapRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.SetCertificateMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.SetCertificateMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetCertificateMap",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCETargetHttpsProxies.SetCertificateMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.SetCertificateMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpsProxies.SetCertificateMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpsProxies.SetCertificateMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetHttpsProxies.SetCertificateMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslCertificates is a method on GCETargetHttpsProxies.
func (g *GCETargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computega.TargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslCertificates",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCETargetHttpsProxies.SetSslCertificates(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.SetSslCertificates(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpsProxies.SetSslCertificates(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslPolicy is a method on GCETargetHttpsProxies.
func (g *GCETargetHttpsProxies) SetSslPolicy(ctx context.Context, key *meta.Key, arg0 *computega.SslPolicyReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.SetSslPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.SetSslPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslPolicy",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCETargetHttpsProxies.SetSslPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.SetSslPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpsProxies.SetSslPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpsProxies.SetSslPolicy(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetHttpsProxies.SetSslPolicy(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCETargetHttpsProxies.
func (g *GCETargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("ga"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCETargetHttpsProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetHttpsProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetHttpsProxies.SetUrlMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaTargetHttpsProxies is an interface that allows for mocking of TargetHttpsProxies.
type AlphaTargetHttpsProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpsProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpsProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetCertificateMap(context.Context, *meta.Key, *computealpha.TargetHttpsProxiesSetCertificateMapRequest, ...Option) error
	SetSslCertificates(context.Context, *meta.Key, *computealpha.TargetHttpsProxiesSetSslCertificatesRequest, ...Option) error
	SetSslPolicy(context.Context, *meta.Key, *computealpha.SslPolicyReference, ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computealpha.UrlMapReference, ...Option) error
}

// NewMockAlphaTargetHttpsProxies returns a new mock for TargetHttpsProxies.
func NewMockAlphaTargetHttpsProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetHttpsProxiesObj) *MockAlphaTargetHttpsProxies {
	mock := &MockAlphaTargetHttpsProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaTargetHttpsProxies is the mock for TargetHttpsProxies.
type MockAlphaTargetHttpsProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetHttpsProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaTargetHttpsProxies, options ...Option) (bool, *computealpha.TargetHttpsProxy, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockAlphaTargetHttpsProxies, options ...Option) (bool, []*computealpha.TargetHttpsProxy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, m *MockAlphaTargetHttpsProxies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaTargetHttpsProxies, options ...Option) (bool, error)
	SetCertificateMapHook  func(context.Context, *meta.Key, *computealpha.TargetHttpsProxiesSetCertificateMapRequest, *MockAlphaTargetHttpsProxies, ...Option) error
	SetSslCertificatesHook func(context.Context, *meta.Key, *computealpha.TargetHttpsProxiesSetSslCertificatesRequest, *MockAlphaTargetHttpsProxies, ...Option) error
	SetSslPolicyHook       func(context.Context, *meta.Key, *computealpha.SslPolicyReference, *MockAlphaTargetHttpsProxies, ...Option) error
	SetUrlMapHook          func(context.Context, *meta.Key, *computealpha.UrlMapReference, *MockAlphaTargetHttpsProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpsProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaTargetHttpsProxies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaTargetHttpsProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpsProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.TargetHttpsProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaTargetHttpsProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaTargetHttpsProxies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "targetHttpsProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "targetHttpsProxies", key)

	m.Objects[*key] = &MockTargetHttpsProxiesObj{obj}
	klog.V(5).Infof("MockAlphaTargetHttpsProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaTargetHttpsProxies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaTargetHttpsProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaTargetHttpsProxies) Obj(o *computealpha.TargetHttpsProxy) *MockTargetHttpsProxiesObj {
	return &MockTargetHttpsProxiesObj{o}
}

// SetCertificateMap is a mock for the corresponding method.
func (m *MockAlphaTargetHttpsProxies) SetCertificateMap(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetHttpsProxiesSetCertificateMapRequest, options ...Option) error {
	if m.SetCertificateMapHook != nil {
		return m.SetCertificateMapHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslCertificates is a mock for the corresponding method.
func (m *MockAlphaTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslPolicy is a mock for the corresponding method.
func (m *MockAlphaTargetHttpsProxies) SetSslPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.SslPolicyReference, options ...Option) error {
	if m.SetSslPolicyHook != nil {
		return m.SetSslPolicyHook(ctx, key, arg0, m)
	}
	return nil
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockAlphaTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaTargetHttpsProxies is a simplifying adapter for the GCE TargetHttpsProxies.
type GCEAlphaTargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCEAlphaTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}

	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.TargetHttpsProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpsProxy objects.
func (g *GCEAlphaTargetHttpsProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.TargetHttpsProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.TargetHttpsProxy
	f := func(l *computealpha.TargetHttpsProxyList) error {
		klog.V(5).Infof("GCEAlphaTargetHttpsProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCEAlphaTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.TargetHttpsProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCEAlphaTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpsProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetCertificateMap is a method on GCEAlphaTargetHttpsProxies.
func (g *GCEAlphaTargetHttpsProxies) SetCertificateMap(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetHttpsProxiesSetCertificateMapRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetCertificateMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.SetCertificateMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetCertificateMap",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetCertificateMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetCertificateMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpsProxies.SetCertificateMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetCertificateMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetCertificateMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslCertificates is a method on GCEAlphaTargetHttpsProxies.
func (g *GCEAlphaTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslCertificates",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetSslCertificates(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetSslCertificates(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpsProxies.SetSslCertificates(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslPolicy is a method on GCEAlphaTargetHttpsProxies.
func (g *GCEAlphaTargetHttpsProxies) SetSslPolicy(ctx context.Context, key *meta.Key, arg0 *computealpha.SslPolicyReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetSslPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.SetSslPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslPolicy",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetSslPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetSslPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpsProxies.SetSslPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetSslPolicy(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetSslPolicy(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEAlphaTargetHttpsProxies.
func (g *GCEAlphaTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("alpha"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetHttpsProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetHttpsProxies.SetUrlMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaTargetHttpsProxies is an interface that allows for mocking of TargetHttpsProxies.
type BetaTargetHttpsProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpsProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpsProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetCertificateMap(context.Context, *meta.Key, *computebeta.TargetHttpsProxiesSetCertificateMapRequest, ...Option) error
	SetSslCertificates(context.Context, *meta.Key, *computebeta.TargetHttpsProxiesSetSslCertificatesRequest, ...Option) error
	SetSslPolicy(context.Context, *meta.Key, *computebeta.SslPolicyReference, ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computebeta.UrlMapReference, ...Option) error
}

// NewMockBetaTargetHttpsProxies returns a new mock for TargetHttpsProxies.
func NewMockBetaTargetHttpsProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetHttpsProxiesObj) *MockBetaTargetHttpsProxies {
	mock := &MockBetaTargetHttpsProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaTargetHttpsProxies is the mock for TargetHttpsProxies.
type MockBetaTargetHttpsProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetHttpsProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockBetaTargetHttpsProxies, options ...Option) (bool, *computebeta.TargetHttpsProxy, error)
	ListHook               func(ctx context.Context, fl *filter.F, m *MockBetaTargetHttpsProxies, options ...Option) (bool, []*computebeta.TargetHttpsProxy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, m *MockBetaTargetHttpsProxies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockBetaTargetHttpsProxies, options ...Option) (bool, error)
	SetCertificateMapHook  func(context.Context, *meta.Key, *computebeta.TargetHttpsProxiesSetCertificateMapRequest, *MockBetaTargetHttpsProxies, ...Option) error
	SetSslCertificatesHook func(context.Context, *meta.Key, *computebeta.TargetHttpsProxiesSetSslCertificatesRequest, *MockBetaTargetHttpsProxies, ...Option) error
	SetSslPolicyHook       func(context.Context, *meta.Key, *computebeta.SslPolicyReference, *MockBetaTargetHttpsProxies, ...Option) error
	SetUrlMapHook          func(context.Context, *meta.Key, *computebeta.UrlMapReference, *MockBetaTargetHttpsProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpsProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaTargetHttpsProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaTargetHttpsProxies %v not found", key),
	}
	klog.V(5).Infof("MockBetaTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaTargetHttpsProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpsProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaTargetHttpsProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.TargetHttpsProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaTargetHttpsProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaTargetHttpsProxies %v exists", key),
		}
		klog.V(5).Infof("MockBetaTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "targetHttpsProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "targetHttpsProxies", key)

	m.Objects[*key] = &MockTargetHttpsProxiesObj{obj}
	klog.V(5).Infof("MockBetaTargetHttpsProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaTargetHttpsProxies %v not found", key),
		}
		klog.V(5).Infof("MockBetaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaTargetHttpsProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaTargetHttpsProxies) Obj(o *computebeta.TargetHttpsProxy) *MockTargetHttpsProxiesObj {
	return &MockTargetHttpsProxiesObj{o}
}

// SetCertificateMap is a mock for the corresponding method.
func (m *MockBetaTargetHttpsProxies) SetCertificateMap(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetHttpsProxiesSetCertificateMapRequest, options ...Option) error {
	if m.SetCertificateMapHook != nil {
		return m.SetCertificateMapHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslCertificates is a mock for the corresponding method.
func (m *MockBetaTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslPolicy is a mock for the corresponding method.
func (m *MockBetaTargetHttpsProxies) SetSslPolicy(ctx context.Context, key *meta.Key, arg0 *computebeta.SslPolicyReference, options ...Option) error {
	if m.SetSslPolicyHook != nil {
		return m.SetSslPolicyHook(ctx, key, arg0, m)
	}
	return nil
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockBetaTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaTargetHttpsProxies is a simplifying adapter for the GCE TargetHttpsProxies.
type GCEBetaTargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCEBetaTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}

	klog.V(5).Infof("GCEBetaTargetHttpsProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.TargetHttpsProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaTargetHttpsProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpsProxy objects.
func (g *GCEBetaTargetHttpsProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.TargetHttpsProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.TargetHttpsProxy
	f := func(l *computebeta.TargetHttpsProxyList) error {
		klog.V(5).Infof("GCEBetaTargetHttpsProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCEBetaTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.TargetHttpsProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaTargetHttpsProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCEBetaTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpsProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetCertificateMap is a method on GCEBetaTargetHttpsProxies.
func (g *GCEBetaTargetHttpsProxies) SetCertificateMap(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetHttpsProxiesSetCertificateMapRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetCertificateMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.SetCertificateMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetCertificateMap",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetCertificateMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetCertificateMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpsProxies.SetCertificateMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetCertificateMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetCertificateMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslCertificates is a method on GCEBetaTargetHttpsProxies.
func (g *GCEBetaTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslCertificates",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetSslCertificates(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetSslCertificates(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpsProxies.SetSslCertificates(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslPolicy is a method on GCEBetaTargetHttpsProxies.
func (g *GCEBetaTargetHttpsProxies) SetSslPolicy(ctx context.Context, key *meta.Key, arg0 *computebeta.SslPolicyReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetSslPolicy(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.SetSslPolicy(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslPolicy",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetSslPolicy(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetSslPolicy(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpsProxies.SetSslPolicy(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetSslPolicy(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetSslPolicy(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEBetaTargetHttpsProxies.
func (g *GCEBetaTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("beta"),
		Service:   "TargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaTargetHttpsProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetHttpsProxies.SetUrlMap(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaRegionTargetHttpsProxies is an interface that allows for mocking of RegionTargetHttpsProxies.
type AlphaRegionTargetHttpsProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpsProxy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpsProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computealpha.TargetHttpsProxy, ...Option) error
	SetSslCertificates(context.Context, *meta.Key, *computealpha.RegionTargetHttpsProxiesSetSslCertificatesRequest, ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computealpha.UrlMapReference, ...Option) error
}

// NewMockAlphaRegionTargetHttpsProxies returns a new mock for RegionTargetHttpsProxies.
func NewMockAlphaRegionTargetHttpsProxies(pr ProjectRouter, objs map[meta.Key]*MockRegionTargetHttpsProxiesObj) *MockAlphaRegionTargetHttpsProxies {
	mock := &MockAlphaRegionTargetHttpsProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionTargetHttpsProxies is the mock for RegionTargetHttpsProxies.
type MockAlphaRegionTargetHttpsProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionTargetHttpsProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockAlphaRegionTargetHttpsProxies, options ...Option) (bool, *computealpha.TargetHttpsProxy, error)
	ListHook               func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionTargetHttpsProxies, options ...Option) (bool, []*computealpha.TargetHttpsProxy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, m *MockAlphaRegionTargetHttpsProxies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockAlphaRegionTargetHttpsProxies, options ...Option) (bool, error)
	PatchHook              func(context.Context, *meta.Key, *computealpha.TargetHttpsProxy, *MockAlphaRegionTargetHttpsProxies, ...Option) error
	SetSslCertificatesHook func(context.Context, *meta.Key, *computealpha.RegionTargetHttpsProxiesSetSslCertificatesRequest, *MockAlphaRegionTargetHttpsProxies, ...Option) error
	SetUrlMapHook          func(context.Context, *meta.Key, *computealpha.UrlMapReference, *MockAlphaRegionTargetHttpsProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionTargetHttpsProxies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionTargetHttpsProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.TargetHttpsProxy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionTargetHttpsProxies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "targetHttpsProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "targetHttpsProxies", key)

	m.Objects[*key] = &MockRegionTargetHttpsProxiesObj{obj}
	klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionTargetHttpsProxies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionTargetHttpsProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionTargetHttpsProxies) Obj(o *computealpha.TargetHttpsProxy) *MockRegionTargetHttpsProxiesObj {
	return &MockRegionTargetHttpsProxiesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockAlphaRegionTargetHttpsProxies) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetHttpsProxy, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslCertificates is a mock for the corresponding method.
func (m *MockAlphaRegionTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computealpha.RegionTargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockAlphaRegionTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaRegionTargetHttpsProxies is a simplifying adapter for the GCE RegionTargetHttpsProxies.
type GCEAlphaRegionTargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCEAlphaRegionTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpsProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}

	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionTargetHttpsProxies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpsProxy objects.
func (g *GCEAlphaRegionTargetHttpsProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionTargetHttpsProxies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.TargetHttpsProxy
	f := func(l *computealpha.TargetHttpsProxyList) error {
		klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCEAlphaRegionTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpsProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionTargetHttpsProxies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCEAlphaRegionTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpsProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionTargetHttpsProxies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEAlphaRegionTargetHttpsProxies.
func (g *GCEAlphaRegionTargetHttpsProxies) Patch(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpsProxies.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionTargetHttpsProxies.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslCertificates is a method on GCEAlphaRegionTargetHttpsProxies.
func (g *GCEAlphaRegionTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computealpha.RegionTargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslCertificates",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionTargetHttpsProxies.SetSslCertificates(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEAlphaRegionTargetHttpsProxies.
func (g *GCEAlphaRegionTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("alpha"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEAlphaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionTargetHttpsProxies.SetUrlMap(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaRegionTargetHttpsProxies is an interface that allows for mocking of RegionTargetHttpsProxies.
type BetaRegionTargetHttpsProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpsProxy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpsProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computebeta.TargetHttpsProxy, ...Option) error
	SetSslCertificates(context.Context, *meta.Key, *computebeta.RegionTargetHttpsProxiesSetSslCertificatesRequest, ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computebeta.UrlMapReference, ...Option) error
}

// NewMockBetaRegionTargetHttpsProxies returns a new mock for RegionTargetHttpsProxies.
func NewMockBetaRegionTargetHttpsProxies(pr ProjectRouter, objs map[meta.Key]*MockRegionTargetHttpsProxiesObj) *MockBetaRegionTargetHttpsProxies {
	mock := &MockBetaRegionTargetHttpsProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRegionTargetHttpsProxies is the mock for RegionTargetHttpsProxies.
type MockBetaRegionTargetHttpsProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionTargetHttpsProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockBetaRegionTargetHttpsProxies, options ...Option) (bool, *computebeta.TargetHttpsProxy, error)
	ListHook               func(ctx context.Context, region string, fl *filter.F, m *MockBetaRegionTargetHttpsProxies, options ...Option) (bool, []*computebeta.TargetHttpsProxy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, m *MockBetaRegionTargetHttpsProxies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockBetaRegionTargetHttpsProxies, options ...Option) (bool, error)
	PatchHook              func(context.Context, *meta.Key, *computebeta.TargetHttpsProxy, *MockBetaRegionTargetHttpsProxies, ...Option) error
	SetSslCertificatesHook func(context.Context, *meta.Key, *computebeta.RegionTargetHttpsProxiesSetSslCertificatesRequest, *MockBetaRegionTargetHttpsProxies, ...Option) error
	SetUrlMapHook          func(context.Context, *meta.Key, *computebeta.UrlMapReference, *MockBetaRegionTargetHttpsProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRegionTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRegionTargetHttpsProxies %v not found", key),
	}
	klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRegionTargetHttpsProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.TargetHttpsProxy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRegionTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRegionTargetHttpsProxies %v exists", key),
		}
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "targetHttpsProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "targetHttpsProxies", key)

	m.Objects[*key] = &MockRegionTargetHttpsProxiesObj{obj}
	klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRegionTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRegionTargetHttpsProxies %v not found", key),
		}
		klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRegionTargetHttpsProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRegionTargetHttpsProxies) Obj(o *computebeta.TargetHttpsProxy) *MockRegionTargetHttpsProxiesObj {
	return &MockRegionTargetHttpsProxiesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockBetaRegionTargetHttpsProxies) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetHttpsProxy, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslCertificates is a mock for the corresponding method.
func (m *MockBetaRegionTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computebeta.RegionTargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockBetaRegionTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaRegionTargetHttpsProxies is a simplifying adapter for the GCE RegionTargetHttpsProxies.
type GCEBetaRegionTargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCEBetaRegionTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpsProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}

	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionTargetHttpsProxies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpsProxy objects.
func (g *GCEBetaRegionTargetHttpsProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.RegionTargetHttpsProxies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.TargetHttpsProxy
	f := func(l *computebeta.TargetHttpsProxyList) error {
		klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCEBetaRegionTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpsProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.RegionTargetHttpsProxies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCEBetaRegionTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpsProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionTargetHttpsProxies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCEBetaRegionTargetHttpsProxies.
func (g *GCEBetaRegionTargetHttpsProxies) Patch(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpsProxies.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionTargetHttpsProxies.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslCertificates is a method on GCEBetaRegionTargetHttpsProxies.
func (g *GCEBetaRegionTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computebeta.RegionTargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslCertificates",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionTargetHttpsProxies.SetSslCertificates(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCEBetaRegionTargetHttpsProxies.
func (g *GCEBetaRegionTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("beta"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCEBetaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionTargetHttpsProxies.SetUrlMap(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RegionTargetHttpsProxies is an interface that allows for mocking of RegionTargetHttpsProxies.
type RegionTargetHttpsProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpsProxy, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetHttpsProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *computega.TargetHttpsProxy, ...Option) error
	SetSslCertificates(context.Context, *meta.Key, *computega.RegionTargetHttpsProxiesSetSslCertificatesRequest, ...Option) error
	SetUrlMap(context.Context, *meta.Key, *computega.UrlMapReference, ...Option) error
}

// NewMockRegionTargetHttpsProxies returns a new mock for RegionTargetHttpsProxies.
func NewMockRegionTargetHttpsProxies(pr ProjectRouter, objs map[meta.Key]*MockRegionTargetHttpsProxiesObj) *MockRegionTargetHttpsProxies {
	mock := &MockRegionTargetHttpsProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionTargetHttpsProxies is the mock for RegionTargetHttpsProxies.
type MockRegionTargetHttpsProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionTargetHttpsProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook                func(ctx context.Context, key *meta.Key, m *MockRegionTargetHttpsProxies, options ...Option) (bool, *computega.TargetHttpsProxy, error)
	ListHook               func(ctx context.Context, region string, fl *filter.F, m *MockRegionTargetHttpsProxies, options ...Option) (bool, []*computega.TargetHttpsProxy, error)
	InsertHook             func(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, m *MockRegionTargetHttpsProxies, options ...Option) (bool, error)
	DeleteHook             func(ctx context.Context, key *meta.Key, m *MockRegionTargetHttpsProxies, options ...Option) (bool, error)
	PatchHook              func(context.Context, *meta.Key, *computega.TargetHttpsProxy, *MockRegionTargetHttpsProxies, ...Option) error
	SetSslCertificatesHook func(context.Context, *meta.Key, *computega.RegionTargetHttpsProxiesSetSslCertificatesRequest, *MockRegionTargetHttpsProxies, ...Option) error
	SetUrlMapHook          func(context.Context, *meta.Key, *computega.UrlMapReference, *MockRegionTargetHttpsProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpsProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpsProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionTargetHttpsProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionTargetHttpsProxies %v not found", key),
	}
	klog.V(5).Infof("MockRegionTargetHttpsProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionTargetHttpsProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetHttpsProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpsProxies.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionTargetHttpsProxies.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.TargetHttpsProxy
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionTargetHttpsProxies.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionTargetHttpsProxies %v exists", key),
		}
		klog.V(5).Infof("MockRegionTargetHttpsProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "targetHttpsProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "targetHttpsProxies", key)

	m.Objects[*key] = &MockRegionTargetHttpsProxiesObj{obj}
	klog.V(5).Infof("MockRegionTargetHttpsProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionTargetHttpsProxies %v not found", key),
		}
		klog.V(5).Infof("MockRegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionTargetHttpsProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionTargetHttpsProxies) Obj(o *computega.TargetHttpsProxy) *MockRegionTargetHttpsProxiesObj {
	return &MockRegionTargetHttpsProxiesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockRegionTargetHttpsProxies) Patch(ctx context.Context, key *meta.Key, arg0 *computega.TargetHttpsProxy, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// SetSslCertificates is a mock for the corresponding method.
func (m *MockRegionTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computega.RegionTargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	if m.SetSslCertificatesHook != nil {
		return m.SetSslCertificatesHook(ctx, key, arg0, m)
	}
	return nil
}

// SetUrlMap is a mock for the corresponding method.
func (m *MockRegionTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	if m.SetUrlMapHook != nil {
		return m.SetUrlMapHook(ctx, key, arg0, m)
	}
	return nil
}

// GCERegionTargetHttpsProxies is a simplifying adapter for the GCE RegionTargetHttpsProxies.
type GCERegionTargetHttpsProxies struct {
	s *Service
}

// Get the TargetHttpsProxy named by key.
func (g *GCERegionTargetHttpsProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpsProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}

	klog.V(5).Infof("GCERegionTargetHttpsProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionTargetHttpsProxies.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionTargetHttpsProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetHttpsProxy objects.
func (g *GCERegionTargetHttpsProxies) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetHttpsProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionTargetHttpsProxies.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionTargetHttpsProxies.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.TargetHttpsProxy
	f := func(l *computega.TargetHttpsProxyList) error {
		klog.V(5).Infof("GCERegionTargetHttpsProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionTargetHttpsProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetHttpsProxy with key of value obj.
func (g *GCERegionTargetHttpsProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpsProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionTargetHttpsProxies.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionTargetHttpsProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetHttpsProxy referenced by key.
func (g *GCERegionTargetHttpsProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpsProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionTargetHttpsProxies.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionTargetHttpsProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on GCERegionTargetHttpsProxies.
func (g *GCERegionTargetHttpsProxies) Patch(ctx context.Context, key *meta.Key, arg0 *computega.TargetHttpsProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpsProxies.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpsProxies.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionTargetHttpsProxies.Patch(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionTargetHttpsProxies.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionTargetHttpsProxies.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetSslCertificates is a method on GCERegionTargetHttpsProxies.
func (g *GCERegionTargetHttpsProxies) SetSslCertificates(ctx context.Context, key *meta.Key, arg0 *computega.RegionTargetHttpsProxiesSetSslCertificatesRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpsProxies.SetSslCertificates(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetSslCertificates",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionTargetHttpsProxies.SetSslCertificates(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionTargetHttpsProxies.SetSslCertificates(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// SetUrlMap is a method on GCERegionTargetHttpsProxies.
func (g *GCERegionTargetHttpsProxies) SetUrlMap(ctx context.Context, key *meta.Key, arg0 *computega.UrlMapReference, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionTargetHttpsProxies.SetUrlMap(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionTargetHttpsProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetUrlMap",
		Version:   meta.Version("ga"),
		Service:   "RegionTargetHttpsProxies",
	}
	klog.V(5).Infof("GCERegionTargetHttpsProxies.SetUrlMap(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionTargetHttpsProxies.SetUrlMap(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionTargetHttpsProxies.SetUrlMap(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionTargetHttpsProxies.SetUrlMap(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TargetPools is an interface that allows for mocking of TargetPools.
type TargetPools interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetPool, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetPool, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.TargetPool, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	AddInstance(context.Context, *meta.Key, *computega.TargetPoolsAddInstanceRequest, ...Option) error
	RemoveInstance(context.Context, *meta.Key, *computega.TargetPoolsRemoveInstanceRequest, ...Option) error
}

// NewMockTargetPools returns a new mock for TargetPools.
func NewMockTargetPools(pr ProjectRouter, objs map[meta.Key]*MockTargetPoolsObj) *MockTargetPools {
	mock := &MockTargetPools{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetPools is the mock for TargetPools.
type MockTargetPools struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetPoolsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook            func(ctx context.Context, key *meta.Key, m *MockTargetPools, options ...Option) (bool, *computega.TargetPool, error)
	ListHook           func(ctx context.Context, region string, fl *filter.F, m *MockTargetPools, options ...Option) (bool, []*computega.TargetPool, error)
	InsertHook         func(ctx context.Context, key *meta.Key, obj *computega.TargetPool, m *MockTargetPools, options ...Option) (bool, error)
	DeleteHook         func(ctx context.Context, key *meta.Key, m *MockTargetPools, options ...Option) (bool, error)
	AddInstanceHook    func(context.Context, *meta.Key, *computega.TargetPoolsAddInstanceRequest, *MockTargetPools, ...Option) error
	RemoveInstanceHook func(context.Context, *meta.Key, *computega.TargetPoolsRemoveInstanceRequest, *MockTargetPools, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetPools) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetPool, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetPools.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockTargetPools.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockTargetPools.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetPools %v not found", key),
	}
	klog.V(5).Infof("MockTargetPools.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockTargetPools) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetPool, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockTargetPools.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockTargetPools.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.TargetPool
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockTargetPools.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetPools) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetPool, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockTargetPools.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockTargetPools.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetPools %v exists", key),
		}
		klog.V(5).Infof("MockTargetPools.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "targetPools")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "targetPools", key)

	m.Objects[*key] = &MockTargetPoolsObj{obj}
	klog.V(5).Infof("MockTargetPools.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetPools) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetPools.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockTargetPools.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetPools %v not found", key),
		}
		klog.V(5).Infof("MockTargetPools.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockTargetPools.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockTargetPools) Obj(o *computega.TargetPool) *MockTargetPoolsObj {
	return &MockTargetPoolsObj{o}
}

// AddInstance is a mock for the corresponding method.
func (m *MockTargetPools) AddInstance(ctx context.Context, key *meta.Key, arg0 *computega.TargetPoolsAddInstanceRequest, options ...Option) error {
	if m.AddInstanceHook != nil {
		return m.AddInstanceHook(ctx, key, arg0, m)
	}
	return nil
}

// RemoveInstance is a mock for the corresponding method.
func (m *MockTargetPools) RemoveInstance(ctx context.Context, key *meta.Key, arg0 *computega.TargetPoolsRemoveInstanceRequest, options ...Option) error {
	if m.RemoveInstanceHook != nil {
		return m.RemoveInstanceHook(ctx, key, arg0, m)
	}
	return nil
}

// GCETargetPools is a simplifying adapter for the GCE TargetPools.
type GCETargetPools struct {
	s *Service
}

// Get the TargetPool named by key.
func (g *GCETargetPools) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetPool, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetPools.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetPools.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetPools")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "TargetPools",
	}

	klog.V(5).Infof("GCETargetPools.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetPools.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.TargetPools.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCETargetPools.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetPool objects.
func (g *GCETargetPools) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.TargetPool, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetPools.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetPools")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "TargetPools",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCETargetPools.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.TargetPools.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.TargetPool
	f := func(l *computega.TargetPoolList) error {
		klog.V(5).Infof("GCETargetPools.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetPools.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCETargetPools.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCETargetPools.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetPool with key of value obj.
func (g *GCETargetPools) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetPool, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetPools.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetPools.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetPools")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "TargetPools",
	}
	klog.V(5).Infof("GCETargetPools.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetPools.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.TargetPools.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetPools.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetPools.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetPool referenced by key.
func (g *GCETargetPools) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetPools.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetPools.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetPools")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "TargetPools",
	}
	klog.V(5).Infof("GCETargetPools.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetPools.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetPools.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetPools.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetPools.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// AddInstance is a method on GCETargetPools.
func (g *GCETargetPools) AddInstance(ctx context.Context, key *meta.Key, arg0 *computega.TargetPoolsAddInstanceRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetPools.AddInstance(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetPools.AddInstance(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetPools")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "AddInstance",
		Version:   meta.Version("ga"),
		Service:   "TargetPools",
	}
	klog.V(5).Infof("GCETargetPools.AddInstance(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetPools.AddInstance(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetPools.AddInstance(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetPools.AddInstance(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetPools.AddInstance(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RemoveInstance is a method on GCETargetPools.
func (g *GCETargetPools) RemoveInstance(ctx context.Context, key *meta.Key, arg0 *computega.TargetPoolsRemoveInstanceRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetPools.RemoveInstance(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetPools.RemoveInstance(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetPools")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "RemoveInstance",
		Version:   meta.Version("ga"),
		Service:   "TargetPools",
	}
	klog.V(5).Infof("GCETargetPools.RemoveInstance(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetPools.RemoveInstance(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetPools.RemoveInstance(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetPools.RemoveInstance(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetPools.RemoveInstance(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaTargetTcpProxies is an interface that allows for mocking of TargetTcpProxies.
type AlphaTargetTcpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetTcpProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetTcpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetTcpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetBackendService(context.Context, *meta.Key, *computealpha.TargetTcpProxiesSetBackendServiceRequest, ...Option) error
}

// NewMockAlphaTargetTcpProxies returns a new mock for TargetTcpProxies.
func NewMockAlphaTargetTcpProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetTcpProxiesObj) *MockAlphaTargetTcpProxies {
	mock := &MockAlphaTargetTcpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaTargetTcpProxies is the mock for TargetTcpProxies.
type MockAlphaTargetTcpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetTcpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook               func(ctx context.Context, key *meta.Key, m *MockAlphaTargetTcpProxies, options ...Option) (bool, *computealpha.TargetTcpProxy, error)
	ListHook              func(ctx context.Context, fl *filter.F, m *MockAlphaTargetTcpProxies, options ...Option) (bool, []*computealpha.TargetTcpProxy, error)
	InsertHook            func(ctx context.Context, key *meta.Key, obj *computealpha.TargetTcpProxy, m *MockAlphaTargetTcpProxies, options ...Option) (bool, error)
	DeleteHook            func(ctx context.Context, key *meta.Key, m *MockAlphaTargetTcpProxies, options ...Option) (bool, error)
	SetBackendServiceHook func(context.Context, *meta.Key, *computealpha.TargetTcpProxiesSetBackendServiceRequest, *MockAlphaTargetTcpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaTargetTcpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetTcpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetTcpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetTcpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaTargetTcpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaTargetTcpProxies %v not found", key),
	}
	klog.V(5).Infof("MockAlphaTargetTcpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaTargetTcpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetTcpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetTcpProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaTargetTcpProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.TargetTcpProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaTargetTcpProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaTargetTcpProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetTcpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaTargetTcpProxies %v exists", key),
		}
		klog.V(5).Infof("MockAlphaTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "targetTcpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "targetTcpProxies", key)

	m.Objects[*key] = &MockTargetTcpProxiesObj{obj}
	klog.V(5).Infof("MockAlphaTargetTcpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaTargetTcpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaTargetTcpProxies %v not found", key),
		}
		klog.V(5).Infof("MockAlphaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaTargetTcpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaTargetTcpProxies) Obj(o *computealpha.TargetTcpProxy) *MockTargetTcpProxiesObj {
	return &MockTargetTcpProxiesObj{o}
}

// SetBackendService is a mock for the corresponding method.
func (m *MockAlphaTargetTcpProxies) SetBackendService(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetTcpProxiesSetBackendServiceRequest, options ...Option) error {
	if m.SetBackendServiceHook != nil {
		return m.SetBackendServiceHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaTargetTcpProxies is a simplifying adapter for the GCE TargetTcpProxies.
type GCEAlphaTargetTcpProxies struct {
	s *Service
}

// Get the TargetTcpProxy named by key.
func (g *GCEAlphaTargetTcpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.TargetTcpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetTcpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "TargetTcpProxies",
	}

	klog.V(5).Infof("GCEAlphaTargetTcpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.TargetTcpProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaTargetTcpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetTcpProxy objects.
func (g *GCEAlphaTargetTcpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.TargetTcpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "TargetTcpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.TargetTcpProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.TargetTcpProxy
	f := func(l *computealpha.TargetTcpProxyList) error {
		klog.V(5).Infof("GCEAlphaTargetTcpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetTcpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaTargetTcpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetTcpProxy with key of value obj.
func (g *GCEAlphaTargetTcpProxies) Insert(ctx context.Context, key *meta.Key, obj *computealpha.TargetTcpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetTcpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.TargetTcpProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaTargetTcpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetTcpProxy referenced by key.
func (g *GCEAlphaTargetTcpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetTcpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetTcpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetTcpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetBackendService is a method on GCEAlphaTargetTcpProxies.
func (g *GCEAlphaTargetTcpProxies) SetBackendService(ctx context.Context, key *meta.Key, arg0 *computealpha.TargetTcpProxiesSetBackendServiceRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.SetBackendService(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaTargetTcpProxies.SetBackendService(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "TargetTcpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetBackendService",
		Version:   meta.Version("alpha"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCEAlphaTargetTcpProxies.SetBackendService(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaTargetTcpProxies.SetBackendService(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.TargetTcpProxies.SetBackendService(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaTargetTcpProxies.SetBackendService(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaTargetTcpProxies.SetBackendService(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaTargetTcpProxies is an interface that allows for mocking of TargetTcpProxies.
type BetaTargetTcpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetTcpProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetTcpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetTcpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetBackendService(context.Context, *meta.Key, *computebeta.TargetTcpProxiesSetBackendServiceRequest, ...Option) error
}

// NewMockBetaTargetTcpProxies returns a new mock for TargetTcpProxies.
func NewMockBetaTargetTcpProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetTcpProxiesObj) *MockBetaTargetTcpProxies {
	mock := &MockBetaTargetTcpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaTargetTcpProxies is the mock for TargetTcpProxies.
type MockBetaTargetTcpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetTcpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook               func(ctx context.Context, key *meta.Key, m *MockBetaTargetTcpProxies, options ...Option) (bool, *computebeta.TargetTcpProxy, error)
	ListHook              func(ctx context.Context, fl *filter.F, m *MockBetaTargetTcpProxies, options ...Option) (bool, []*computebeta.TargetTcpProxy, error)
	InsertHook            func(ctx context.Context, key *meta.Key, obj *computebeta.TargetTcpProxy, m *MockBetaTargetTcpProxies, options ...Option) (bool, error)
	DeleteHook            func(ctx context.Context, key *meta.Key, m *MockBetaTargetTcpProxies, options ...Option) (bool, error)
	SetBackendServiceHook func(context.Context, *meta.Key, *computebeta.TargetTcpProxiesSetBackendServiceRequest, *MockBetaTargetTcpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaTargetTcpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetTcpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetTcpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetTcpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaTargetTcpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaTargetTcpProxies %v not found", key),
	}
	klog.V(5).Infof("MockBetaTargetTcpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaTargetTcpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetTcpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetTcpProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaTargetTcpProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.TargetTcpProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaTargetTcpProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaTargetTcpProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetTcpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaTargetTcpProxies %v exists", key),
		}
		klog.V(5).Infof("MockBetaTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "targetTcpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "targetTcpProxies", key)

	m.Objects[*key] = &MockTargetTcpProxiesObj{obj}
	klog.V(5).Infof("MockBetaTargetTcpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaTargetTcpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaTargetTcpProxies %v not found", key),
		}
		klog.V(5).Infof("MockBetaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaTargetTcpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaTargetTcpProxies) Obj(o *computebeta.TargetTcpProxy) *MockTargetTcpProxiesObj {
	return &MockTargetTcpProxiesObj{o}
}

// SetBackendService is a mock for the corresponding method.
func (m *MockBetaTargetTcpProxies) SetBackendService(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetTcpProxiesSetBackendServiceRequest, options ...Option) error {
	if m.SetBackendServiceHook != nil {
		return m.SetBackendServiceHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaTargetTcpProxies is a simplifying adapter for the GCE TargetTcpProxies.
type GCEBetaTargetTcpProxies struct {
	s *Service
}

// Get the TargetTcpProxy named by key.
func (g *GCEBetaTargetTcpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.TargetTcpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetTcpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetTcpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "TargetTcpProxies",
	}

	klog.V(5).Infof("GCEBetaTargetTcpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.TargetTcpProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaTargetTcpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetTcpProxy objects.
func (g *GCEBetaTargetTcpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.TargetTcpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetTcpProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "TargetTcpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaTargetTcpProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.TargetTcpProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.TargetTcpProxy
	f := func(l *computebeta.TargetTcpProxyList) error {
		klog.V(5).Infof("GCEBetaTargetTcpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetTcpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaTargetTcpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetTcpProxy with key of value obj.
func (g *GCEBetaTargetTcpProxies) Insert(ctx context.Context, key *meta.Key, obj *computebeta.TargetTcpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetTcpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetTcpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCEBetaTargetTcpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.TargetTcpProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaTargetTcpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetTcpProxy referenced by key.
func (g *GCEBetaTargetTcpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetTcpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetTcpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetTcpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCEBetaTargetTcpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetTcpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetBackendService is a method on GCEBetaTargetTcpProxies.
func (g *GCEBetaTargetTcpProxies) SetBackendService(ctx context.Context, key *meta.Key, arg0 *computebeta.TargetTcpProxiesSetBackendServiceRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaTargetTcpProxies.SetBackendService(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaTargetTcpProxies.SetBackendService(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TargetTcpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetBackendService",
		Version:   meta.Version("beta"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCEBetaTargetTcpProxies.SetBackendService(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaTargetTcpProxies.SetBackendService(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.TargetTcpProxies.SetBackendService(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaTargetTcpProxies.SetBackendService(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaTargetTcpProxies.SetBackendService(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// TargetTcpProxies is an interface that allows for mocking of TargetTcpProxies.
type TargetTcpProxies interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetTcpProxy, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetTcpProxy, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.TargetTcpProxy, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	SetBackendService(context.Context, *meta.Key, *computega.TargetTcpProxiesSetBackendServiceRequest, ...Option) error
}

// NewMockTargetTcpProxies returns a new mock for TargetTcpProxies.
func NewMockTargetTcpProxies(pr ProjectRouter, objs map[meta.Key]*MockTargetTcpProxiesObj) *MockTargetTcpProxies {
	mock := &MockTargetTcpProxies{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTargetTcpProxies is the mock for TargetTcpProxies.
type MockTargetTcpProxies struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTargetTcpProxiesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook               func(ctx context.Context, key *meta.Key, m *MockTargetTcpProxies, options ...Option) (bool, *computega.TargetTcpProxy, error)
	ListHook              func(ctx context.Context, fl *filter.F, m *MockTargetTcpProxies, options ...Option) (bool, []*computega.TargetTcpProxy, error)
	InsertHook            func(ctx context.Context, key *meta.Key, obj *computega.TargetTcpProxy, m *MockTargetTcpProxies, options ...Option) (bool, error)
	DeleteHook            func(ctx context.Context, key *meta.Key, m *MockTargetTcpProxies, options ...Option) (bool, error)
	SetBackendServiceHook func(context.Context, *meta.Key, *computega.TargetTcpProxiesSetBackendServiceRequest, *MockTargetTcpProxies, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTargetTcpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetTcpProxy, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetTcpProxies.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockTargetTcpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockTargetTcpProxies.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTargetTcpProxies %v not found", key),
	}
	klog.V(5).Infof("MockTargetTcpProxies.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockTargetTcpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetTcpProxy, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockTargetTcpProxies.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockTargetTcpProxies.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.TargetTcpProxy
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockTargetTcpProxies.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTargetTcpProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetTcpProxy, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTargetTcpProxies %v exists", key),
		}
		klog.V(5).Infof("MockTargetTcpProxies.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "targetTcpProxies")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "targetTcpProxies", key)

	m.Objects[*key] = &MockTargetTcpProxiesObj{obj}
	klog.V(5).Infof("MockTargetTcpProxies.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTargetTcpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTargetTcpProxies %v not found", key),
		}
		klog.V(5).Infof("MockTargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockTargetTcpProxies.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockTargetTcpProxies) Obj(o *computega.TargetTcpProxy) *MockTargetTcpProxiesObj {
	return &MockTargetTcpProxiesObj{o}
}

// SetBackendService is a mock for the corresponding method.
func (m *MockTargetTcpProxies) SetBackendService(ctx context.Context, key *meta.Key, arg0 *computega.TargetTcpProxiesSetBackendServiceRequest, options ...Option) error {
	if m.SetBackendServiceHook != nil {
		return m.SetBackendServiceHook(ctx, key, arg0, m)
	}
	return nil
}

// GCETargetTcpProxies is a simplifying adapter for the GCE TargetTcpProxies.
type GCETargetTcpProxies struct {
	s *Service
}

// Get the TargetTcpProxy named by key.
func (g *GCETargetTcpProxies) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.TargetTcpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetTcpProxies.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetTcpProxies.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "TargetTcpProxies",
	}

	klog.V(5).Infof("GCETargetTcpProxies.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetTcpProxies.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.TargetTcpProxies.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCETargetTcpProxies.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TargetTcpProxy objects.
func (g *GCETargetTcpProxies) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.TargetTcpProxy, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetTcpProxies.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "TargetTcpProxies",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCETargetTcpProxies.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.TargetTcpProxies.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.TargetTcpProxy
	f := func(l *computega.TargetTcpProxyList) error {
		klog.V(5).Infof("GCETargetTcpProxies.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetTcpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCETargetTcpProxies.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCETargetTcpProxies.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TargetTcpProxy with key of value obj.
func (g *GCETargetTcpProxies) Insert(ctx context.Context, key *meta.Key, obj *computega.TargetTcpProxy, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetTcpProxies.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetTcpProxies.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetTcpProxies")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCETargetTcpProxies.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetTcpProxies.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.TargetTcpProxies.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetTcpProxies.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetTcpProxies.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TargetTcpProxy referenced by key.
func (g *GCETargetTcpProxies) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetTcpProxies.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCETargetTcpProxies.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetTcpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCETargetTcpProxies.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetTcpProxies.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetTcpProxies.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCETargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCETargetTcpProxies.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// SetBackendService is a method on GCETargetTcpProxies.
func (g *GCETargetTcpProxies) SetBackendService(ctx context.Context, key *meta.Key, arg0 *computega.TargetTcpProxiesSetBackendServiceRequest, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCETargetTcpProxies.SetBackendService(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCETargetTcpProxies.SetBackendService(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TargetTcpProxies")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "SetBackendService",
		Version:   meta.Version("ga"),
		Service:   "TargetTcpProxies",
	}
	klog.V(5).Infof("GCETargetTcpProxies.SetBackendService(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCETargetTcpProxies.SetBackendService(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.TargetTcpProxies.SetBackendService(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCETargetTcpProxies.SetBackendService(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCETargetTcpProxies.SetBackendService(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaUrlMaps is an interface that allows for mocking of UrlMaps.
type AlphaUrlMaps interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.UrlMap, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.UrlMap, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computealpha.UrlMap, ...Option) error
}

// NewMockAlphaUrlMaps returns a new mock for UrlMaps.
func NewMockAlphaUrlMaps(pr ProjectRouter, objs map[meta.Key]*MockUrlMapsObj) *MockAlphaUrlMaps {
	mock := &MockAlphaUrlMaps{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaUrlMaps is the mock for UrlMaps.
type MockAlphaUrlMaps struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockUrlMapsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaUrlMaps, options ...Option) (bool, *computealpha.UrlMap, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockAlphaUrlMaps, options ...Option) (bool, []*computealpha.UrlMap, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, m *MockAlphaUrlMaps, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaUrlMaps, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computealpha.UrlMap, *MockAlphaUrlMaps, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaUrlMaps.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaUrlMaps.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaUrlMaps %v not found", key),
	}
	klog.V(5).Infof("MockAlphaUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockAlphaUrlMaps) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaUrlMaps.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaUrlMaps.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.UrlMap
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaUrlMaps.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaUrlMaps %v exists", key),
		}
		klog.V(5).Infof("MockAlphaUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "urlMaps")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "urlMaps", key)

	m.Objects[*key] = &MockUrlMapsObj{obj}
	klog.V(5).Infof("MockAlphaUrlMaps.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaUrlMaps %v not found", key),
		}
		klog.V(5).Infof("MockAlphaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaUrlMaps.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaUrlMaps) Obj(o *computealpha.UrlMap) *MockUrlMapsObj {
	return &MockUrlMapsObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockAlphaUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMap, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaUrlMaps is a simplifying adapter for the GCE UrlMaps.
type GCEAlphaUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCEAlphaUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaUrlMaps.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaUrlMaps.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "UrlMaps",
	}

	klog.V(5).Infof("GCEAlphaUrlMaps.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaUrlMaps.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.UrlMaps.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaUrlMaps.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all UrlMap objects.
func (g *GCEAlphaUrlMaps) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computealpha.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaUrlMaps.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "UrlMaps",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaUrlMaps.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Alpha.UrlMaps.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.UrlMap
	f := func(l *computealpha.UrlMapList) error {
		klog.V(5).Infof("GCEAlphaUrlMaps.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaUrlMaps.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCEAlphaUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaUrlMaps.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaUrlMaps.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEAlphaUrlMaps.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaUrlMaps.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.UrlMaps.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaUrlMaps.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaUrlMaps.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the UrlMap referenced by key.
func (g *GCEAlphaUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaUrlMaps.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaUrlMaps.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "UrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEAlphaUrlMaps.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaUrlMaps.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.UrlMaps.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaUrlMaps.
func (g *GCEAlphaUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaUrlMaps.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaUrlMaps.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "UrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEAlphaUrlMaps.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaUrlMaps.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.UrlMaps.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaUrlMaps is an interface that allows for mocking of UrlMaps.
type BetaUrlMaps interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.UrlMap, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.UrlMap, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computebeta.UrlMap, ...Option) error
}

// NewMockBetaUrlMaps returns a new mock for UrlMaps.
func NewMockBetaUrlMaps(pr ProjectRouter, objs map[meta.Key]*MockUrlMapsObj) *MockBetaUrlMaps {
	mock := &MockBetaUrlMaps{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaUrlMaps is the mock for UrlMaps.
type MockBetaUrlMaps struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockUrlMapsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaUrlMaps, options ...Option) (bool, *computebeta.UrlMap, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaUrlMaps, options ...Option) (bool, []*computebeta.UrlMap, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, m *MockBetaUrlMaps, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaUrlMaps, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computebeta.UrlMap, *MockBetaUrlMaps, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaUrlMaps.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaUrlMaps.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaUrlMaps %v not found", key),
	}
	klog.V(5).Infof("MockBetaUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaUrlMaps) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaUrlMaps.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaUrlMaps.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.UrlMap
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaUrlMaps.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaUrlMaps %v exists", key),
		}
		klog.V(5).Infof("MockBetaUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "urlMaps")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "urlMaps", key)

	m.Objects[*key] = &MockUrlMapsObj{obj}
	klog.V(5).Infof("MockBetaUrlMaps.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaUrlMaps %v not found", key),
		}
		klog.V(5).Infof("MockBetaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaUrlMaps.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaUrlMaps) Obj(o *computebeta.UrlMap) *MockUrlMapsObj {
	return &MockUrlMapsObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockBetaUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMap, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaUrlMaps is a simplifying adapter for the GCE UrlMaps.
type GCEBetaUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCEBetaUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaUrlMaps.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaUrlMaps.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "UrlMaps",
	}

	klog.V(5).Infof("GCEBetaUrlMaps.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaUrlMaps.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.UrlMaps.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaUrlMaps.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all UrlMap objects.
func (g *GCEBetaUrlMaps) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computebeta.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaUrlMaps.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "UrlMaps",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaUrlMaps.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.Beta.UrlMaps.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.UrlMap
	f := func(l *computebeta.UrlMapList) error {
		klog.V(5).Infof("GCEBetaUrlMaps.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaUrlMaps.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCEBetaUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaUrlMaps.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaUrlMaps.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEBetaUrlMaps.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaUrlMaps.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.UrlMaps.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaUrlMaps.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaUrlMaps.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the UrlMap referenced by key.
func (g *GCEBetaUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaUrlMaps.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaUrlMaps.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "UrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEBetaUrlMaps.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaUrlMaps.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.UrlMaps.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaUrlMaps.
func (g *GCEBetaUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaUrlMaps.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaUrlMaps.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "UrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEBetaUrlMaps.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaUrlMaps.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.UrlMaps.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// UrlMaps is an interface that allows for mocking of UrlMaps.
type UrlMaps interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.UrlMap, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.UrlMap, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.UrlMap, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computega.UrlMap, ...Option) error
}

// NewMockUrlMaps returns a new mock for UrlMaps.
func NewMockUrlMaps(pr ProjectRouter, objs map[meta.Key]*MockUrlMapsObj) *MockUrlMaps {
	mock := &MockUrlMaps{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockUrlMaps is the mock for UrlMaps.
type MockUrlMaps struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockUrlMapsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockUrlMaps, options ...Option) (bool, *computega.UrlMap, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockUrlMaps, options ...Option) (bool, []*computega.UrlMap, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.UrlMap, m *MockUrlMaps, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockUrlMaps, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computega.UrlMap, *MockUrlMaps, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockUrlMaps.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockUrlMaps.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockUrlMaps %v not found", key),
	}
	klog.V(5).Infof("MockUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockUrlMaps) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockUrlMaps.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockUrlMaps.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.UrlMap
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockUrlMaps.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computega.UrlMap, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockUrlMaps %v exists", key),
		}
		klog.V(5).Infof("MockUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "urlMaps")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "urlMaps", key)

	m.Objects[*key] = &MockUrlMapsObj{obj}
	klog.V(5).Infof("MockUrlMaps.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockUrlMaps %v not found", key),
		}
		klog.V(5).Infof("MockUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockUrlMaps.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockUrlMaps) Obj(o *computega.UrlMap) *MockUrlMapsObj {
	return &MockUrlMapsObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computega.UrlMap, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEUrlMaps is a simplifying adapter for the GCE UrlMaps.
type GCEUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCEUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEUrlMaps.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEUrlMaps.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "UrlMaps",
	}

	klog.V(5).Infof("GCEUrlMaps.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEUrlMaps.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.UrlMaps.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEUrlMaps.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all UrlMap objects.
func (g *GCEUrlMaps) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEUrlMaps.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "UrlMaps",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEUrlMaps.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.UrlMaps.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.UrlMap
	f := func(l *computega.UrlMapList) error {
		klog.V(5).Infof("GCEUrlMaps.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEUrlMaps.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCEUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computega.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEUrlMaps.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEUrlMaps.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "UrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEUrlMaps.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEUrlMaps.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.UrlMaps.Insert(projectID, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEUrlMaps.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEUrlMaps.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the UrlMap referenced by key.
func (g *GCEUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEUrlMaps.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEUrlMaps.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "UrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEUrlMaps.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEUrlMaps.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.UrlMaps.Delete(projectID, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEUrlMaps.
func (g *GCEUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computega.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEUrlMaps.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEUrlMaps.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "UrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "UrlMaps",
	}
	klog.V(5).Infof("GCEUrlMaps.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEUrlMaps.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.UrlMaps.Update(projectID, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// AlphaRegionUrlMaps is an interface that allows for mocking of RegionUrlMaps.
type AlphaRegionUrlMaps interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.UrlMap, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.UrlMap, error)
	Insert(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computealpha.UrlMap, ...Option) error
}

// NewMockAlphaRegionUrlMaps returns a new mock for RegionUrlMaps.
func NewMockAlphaRegionUrlMaps(pr ProjectRouter, objs map[meta.Key]*MockRegionUrlMapsObj) *MockAlphaRegionUrlMaps {
	mock := &MockAlphaRegionUrlMaps{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockAlphaRegionUrlMaps is the mock for RegionUrlMaps.
type MockAlphaRegionUrlMaps struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionUrlMapsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockAlphaRegionUrlMaps, options ...Option) (bool, *computealpha.UrlMap, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockAlphaRegionUrlMaps, options ...Option) (bool, []*computealpha.UrlMap, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, m *MockAlphaRegionUrlMaps, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockAlphaRegionUrlMaps, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computealpha.UrlMap, *MockAlphaRegionUrlMaps, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockAlphaRegionUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionUrlMaps.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToAlpha()
		klog.V(5).Infof("MockAlphaRegionUrlMaps.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockAlphaRegionUrlMaps %v not found", key),
	}
	klog.V(5).Infof("MockAlphaRegionUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockAlphaRegionUrlMaps) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionUrlMaps.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockAlphaRegionUrlMaps.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computealpha.UrlMap
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToAlpha()) {
			continue
		}
		objs = append(objs, obj.ToAlpha())
	}

	klog.V(5).Infof("MockAlphaRegionUrlMaps.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockAlphaRegionUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockAlphaRegionUrlMaps %v exists", key),
		}
		klog.V(5).Infof("MockAlphaRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "alpha", "urlMaps")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionAlpha, projectID, "urlMaps", key)

	m.Objects[*key] = &MockRegionUrlMapsObj{obj}
	klog.V(5).Infof("MockAlphaRegionUrlMaps.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockAlphaRegionUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockAlphaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockAlphaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockAlphaRegionUrlMaps %v not found", key),
		}
		klog.V(5).Infof("MockAlphaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockAlphaRegionUrlMaps.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockAlphaRegionUrlMaps) Obj(o *computealpha.UrlMap) *MockRegionUrlMapsObj {
	return &MockRegionUrlMapsObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockAlphaRegionUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMap, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEAlphaRegionUrlMaps is a simplifying adapter for the GCE RegionUrlMaps.
type GCEAlphaRegionUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCEAlphaRegionUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computealpha.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionUrlMaps.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("alpha"),
		Service:   "RegionUrlMaps",
	}

	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Alpha.RegionUrlMaps.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEAlphaRegionUrlMaps.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all UrlMap objects.
func (g *GCEAlphaRegionUrlMaps) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computealpha.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("alpha"),
		Service:   "RegionUrlMaps",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Alpha.RegionUrlMaps.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computealpha.UrlMap
	f := func(l *computealpha.UrlMapList) error {
		klog.V(5).Infof("GCEAlphaRegionUrlMaps.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEAlphaRegionUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCEAlphaRegionUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computealpha.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionUrlMaps.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("alpha"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Alpha.RegionUrlMaps.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionUrlMaps.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the UrlMap referenced by key.
func (g *GCEAlphaRegionUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionUrlMaps.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionUrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("alpha"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionUrlMaps.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEAlphaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEAlphaRegionUrlMaps.
func (g *GCEAlphaRegionUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computealpha.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEAlphaRegionUrlMaps.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "alpha", "RegionUrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("alpha"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCEAlphaRegionUrlMaps.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Alpha.RegionUrlMaps.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEAlphaRegionUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEAlphaRegionUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaRegionUrlMaps is an interface that allows for mocking of RegionUrlMaps.
type BetaRegionUrlMaps interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.UrlMap, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.UrlMap, error)
	Insert(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computebeta.UrlMap, ...Option) error
}

// NewMockBetaRegionUrlMaps returns a new mock for RegionUrlMaps.
func NewMockBetaRegionUrlMaps(pr ProjectRouter, objs map[meta.Key]*MockRegionUrlMapsObj) *MockBetaRegionUrlMaps {
	mock := &MockBetaRegionUrlMaps{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaRegionUrlMaps is the mock for RegionUrlMaps.
type MockBetaRegionUrlMaps struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionUrlMapsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaRegionUrlMaps, options ...Option) (bool, *computebeta.UrlMap, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockBetaRegionUrlMaps, options ...Option) (bool, []*computebeta.UrlMap, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, m *MockBetaRegionUrlMaps, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaRegionUrlMaps, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computebeta.UrlMap, *MockBetaRegionUrlMaps, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaRegionUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionUrlMaps.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaRegionUrlMaps.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaRegionUrlMaps %v not found", key),
	}
	klog.V(5).Infof("MockBetaRegionUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockBetaRegionUrlMaps) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionUrlMaps.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaRegionUrlMaps.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computebeta.UrlMap
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaRegionUrlMaps.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaRegionUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaRegionUrlMaps %v exists", key),
		}
		klog.V(5).Infof("MockBetaRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "urlMaps")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionBeta, projectID, "urlMaps", key)

	m.Objects[*key] = &MockRegionUrlMapsObj{obj}
	klog.V(5).Infof("MockBetaRegionUrlMaps.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaRegionUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaRegionUrlMaps %v not found", key),
		}
		klog.V(5).Infof("MockBetaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaRegionUrlMaps.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaRegionUrlMaps) Obj(o *computebeta.UrlMap) *MockRegionUrlMapsObj {
	return &MockRegionUrlMapsObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockBetaRegionUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMap, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCEBetaRegionUrlMaps is a simplifying adapter for the GCE RegionUrlMaps.
type GCEBetaRegionUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCEBetaRegionUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computebeta.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionUrlMaps.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "RegionUrlMaps",
	}

	klog.V(5).Infof("GCEBetaRegionUrlMaps.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.Beta.RegionUrlMaps.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEBetaRegionUrlMaps.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all UrlMap objects.
func (g *GCEBetaRegionUrlMaps) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computebeta.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionUrlMaps.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "RegionUrlMaps",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEBetaRegionUrlMaps.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.Beta.RegionUrlMaps.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computebeta.UrlMap
	f := func(l *computebeta.UrlMapList) error {
		klog.V(5).Infof("GCEBetaRegionUrlMaps.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEBetaRegionUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCEBetaRegionUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computebeta.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionUrlMaps.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.Beta.RegionUrlMaps.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionUrlMaps.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the UrlMap referenced by key.
func (g *GCEBetaRegionUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionUrlMaps.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionUrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionUrlMaps.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCEBetaRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCEBetaRegionUrlMaps.
func (g *GCEBetaRegionUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computebeta.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEBetaRegionUrlMaps.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "RegionUrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("beta"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCEBetaRegionUrlMaps.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEBetaRegionUrlMaps.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.Beta.RegionUrlMaps.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEBetaRegionUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCEBetaRegionUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// RegionUrlMaps is an interface that allows for mocking of RegionUrlMaps.
type RegionUrlMaps interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.UrlMap, error)
	List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.UrlMap, error)
	Insert(ctx context.Context, key *meta.Key, obj *computega.UrlMap, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Update(context.Context, *meta.Key, *computega.UrlMap, ...Option) error
}

// NewMockRegionUrlMaps returns a new mock for RegionUrlMaps.
func NewMockRegionUrlMaps(pr ProjectRouter, objs map[meta.Key]*MockRegionUrlMapsObj) *MockRegionUrlMaps {
	mock := &MockRegionUrlMaps{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockRegionUrlMaps is the mock for RegionUrlMaps.
type MockRegionUrlMaps struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockRegionUrlMapsObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockRegionUrlMaps, options ...Option) (bool, *computega.UrlMap, error)
	ListHook   func(ctx context.Context, region string, fl *filter.F, m *MockRegionUrlMaps, options ...Option) (bool, []*computega.UrlMap, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *computega.UrlMap, m *MockRegionUrlMaps, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockRegionUrlMaps, options ...Option) (bool, error)
	UpdateHook func(context.Context, *meta.Key, *computega.UrlMap, *MockRegionUrlMaps, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockRegionUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.UrlMap, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionUrlMaps.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockRegionUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockRegionUrlMaps.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockRegionUrlMaps %v not found", key),
	}
	klog.V(5).Infof("MockRegionUrlMaps.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock in the given region.
func (m *MockRegionUrlMaps) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.UrlMap, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, region, fl, m, options...); intercept {
			klog.V(5).Infof("MockRegionUrlMaps.List(%v, %q, %v) = [%v items], %v", ctx, region, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockRegionUrlMaps.List(%v, %q, %v) = nil, %v", ctx, region, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.UrlMap
	for key, obj := range m.Objects {
		if key.Region != region {
			continue
		}
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockRegionUrlMaps.List(%v, %q, %v) = [%v items], nil", ctx, region, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockRegionUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computega.UrlMap, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockRegionUrlMaps %v exists", key),
		}
		klog.V(5).Infof("MockRegionUrlMaps.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "urlMaps")
	obj.SelfLink = SelfLinkWithGroup("compute", meta.VersionGA, projectID, "urlMaps", key)

	m.Objects[*key] = &MockRegionUrlMapsObj{obj}
	klog.V(5).Infof("MockRegionUrlMaps.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockRegionUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockRegionUrlMaps %v not found", key),
		}
		klog.V(5).Infof("MockRegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockRegionUrlMaps.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockRegionUrlMaps) Obj(o *computega.UrlMap) *MockRegionUrlMapsObj {
	return &MockRegionUrlMapsObj{o}
}

// Update is a mock for the corresponding method.
func (m *MockRegionUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computega.UrlMap, options ...Option) error {
	if m.UpdateHook != nil {
		return m.UpdateHook(ctx, key, arg0, m)
	}
	return nil
}

// GCERegionUrlMaps is a simplifying adapter for the GCE RegionUrlMaps.
type GCERegionUrlMaps struct {
	s *Service
}

// Get the UrlMap named by key.
func (g *GCERegionUrlMaps) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionUrlMaps.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionUrlMaps.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "RegionUrlMaps",
	}

	klog.V(5).Infof("GCERegionUrlMaps.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionUrlMaps.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.RegionUrlMaps.Get(projectID, key.Region, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCERegionUrlMaps.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all UrlMap objects.
func (g *GCERegionUrlMaps) List(ctx context.Context, region string, fl *filter.F, options ...Option) ([]*computega.UrlMap, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionUrlMaps.List(%v, %v, %v, %v) called", ctx, region, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "RegionUrlMaps",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCERegionUrlMaps.List(%v, %v, %v): projectID = %v, ck = %+v", ctx, region, fl, projectID, ck)
	call := g.s.GA.RegionUrlMaps.List(projectID, region)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.UrlMap
	f := func(l *computega.UrlMapList) error {
		klog.V(5).Infof("GCERegionUrlMaps.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCERegionUrlMaps.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCERegionUrlMaps.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert UrlMap with key of value obj.
func (g *GCERegionUrlMaps) Insert(ctx context.Context, key *meta.Key, obj *computega.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionUrlMaps.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionUrlMaps.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionUrlMaps")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCERegionUrlMaps.Insert(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionUrlMaps.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	call := g.s.GA.RegionUrlMaps.Insert(projectID, key.Region, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionUrlMaps.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionUrlMaps.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the UrlMap referenced by key.
func (g *GCERegionUrlMaps) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionUrlMaps.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("GCERegionUrlMaps.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionUrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCERegionUrlMaps.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionUrlMaps.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionUrlMaps.Delete(projectID, key.Region, key.Name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("GCERegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("GCERegionUrlMaps.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Update is a method on GCERegionUrlMaps.
func (g *GCERegionUrlMaps) Update(ctx context.Context, key *meta.Key, arg0 *computega.UrlMap, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCERegionUrlMaps.Update(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCERegionUrlMaps.Update(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "RegionUrlMaps")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Update",
		Version:   meta.Version("ga"),
		Service:   "RegionUrlMaps",
	}
	klog.V(5).Infof("GCERegionUrlMaps.Update(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCERegionUrlMaps.Update(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	call := g.s.GA.RegionUrlMaps.Update(projectID, key.Region, key.Name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCERegionUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("GCERegionUrlMaps.Update(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Zones is an interface that allows for mocking of Zones.
type Zones interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Zone, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Zone, error)
}

// NewMockZones returns a new mock for Zones.
func NewMockZones(pr ProjectRouter, objs map[meta.Key]*MockZonesObj) *MockZones {
	mock := &MockZones{
		ProjectRouter: pr,

		Objects:  objs,
		GetError: map[meta.Key]error{},
	}
	return mock
}

// MockZones is the mock for Zones.
type MockZones struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockZonesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError  map[meta.Key]error
	ListError *error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook  func(ctx context.Context, key *meta.Key, m *MockZones, options ...Option) (bool, *computega.Zone, error)
	ListHook func(ctx context.Context, fl *filter.F, m *MockZones, options ...Option) (bool, []*computega.Zone, error)

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockZones) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Zone, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockZones.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockZones.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockZones.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockZones %v not found", key),
	}
	klog.V(5).Infof("MockZones.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockZones) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Zone, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockZones.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockZones.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*computega.Zone
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockZones.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Obj wraps the object for use in the mock.
func (m *MockZones) Obj(o *computega.Zone) *MockZonesObj {
	return &MockZonesObj{o}
}

// GCEZones is a simplifying adapter for the GCE Zones.
type GCEZones struct {
	s *Service
}

// Get the Zone named by key.
func (g *GCEZones) Get(ctx context.Context, key *meta.Key, options ...Option) (*computega.Zone, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEZones.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("GCEZones.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Zones")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Zones",
	}

	klog.V(5).Infof("GCEZones.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("GCEZones.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	call := g.s.GA.Zones.Get(projectID, key.Name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("GCEZones.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Zone objects.
func (g *GCEZones) List(ctx context.Context, fl *filter.F, options ...Option) ([]*computega.Zone, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("GCEZones.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Zones")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Zones",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("GCEZones.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.GA.Zones.List(projectID)
	if fl != filter.None {
		call.Filter(fl.String())
	}

	var all []*computega.Zone
	f := func(l *computega.ZoneList) error {
		klog.V(5).Infof("GCEZones.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Items...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("GCEZones.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("GCEZones.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("GCEZones.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// TcpRoutes is an interface that allows for mocking of TcpRoutes.
type TcpRoutes interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesga.TcpRoute, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesga.TcpRoute, error)
	Insert(ctx context.Context, key *meta.Key, obj *networkservicesga.TcpRoute, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *networkservicesga.TcpRoute, ...Option) error
}

// NewMockTcpRoutes returns a new mock for TcpRoutes.
func NewMockTcpRoutes(pr ProjectRouter, objs map[meta.Key]*MockTcpRoutesObj) *MockTcpRoutes {
	mock := &MockTcpRoutes{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockTcpRoutes is the mock for TcpRoutes.
type MockTcpRoutes struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTcpRoutesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockTcpRoutes, options ...Option) (bool, *networkservicesga.TcpRoute, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockTcpRoutes, options ...Option) (bool, []*networkservicesga.TcpRoute, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *networkservicesga.TcpRoute, m *MockTcpRoutes, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockTcpRoutes, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *networkservicesga.TcpRoute, *MockTcpRoutes, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockTcpRoutes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesga.TcpRoute, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTcpRoutes.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockTcpRoutes.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockTcpRoutes.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockTcpRoutes %v not found", key),
	}
	klog.V(5).Infof("MockTcpRoutes.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockTcpRoutes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesga.TcpRoute, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockTcpRoutes.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockTcpRoutes.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*networkservicesga.TcpRoute
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockTcpRoutes.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockTcpRoutes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesga.TcpRoute, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockTcpRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockTcpRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockTcpRoutes %v exists", key),
		}
		klog.V(5).Infof("MockTcpRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "tcpRoutes")
	obj.SelfLink = SelfLinkWithGroup("networkservices", meta.VersionGA, projectID, "tcpRoutes", key)

	m.Objects[*key] = &MockTcpRoutesObj{obj}
	klog.V(5).Infof("MockTcpRoutes.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockTcpRoutes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockTcpRoutes %v not found", key),
		}
		klog.V(5).Infof("MockTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockTcpRoutes.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockTcpRoutes) Obj(o *networkservicesga.TcpRoute) *MockTcpRoutesObj {
	return &MockTcpRoutesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockTcpRoutes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesga.TcpRoute, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// TDTcpRoutes is a simplifying adapter for the GCE TcpRoutes.
type TDTcpRoutes struct {
	s *Service
}

// Get the TcpRoute named by key.
func (g *TDTcpRoutes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesga.TcpRoute, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDTcpRoutes.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDTcpRoutes.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TcpRoutes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "TcpRoutes",
	}

	klog.V(5).Infof("TDTcpRoutes.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDTcpRoutes.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	name := fmt.Sprintf("projects/%s/locations/global/tcpRoutes/%s", projectID, key.Name)
	call := g.s.NetworkServicesGA.TcpRoutes.Get(name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("TDTcpRoutes.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TcpRoute objects.
func (g *TDTcpRoutes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesga.TcpRoute, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDTcpRoutes.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TcpRoutes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "TcpRoutes",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("TDTcpRoutes.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.NetworkServicesGA.TcpRoutes.List(projectID)

	var all []*networkservicesga.TcpRoute
	f := func(l *networkservicesga.ListTcpRoutesResponse) error {
		klog.V(5).Infof("TDTcpRoutes.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.TcpRoutes...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDTcpRoutes.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("TDTcpRoutes.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("TDTcpRoutes.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TcpRoute with key of value obj.
func (g *TDTcpRoutes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesga.TcpRoute, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDTcpRoutes.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDTcpRoutes.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TcpRoutes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "TcpRoutes",
	}
	klog.V(5).Infof("TDTcpRoutes.Create(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDTcpRoutes.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	parent := fmt.Sprintf("projects/%s/locations/global", projectID)
	call := g.s.NetworkServicesGA.TcpRoutes.Create(parent, obj)
	call.TcpRouteId(obj.Name)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDTcpRoutes.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDTcpRoutes.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TcpRoute referenced by key.
func (g *TDTcpRoutes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDTcpRoutes.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDTcpRoutes.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TcpRoutes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "TcpRoutes",
	}
	klog.V(5).Infof("TDTcpRoutes.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDTcpRoutes.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/tcpRoutes/%s", projectID, key.Name)
	call := g.s.NetworkServicesGA.TcpRoutes.Delete(name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on TDTcpRoutes.
func (g *TDTcpRoutes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesga.TcpRoute, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDTcpRoutes.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDTcpRoutes.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "TcpRoutes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "TcpRoutes",
	}
	klog.V(5).Infof("TDTcpRoutes.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDTcpRoutes.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/tcpRoutes/%s", projectID, key.Name)
	call := g.s.NetworkServicesGA.TcpRoutes.Patch(name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDTcpRoutes.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("TDTcpRoutes.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaTcpRoutes is an interface that allows for mocking of TcpRoutes.
type BetaTcpRoutes interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesbeta.TcpRoute, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesbeta.TcpRoute, error)
	Insert(ctx context.Context, key *meta.Key, obj *networkservicesbeta.TcpRoute, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *networkservicesbeta.TcpRoute, ...Option) error
}

// NewMockBetaTcpRoutes returns a new mock for TcpRoutes.
func NewMockBetaTcpRoutes(pr ProjectRouter, objs map[meta.Key]*MockTcpRoutesObj) *MockBetaTcpRoutes {
	mock := &MockBetaTcpRoutes{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaTcpRoutes is the mock for TcpRoutes.
type MockBetaTcpRoutes struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockTcpRoutesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaTcpRoutes, options ...Option) (bool, *networkservicesbeta.TcpRoute, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaTcpRoutes, options ...Option) (bool, []*networkservicesbeta.TcpRoute, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *networkservicesbeta.TcpRoute, m *MockBetaTcpRoutes, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaTcpRoutes, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *networkservicesbeta.TcpRoute, *MockBetaTcpRoutes, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaTcpRoutes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesbeta.TcpRoute, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTcpRoutes.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaTcpRoutes.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaTcpRoutes.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaTcpRoutes %v not found", key),
	}
	klog.V(5).Infof("MockBetaTcpRoutes.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaTcpRoutes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesbeta.TcpRoute, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaTcpRoutes.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaTcpRoutes.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*networkservicesbeta.TcpRoute
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaTcpRoutes.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaTcpRoutes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesbeta.TcpRoute, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaTcpRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaTcpRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaTcpRoutes %v exists", key),
		}
		klog.V(5).Infof("MockBetaTcpRoutes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "tcpRoutes")
	obj.SelfLink = SelfLinkWithGroup("networkservices", meta.VersionBeta, projectID, "tcpRoutes", key)

	m.Objects[*key] = &MockTcpRoutesObj{obj}
	klog.V(5).Infof("MockBetaTcpRoutes.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaTcpRoutes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaTcpRoutes %v not found", key),
		}
		klog.V(5).Infof("MockBetaTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaTcpRoutes.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaTcpRoutes) Obj(o *networkservicesbeta.TcpRoute) *MockTcpRoutesObj {
	return &MockTcpRoutesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockBetaTcpRoutes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesbeta.TcpRoute, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// TDBetaTcpRoutes is a simplifying adapter for the GCE TcpRoutes.
type TDBetaTcpRoutes struct {
	s *Service
}

// Get the TcpRoute named by key.
func (g *TDBetaTcpRoutes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesbeta.TcpRoute, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaTcpRoutes.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDBetaTcpRoutes.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TcpRoutes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "TcpRoutes",
	}

	klog.V(5).Infof("TDBetaTcpRoutes.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaTcpRoutes.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	name := fmt.Sprintf("projects/%s/locations/global/tcpRoutes/%s", projectID, key.Name)
	call := g.s.NetworkServicesBeta.TcpRoutes.Get(name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("TDBetaTcpRoutes.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all TcpRoute objects.
func (g *TDBetaTcpRoutes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesbeta.TcpRoute, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaTcpRoutes.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TcpRoutes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "TcpRoutes",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("TDBetaTcpRoutes.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.NetworkServicesBeta.TcpRoutes.List(projectID)

	var all []*networkservicesbeta.TcpRoute
	f := func(l *networkservicesbeta.ListTcpRoutesResponse) error {
		klog.V(5).Infof("TDBetaTcpRoutes.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.TcpRoutes...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDBetaTcpRoutes.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("TDBetaTcpRoutes.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("TDBetaTcpRoutes.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert TcpRoute with key of value obj.
func (g *TDBetaTcpRoutes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesbeta.TcpRoute, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaTcpRoutes.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDBetaTcpRoutes.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TcpRoutes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "TcpRoutes",
	}
	klog.V(5).Infof("TDBetaTcpRoutes.Create(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaTcpRoutes.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	parent := fmt.Sprintf("projects/%s/locations/global", projectID)
	call := g.s.NetworkServicesBeta.TcpRoutes.Create(parent, obj)
	call.TcpRouteId(obj.Name)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDBetaTcpRoutes.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDBetaTcpRoutes.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the TcpRoute referenced by key.
func (g *TDBetaTcpRoutes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaTcpRoutes.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDBetaTcpRoutes.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TcpRoutes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "TcpRoutes",
	}
	klog.V(5).Infof("TDBetaTcpRoutes.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaTcpRoutes.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/tcpRoutes/%s", projectID, key.Name)
	call := g.s.NetworkServicesBeta.TcpRoutes.Delete(name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDBetaTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDBetaTcpRoutes.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on TDBetaTcpRoutes.
func (g *TDBetaTcpRoutes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesbeta.TcpRoute, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaTcpRoutes.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDBetaTcpRoutes.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "TcpRoutes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "TcpRoutes",
	}
	klog.V(5).Infof("TDBetaTcpRoutes.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaTcpRoutes.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/tcpRoutes/%s", projectID, key.Name)
	call := g.s.NetworkServicesBeta.TcpRoutes.Patch(name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDBetaTcpRoutes.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("TDBetaTcpRoutes.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// Meshes is an interface that allows for mocking of Meshes.
type Meshes interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesga.Mesh, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesga.Mesh, error)
	Insert(ctx context.Context, key *meta.Key, obj *networkservicesga.Mesh, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *networkservicesga.Mesh, ...Option) error
}

// NewMockMeshes returns a new mock for Meshes.
func NewMockMeshes(pr ProjectRouter, objs map[meta.Key]*MockMeshesObj) *MockMeshes {
	mock := &MockMeshes{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockMeshes is the mock for Meshes.
type MockMeshes struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockMeshesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockMeshes, options ...Option) (bool, *networkservicesga.Mesh, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockMeshes, options ...Option) (bool, []*networkservicesga.Mesh, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *networkservicesga.Mesh, m *MockMeshes, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockMeshes, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *networkservicesga.Mesh, *MockMeshes, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockMeshes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesga.Mesh, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockMeshes.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockMeshes.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToGA()
		klog.V(5).Infof("MockMeshes.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockMeshes %v not found", key),
	}
	klog.V(5).Infof("MockMeshes.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockMeshes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesga.Mesh, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockMeshes.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockMeshes.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*networkservicesga.Mesh
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToGA()) {
			continue
		}
		objs = append(objs, obj.ToGA())
	}

	klog.V(5).Infof("MockMeshes.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockMeshes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesga.Mesh, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockMeshes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockMeshes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockMeshes %v exists", key),
		}
		klog.V(5).Infof("MockMeshes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "ga", "meshes")
	obj.SelfLink = SelfLinkWithGroup("networkservices", meta.VersionGA, projectID, "meshes", key)

	m.Objects[*key] = &MockMeshesObj{obj}
	klog.V(5).Infof("MockMeshes.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockMeshes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockMeshes.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockMeshes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockMeshes %v not found", key),
		}
		klog.V(5).Infof("MockMeshes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockMeshes.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockMeshes) Obj(o *networkservicesga.Mesh) *MockMeshesObj {
	return &MockMeshesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockMeshes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesga.Mesh, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// TDMeshes is a simplifying adapter for the GCE Meshes.
type TDMeshes struct {
	s *Service
}

// Get the Mesh named by key.
func (g *TDMeshes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesga.Mesh, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDMeshes.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDMeshes.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Meshes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("ga"),
		Service:   "Meshes",
	}

	klog.V(5).Infof("TDMeshes.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDMeshes.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	name := fmt.Sprintf("projects/%s/locations/global/meshes/%s", projectID, key.Name)
	call := g.s.NetworkServicesGA.Meshes.Get(name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("TDMeshes.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Mesh objects.
func (g *TDMeshes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesga.Mesh, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDMeshes.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Meshes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("ga"),
		Service:   "Meshes",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("TDMeshes.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.NetworkServicesGA.Meshes.List(projectID)

	var all []*networkservicesga.Mesh
	f := func(l *networkservicesga.ListMeshesResponse) error {
		klog.V(5).Infof("TDMeshes.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Meshes...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDMeshes.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("TDMeshes.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("TDMeshes.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Mesh with key of value obj.
func (g *TDMeshes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesga.Mesh, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDMeshes.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDMeshes.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Meshes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("ga"),
		Service:   "Meshes",
	}
	klog.V(5).Infof("TDMeshes.Create(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDMeshes.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	parent := fmt.Sprintf("projects/%s/locations/global", projectID)
	call := g.s.NetworkServicesGA.Meshes.Create(parent, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDMeshes.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDMeshes.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Mesh referenced by key.
func (g *TDMeshes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDMeshes.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDMeshes.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Meshes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("ga"),
		Service:   "Meshes",
	}
	klog.V(5).Infof("TDMeshes.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDMeshes.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/meshes/%s", projectID, key.Name)
	call := g.s.NetworkServicesGA.Meshes.Delete(name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDMeshes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDMeshes.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on TDMeshes.
func (g *TDMeshes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesga.Mesh, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDMeshes.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDMeshes.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "ga", "Meshes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("ga"),
		Service:   "Meshes",
	}
	klog.V(5).Infof("TDMeshes.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDMeshes.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/meshes/%s", projectID, key.Name)
	call := g.s.NetworkServicesGA.Meshes.Patch(name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDMeshes.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("TDMeshes.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// BetaMeshes is an interface that allows for mocking of Meshes.
type BetaMeshes interface {
	Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesbeta.Mesh, error)
	List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesbeta.Mesh, error)
	Insert(ctx context.Context, key *meta.Key, obj *networkservicesbeta.Mesh, options ...Option) error
	Delete(ctx context.Context, key *meta.Key, options ...Option) error
	Patch(context.Context, *meta.Key, *networkservicesbeta.Mesh, ...Option) error
}

// NewMockBetaMeshes returns a new mock for Meshes.
func NewMockBetaMeshes(pr ProjectRouter, objs map[meta.Key]*MockMeshesObj) *MockBetaMeshes {
	mock := &MockBetaMeshes{
		ProjectRouter: pr,

		Objects:     objs,
		GetError:    map[meta.Key]error{},
		InsertError: map[meta.Key]error{},
		DeleteError: map[meta.Key]error{},
	}
	return mock
}

// MockBetaMeshes is the mock for Meshes.
type MockBetaMeshes struct {
	Lock sync.Mutex

	ProjectRouter ProjectRouter

	// Objects maintained by the mock.
	Objects map[meta.Key]*MockMeshesObj

	// If an entry exists for the given key and operation, then the error
	// will be returned instead of the operation.
	GetError    map[meta.Key]error
	ListError   *error
	InsertError map[meta.Key]error
	DeleteError map[meta.Key]error

	// xxxHook allow you to intercept the standard processing of the mock in
	// order to add your own logic. Return (true, _, _) to prevent the normal
	// execution flow of the mock. Return (false, nil, nil) to continue with
	// normal mock behavior/ after the hook function executes.
	GetHook    func(ctx context.Context, key *meta.Key, m *MockBetaMeshes, options ...Option) (bool, *networkservicesbeta.Mesh, error)
	ListHook   func(ctx context.Context, fl *filter.F, m *MockBetaMeshes, options ...Option) (bool, []*networkservicesbeta.Mesh, error)
	InsertHook func(ctx context.Context, key *meta.Key, obj *networkservicesbeta.Mesh, m *MockBetaMeshes, options ...Option) (bool, error)
	DeleteHook func(ctx context.Context, key *meta.Key, m *MockBetaMeshes, options ...Option) (bool, error)
	PatchHook  func(context.Context, *meta.Key, *networkservicesbeta.Mesh, *MockBetaMeshes, ...Option) error

	// X is extra state that can be used as part of the mock. Generated code
	// will not use this field.
	X interface{}
}

// Get returns the object from the mock.
func (m *MockBetaMeshes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesbeta.Mesh, error) {
	if m.GetHook != nil {
		if intercept, obj, err := m.GetHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaMeshes.Get(%v, %s) = %+v, %v", ctx, key, obj, err)
			return obj, err
		}
	}
	if !key.Valid() {
		return nil, fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.GetError[*key]; ok {
		klog.V(5).Infof("MockBetaMeshes.Get(%v, %s) = nil, %v", ctx, key, err)
		return nil, err
	}
	if obj, ok := m.Objects[*key]; ok {
		typedObj := obj.ToBeta()
		klog.V(5).Infof("MockBetaMeshes.Get(%v, %s) = %+v, nil", ctx, key, typedObj)
		return typedObj, nil
	}

	err := &googleapi.Error{
		Code:    http.StatusNotFound,
		Message: fmt.Sprintf("MockBetaMeshes %v not found", key),
	}
	klog.V(5).Infof("MockBetaMeshes.Get(%v, %s) = nil, %v", ctx, key, err)
	return nil, err
}

// List all of the objects in the mock.
func (m *MockBetaMeshes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesbeta.Mesh, error) {
	if m.ListHook != nil {
		if intercept, objs, err := m.ListHook(ctx, fl, m, options...); intercept {
			klog.V(5).Infof("MockBetaMeshes.List(%v, %v) = [%v items], %v", ctx, fl, len(objs), err)
			return objs, err
		}
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if m.ListError != nil {
		err := *m.ListError
		klog.V(5).Infof("MockBetaMeshes.List(%v, %v) = nil, %v", ctx, fl, err)

		return nil, *m.ListError
	}

	var objs []*networkservicesbeta.Mesh
	for _, obj := range m.Objects {
		if !fl.Match(obj.ToBeta()) {
			continue
		}
		objs = append(objs, obj.ToBeta())
	}

	klog.V(5).Infof("MockBetaMeshes.List(%v, %v) = [%v items], nil", ctx, fl, len(objs))
	return objs, nil
}

// Insert is a mock for inserting/creating a new object.
func (m *MockBetaMeshes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesbeta.Mesh, options ...Option) error {
	if m.InsertHook != nil {
		if intercept, err := m.InsertHook(ctx, key, obj, m, options...); intercept {
			klog.V(5).Infof("MockBetaMeshes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
			return err
		}
	}
	opts := mergeOptions(options)
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.InsertError[*key]; ok {
		klog.V(5).Infof("MockBetaMeshes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}
	if _, ok := m.Objects[*key]; ok {
		err := &googleapi.Error{
			Code:    http.StatusConflict,
			Message: fmt.Sprintf("MockBetaMeshes %v exists", key),
		}
		klog.V(5).Infof("MockBetaMeshes.Insert(%v, %v, %+v) = %v", ctx, key, obj, err)
		return err
	}

	obj.Name = key.Name
	projectID := getProjectID(ctx, m.ProjectRouter, opts, "beta", "meshes")
	obj.SelfLink = SelfLinkWithGroup("networkservices", meta.VersionBeta, projectID, "meshes", key)

	m.Objects[*key] = &MockMeshesObj{obj}
	klog.V(5).Infof("MockBetaMeshes.Insert(%v, %v, %+v) = nil", ctx, key, obj)
	return nil
}

// Delete is a mock for deleting the object.
func (m *MockBetaMeshes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	if m.DeleteHook != nil {
		if intercept, err := m.DeleteHook(ctx, key, m, options...); intercept {
			klog.V(5).Infof("MockBetaMeshes.Delete(%v, %v) = %v", ctx, key, err)
			return err
		}
	}
	if !key.Valid() {
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	m.Lock.Lock()
	defer m.Lock.Unlock()

	if err, ok := m.DeleteError[*key]; ok {
		klog.V(5).Infof("MockBetaMeshes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}
	if _, ok := m.Objects[*key]; !ok {
		err := &googleapi.Error{
			Code:    http.StatusNotFound,
			Message: fmt.Sprintf("MockBetaMeshes %v not found", key),
		}
		klog.V(5).Infof("MockBetaMeshes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	delete(m.Objects, *key)
	klog.V(5).Infof("MockBetaMeshes.Delete(%v, %v) = nil", ctx, key)
	return nil
}

// Obj wraps the object for use in the mock.
func (m *MockBetaMeshes) Obj(o *networkservicesbeta.Mesh) *MockMeshesObj {
	return &MockMeshesObj{o}
}

// Patch is a mock for the corresponding method.
func (m *MockBetaMeshes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesbeta.Mesh, options ...Option) error {
	if m.PatchHook != nil {
		return m.PatchHook(ctx, key, arg0, m)
	}
	return nil
}

// TDBetaMeshes is a simplifying adapter for the GCE Meshes.
type TDBetaMeshes struct {
	s *Service
}

// Get the Mesh named by key.
func (g *TDBetaMeshes) Get(ctx context.Context, key *meta.Key, options ...Option) (*networkservicesbeta.Mesh, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaMeshes.Get(%v, %v, %v): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDBetaMeshes.Get(%v, %v): key is invalid (%#v)", ctx, key, key)
		return nil, fmt.Errorf("invalid GCE key (%#v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Meshes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Get",
		Version:   meta.Version("beta"),
		Service:   "Meshes",
	}

	klog.V(5).Infof("TDBetaMeshes.Get(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaMeshes.Get(%v, %v): RateLimiter error: %v", ctx, key, err)
		return nil, err
	}
	name := fmt.Sprintf("projects/%s/locations/global/meshes/%s", projectID, key.Name)
	call := g.s.NetworkServicesBeta.Meshes.Get(name)
	call.Context(ctx)
	v, err := call.Do()
	klog.V(4).Infof("TDBetaMeshes.Get(%v, %v) = %+v, %v", ctx, key, v, err)

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	return v, err
}

// List all Mesh objects.
func (g *TDBetaMeshes) List(ctx context.Context, fl *filter.F, options ...Option) ([]*networkservicesbeta.Mesh, error) {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaMeshes.List(%v, %v, %v) called", ctx, fl, opts)
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Meshes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "List",
		Version:   meta.Version("beta"),
		Service:   "Meshes",
	}

	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		return nil, err
	}
	klog.V(5).Infof("TDBetaMeshes.List(%v, %v): projectID = %v, ck = %+v", ctx, fl, projectID, ck)
	call := g.s.NetworkServicesBeta.Meshes.List(projectID)

	var all []*networkservicesbeta.Mesh
	f := func(l *networkservicesbeta.ListMeshesResponse) error {
		klog.V(5).Infof("TDBetaMeshes.List(%v, ..., %v): page %+v", ctx, fl, l)
		all = append(all, l.Meshes...)
		return nil
	}
	if err := call.Pages(ctx, f); err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDBetaMeshes.List(%v, ..., %v) = %v, %v", ctx, fl, nil, err)
		return nil, err
	}

	callObserverEnd(ctx, ck, nil)
	g.s.RateLimiter.Observe(ctx, nil, ck)

	if kLogEnabled(4) {
		klog.V(4).Infof("TDBetaMeshes.List(%v, ..., %v) = [%v items], %v", ctx, fl, len(all), nil)
	} else if kLogEnabled(5) {
		var asStr []string
		for _, o := range all {
			asStr = append(asStr, fmt.Sprintf("%+v", o))
		}
		klog.V(5).Infof("TDBetaMeshes.List(%v, ..., %v) = %v, %v", ctx, fl, asStr, nil)
	}

	return all, nil
}

// Insert Mesh with key of value obj.
func (g *TDBetaMeshes) Insert(ctx context.Context, key *meta.Key, obj *networkservicesbeta.Mesh, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaMeshes.Insert(%v, %v, %+v, %v): called", ctx, key, obj, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDBetaMeshes.Insert(%v, %v, ...): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Meshes")

	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Insert",
		Version:   meta.Version("beta"),
		Service:   "Meshes",
	}
	klog.V(5).Infof("TDBetaMeshes.Create(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaMeshes.Insert(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	obj.Name = key.Name
	parent := fmt.Sprintf("projects/%s/locations/global", projectID)
	call := g.s.NetworkServicesBeta.Meshes.Create(parent, obj)
	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDBetaMeshes.Insert(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDBetaMeshes.Insert(%v, %v, %+v) = %+v", ctx, key, obj, err)
	return err
}

// Delete the Mesh referenced by key.
func (g *TDBetaMeshes) Delete(ctx context.Context, key *meta.Key, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaMeshes.Delete(%v, %v, %v): called", ctx, key, opts)
	if !key.Valid() {
		klog.V(2).Infof("TDBetaMeshes.Delete(%v, %v): key is invalid (%#v)", ctx, key, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}

	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Meshes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Delete",
		Version:   meta.Version("beta"),
		Service:   "Meshes",
	}
	klog.V(5).Infof("TDBetaMeshes.Delete(%v, %v): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaMeshes.Delete(%v, %v): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/meshes/%s", projectID, key.Name)
	call := g.s.NetworkServicesBeta.Meshes.Delete(name)

	call.Context(ctx)

	op, err := call.Do()

	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck)

	if err != nil {
		klog.V(4).Infof("TDBetaMeshes.Delete(%v, %v) = %v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	klog.V(4).Infof("TDBetaMeshes.Delete(%v, %v) = %v", ctx, key, err)
	return err
}

// Patch is a method on TDBetaMeshes.
func (g *TDBetaMeshes) Patch(ctx context.Context, key *meta.Key, arg0 *networkservicesbeta.Mesh, options ...Option) error {
	opts := mergeOptions(options)
	klog.V(5).Infof("TDBetaMeshes.Patch(%v, %v, %v, ...): called", ctx, key, opts)

	if !key.Valid() {
		klog.V(2).Infof("TDBetaMeshes.Patch(%v, %v, %v, ...): key is invalid (%#v)", ctx, key, opts, key)
		return fmt.Errorf("invalid GCE key (%+v)", key)
	}
	projectID := getProjectID(ctx, g.s.ProjectRouter, opts, "beta", "Meshes")
	ck := &CallContextKey{
		ProjectID: projectID,
		Operation: "Patch",
		Version:   meta.Version("beta"),
		Service:   "Meshes",
	}
	klog.V(5).Infof("TDBetaMeshes.Patch(%v, %v, ...): projectID = %v, ck = %+v", ctx, key, projectID, ck)
	callObserverStart(ctx, ck)
	if err := g.s.RateLimiter.Accept(ctx, ck); err != nil {
		klog.V(4).Infof("TDBetaMeshes.Patch(%v, %v, ...): RateLimiter error: %v", ctx, key, err)
		return err
	}
	name := fmt.Sprintf("projects/%s/locations/global/meshes/%s", projectID, key.Name)
	call := g.s.NetworkServicesBeta.Meshes.Patch(name, arg0)
	call.Context(ctx)
	op, err := call.Do()

	if err != nil {
		callObserverEnd(ctx, ck, err)
		g.s.RateLimiter.Observe(ctx, err, ck)

		klog.V(4).Infof("TDBetaMeshes.Patch(%v, %v, ...) = %+v", ctx, key, err)
		return err
	}

	err = g.s.WaitForCompletion(ctx, op)
	callObserverEnd(ctx, ck, err)
	g.s.RateLimiter.Observe(ctx, err, ck) // XXX

	klog.V(4).Infof("TDBetaMeshes.Patch(%v, %v, ...) = %+v", ctx, key, err)
	return err
}

// NewAddressesResourceID creates a ResourceID for the Addresses resource.
func NewAddressesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "addresses", key}
}

// NewBackendServicesResourceID creates a ResourceID for the BackendServices resource.
func NewBackendServicesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "backendServices", key}
}

// NewDisksResourceID creates a ResourceID for the Disks resource.
func NewDisksResourceID(project, zone, name string) *ResourceID {
	key := meta.ZonalKey(name, zone)
	return &ResourceID{project, "compute", "disks", key}
}

// NewFirewallsResourceID creates a ResourceID for the Firewalls resource.
func NewFirewallsResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "firewalls", key}
}

// NewForwardingRulesResourceID creates a ResourceID for the ForwardingRules resource.
func NewForwardingRulesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "forwardingRules", key}
}

// NewGlobalAddressesResourceID creates a ResourceID for the GlobalAddresses resource.
func NewGlobalAddressesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "addresses", key}
}

// NewGlobalForwardingRulesResourceID creates a ResourceID for the GlobalForwardingRules resource.
func NewGlobalForwardingRulesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "forwardingRules", key}
}

// NewGlobalNetworkEndpointGroupsResourceID creates a ResourceID for the GlobalNetworkEndpointGroups resource.
func NewGlobalNetworkEndpointGroupsResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "networkEndpointGroups", key}
}

// NewHealthChecksResourceID creates a ResourceID for the HealthChecks resource.
func NewHealthChecksResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "healthChecks", key}
}

// NewHttpHealthChecksResourceID creates a ResourceID for the HttpHealthChecks resource.
func NewHttpHealthChecksResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "httpHealthChecks", key}
}

// NewHttpsHealthChecksResourceID creates a ResourceID for the HttpsHealthChecks resource.
func NewHttpsHealthChecksResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "httpsHealthChecks", key}
}

// NewImagesResourceID creates a ResourceID for the Images resource.
func NewImagesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "Images", key}
}

// NewInstanceGroupManagersResourceID creates a ResourceID for the InstanceGroupManagers resource.
func NewInstanceGroupManagersResourceID(project, zone, name string) *ResourceID {
	key := meta.ZonalKey(name, zone)
	return &ResourceID{project, "compute", "instanceGroupManagers", key}
}

// NewInstanceGroupsResourceID creates a ResourceID for the InstanceGroups resource.
func NewInstanceGroupsResourceID(project, zone, name string) *ResourceID {
	key := meta.ZonalKey(name, zone)
	return &ResourceID{project, "compute", "instanceGroups", key}
}

// NewInstanceTemplatesResourceID creates a ResourceID for the InstanceTemplates resource.
func NewInstanceTemplatesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "instanceTemplates", key}
}

// NewInstancesResourceID creates a ResourceID for the Instances resource.
func NewInstancesResourceID(project, zone, name string) *ResourceID {
	key := meta.ZonalKey(name, zone)
	return &ResourceID{project, "compute", "instances", key}
}

// NewMeshesResourceID creates a ResourceID for the Meshes resource.
func NewMeshesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "networkservices", "meshes", key}
}

// NewNetworkEndpointGroupsResourceID creates a ResourceID for the NetworkEndpointGroups resource.
func NewNetworkEndpointGroupsResourceID(project, zone, name string) *ResourceID {
	key := meta.ZonalKey(name, zone)
	return &ResourceID{project, "compute", "networkEndpointGroups", key}
}

// NewNetworkFirewallPoliciesResourceID creates a ResourceID for the NetworkFirewallPolicies resource.
func NewNetworkFirewallPoliciesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "networkFirewallPolicies", key}
}

// NewNetworksResourceID creates a ResourceID for the Networks resource.
func NewNetworksResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "networks", key}
}

// NewProjectsResourceID creates a ResourceID for the Projects resource.
func NewProjectsResourceID(project string) *ResourceID {
	var key *meta.Key
	return &ResourceID{project, "compute", "projects", key}
}

// NewRegionBackendServicesResourceID creates a ResourceID for the RegionBackendServices resource.
func NewRegionBackendServicesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "backendServices", key}
}

// NewRegionDisksResourceID creates a ResourceID for the RegionDisks resource.
func NewRegionDisksResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "disks", key}
}

// NewRegionHealthChecksResourceID creates a ResourceID for the RegionHealthChecks resource.
func NewRegionHealthChecksResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "healthChecks", key}
}

// NewRegionNetworkFirewallPoliciesResourceID creates a ResourceID for the RegionNetworkFirewallPolicies resource.
func NewRegionNetworkFirewallPoliciesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "regionNetworkFirewallPolicies", key}
}

// NewRegionSslCertificatesResourceID creates a ResourceID for the RegionSslCertificates resource.
func NewRegionSslCertificatesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "sslCertificates", key}
}

// NewRegionSslPoliciesResourceID creates a ResourceID for the RegionSslPolicies resource.
func NewRegionSslPoliciesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "sslPolicies", key}
}

// NewRegionTargetHttpProxiesResourceID creates a ResourceID for the RegionTargetHttpProxies resource.
func NewRegionTargetHttpProxiesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "targetHttpProxies", key}
}

// NewRegionTargetHttpsProxiesResourceID creates a ResourceID for the RegionTargetHttpsProxies resource.
func NewRegionTargetHttpsProxiesResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "targetHttpsProxies", key}
}

// NewRegionUrlMapsResourceID creates a ResourceID for the RegionUrlMaps resource.
func NewRegionUrlMapsResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "urlMaps", key}
}

// NewRegionsResourceID creates a ResourceID for the Regions resource.
func NewRegionsResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "regions", key}
}

// NewRoutersResourceID creates a ResourceID for the Routers resource.
func NewRoutersResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "routers", key}
}

// NewRoutesResourceID creates a ResourceID for the Routes resource.
func NewRoutesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "routes", key}
}

// NewSecurityPoliciesResourceID creates a ResourceID for the SecurityPolicies resource.
func NewSecurityPoliciesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "securityPolicies", key}
}

// NewServiceAttachmentsResourceID creates a ResourceID for the ServiceAttachments resource.
func NewServiceAttachmentsResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "serviceAttachments", key}
}

// NewSslCertificatesResourceID creates a ResourceID for the SslCertificates resource.
func NewSslCertificatesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "sslCertificates", key}
}

// NewSslPoliciesResourceID creates a ResourceID for the SslPolicies resource.
func NewSslPoliciesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "sslPolicies", key}
}

// NewSubnetworksResourceID creates a ResourceID for the Subnetworks resource.
func NewSubnetworksResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "subnetworks", key}
}

// NewTargetHttpProxiesResourceID creates a ResourceID for the TargetHttpProxies resource.
func NewTargetHttpProxiesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "targetHttpProxies", key}
}

// NewTargetHttpsProxiesResourceID creates a ResourceID for the TargetHttpsProxies resource.
func NewTargetHttpsProxiesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "targetHttpsProxies", key}
}

// NewTargetPoolsResourceID creates a ResourceID for the TargetPools resource.
func NewTargetPoolsResourceID(project, region, name string) *ResourceID {
	key := meta.RegionalKey(name, region)
	return &ResourceID{project, "compute", "targetPools", key}
}

// NewTargetTcpProxiesResourceID creates a ResourceID for the TargetTcpProxies resource.
func NewTargetTcpProxiesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "targetTcpProxies", key}
}

// NewTcpRoutesResourceID creates a ResourceID for the TcpRoutes resource.
func NewTcpRoutesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "networkservices", "tcpRoutes", key}
}

// NewUrlMapsResourceID creates a ResourceID for the UrlMaps resource.
func NewUrlMapsResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "urlMaps", key}
}

// NewZonesResourceID creates a ResourceID for the Zones resource.
func NewZonesResourceID(project, name string) *ResourceID {
	key := meta.GlobalKey(name)
	return &ResourceID{project, "compute", "zones", key}
}
